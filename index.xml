<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>主要内容 on OS Learning</title><link>http://shipengqi.github.io/os-learn/</link><description>Recent content in 主要内容 on OS Learning</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="http://shipengqi.github.io/os-learn/index.xml" rel="self" type="application/rss+xml"/><item><title>查看文件内容</title><link>http://shipengqi.github.io/os-learn/docs/commands/01_view_text/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/os-learn/docs/commands/01_view_text/</guid><description> 查看文件内容 # cat：显示文件的所有内容。 more：读取文件，但不需要读取整个文件到内存中，支持向下翻页。 less：more 的反义词，支持上下翻页。尽量使用 less 这种不需要读取全部文件的指令，因为在线上执行 cat 是一件非常危险的事情，这可能导致线上服务器资源不足。 head：查看文件开头。 head -5 &amp;lt;file&amp;gt;，显示文件前 5 行的内容。 tail：查看文件结尾： tail -n 5 &amp;lt;file&amp;gt;，显示文件尾部 5 行的内容。 -f 同步显示更新内容。 wc：统计文件内容。 wc -l &amp;lt;file&amp;gt; 统计指定文件中的内容有多少行。</description></item><item><title>打包压缩</title><link>http://shipengqi.github.io/os-learn/docs/commands/02_tar/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/os-learn/docs/commands/02_tar/</guid><description> 打包压缩 # Linux 里面打包和压缩是分开的两个命令：
tar 打包备份，tar -cf /tmp/backup.tar /etc 把 /etc 目录打包到 /tmp/backup.tar 文件 -c 打包 -f 指定打包的文件 -x 从备份文件中还原文件，tar -xf /tmp/backup.tar -C /root 把 /tmp/backup.tar 文件还原到 /root 目录下，需要解压缩就加上 -z 或者 -j 参数。 -C 还原到指定的目录 -z 打包的同时使用 gzip 压缩文件，一般后缀会加上 .gz 来表明备份文件的压缩方式，比如 tar -czf /tmp/backup.tar.gz /etc。tgz 是 .tar.gz 的简写。 -j 打包的同时使用 bzip2 压缩文件，一般后缀会加上 .bz2 或者 bzip2 来表明备份文件的压缩方式，比如 tar -cjf /tmp/backup.tar.bz2 /etc。tbz2 是 .tar.bz2 的简写。 -v|--verbose 显示指令执行过程。 tar -cf - /etc，- 表示将 tar 压缩包发送到标准输出，而不是写入文件。 gzip, bzip2 压缩 gzip 压缩更快，bzip2 压缩比例更高</description></item><item><title>Vim</title><link>http://shipengqi.github.io/os-learn/docs/commands/03_vim/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/os-learn/docs/commands/03_vim/</guid><description>Vim # vim 的四种模式：命令模式，输入模式，底线命令模式，可视模式。
命令模式 # 启动 vim 就会直接进入命令模式。此状态下敲击键盘识别为命令，而非输入字符。比如此时按下 i，会进入输入模式。
i a o I A O 都是进入输入模式，区别在于： i：从光标所在位置前面开始插入 I：在当前行首插入 a：从光标所在位置后面开始输入 A：在当前行尾插入 o：在光标所在行下方新增一行并进入输入模式 O：在当前上面一行插入 yy：复制整行内容，例如 3yy 就是复制光标以下的 3 行内容。 y$：复制当前光标到行尾内容 p：粘贴 dd：剪切或者删除光标所在行，20dd 则是删除光标以下的 20 行。 d$：剪切或者删除光标到行尾内容 u：撤销上一次操作 ctrl + r：如果错误的撤销了，可以使用 ctrl + r 恢复。 x：删除当前光标后的一个字符。 G：移动到最后一行，20G 则会移动到第 20 行（可配合 :set nu）。 gg：移动到第一行 :：切换到底线命令模式，也就是在 vim 编辑器的最下面一行输入命令。 输入模式 # 在命令模式下按下 i 就进入了输入模式。
ESC，退出输入模式，切换到命令模式 底线命令模式 # 在命令模式下按下 : 就进入了底线命令模式。底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。
q：退出 vim。 q!：不保存修改，退出 vim。 w：保存文件 wq 或者 x：保存并退出。 set nu：显示行号 set nonu：取消行号 /：向前搜索 ?</description></item><item><title>用户管理</title><link>http://shipengqi.github.io/os-learn/docs/commands/04_user_manage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/os-learn/docs/commands/04_user_manage/</guid><description>用户管理 # 用户 # Linux 系统的用户存放在 /etc/passwd 文件中。/etc/shadow 是用户密码相关的文件。
useradd：创建用户。useradd pooky 添加了一个用户 pooky。 id pooky 验证 pooky 用户是否存在。root 用户的 uid 是 0。普通用户的 uid 如果改为 0，那就会具有 root 用户的权限。 -g：指定用户组。useradd -g group1 user2 创建用户 user2 并加入到用户组 group1。添加用户时，不指定用户组，就会默认创建和用户名同名的用户组。 userdel：删除用户。userdel pooky 删除用户 pooky。 -r：会删除用户的 home 目录，否则会保留。 passwd：修改密码。 passwd pooky 设置用户 pooky 的密码。直接输入 passwd 会修改当前用户的密码。 usermod：修改用户属性 -d：修改用户 home 目录。usermod -d /hmoe/pookyh pooky 把 pooky 的 home 目录改为 pookyh。 -g：修改用户组。usermod -g group1 pooky 将 pooky 的用户组改为 group1。 chage：修改用户密码的过期信息。 用户组 # Linux 用户组的信息存放在 /etc/group 文件中。</description></item><item><title>文件权限</title><link>http://shipengqi.github.io/os-learn/docs/commands/05_file_perm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/os-learn/docs/commands/05_file_perm/</guid><description>文件权限 # 查看文件权限 # ls -l 可以查看文件的权限信息：
-rwxr-xr-x. 1 root root 12059203 Jun 12 2019 renewCert -rwxr-xr-x 第一个字符表示类型 - 表示普通文件。rwxr-xr-x 表示权限，前面三个字符 rwx 表示当前用户的权限，中间三个字符 r-x 表示所属用户组的权限，后三个字符 r-x 表示其他用户的权限。 1 硬链接的数目。 root root 分别表示文件所属的用户和用户组。 对于普通文件 r, w, x 分别表示：读，写，执行权限。用数字表示就是：r=4，w=2，x=1。 对于目录文件 r, rx, wx 分别表示：进入目录，显示目录内的文件，修改目录内文件的权限。
文件类型 # -：普通文件 d：目录文件 b：块设备文件 c：字符设备文件 l：符号链接（类似 windows 的快捷方式） f：命名管道 s：套接字文件 修改文件权限 # chmod：修改文件，目录的权限。 chmod u+x /test，chmod 755 /test。 chown 修改所属用户，用户组。 chown user1 /test 修改 /test 的所属用户为 user1。 chown :group1 /test 修改 /test 的所属用户组为 group1。 chown user1:group1 /test 修改 /test 的所属用户为 user1，用户组为 group1。 chgrp 只修改所属用户组。 chgrp group1 /test 修改 /test 的所属用户组为 group1。 chmod # u：用户，对应个 rwxr-xr-x 中的前三个字符 g：用户组，对应个 rwxr-xr-x 中中间的三个字符 o：其它用户，对应个 rwxr-xr-x 中后面的三个字符 a：所有用户(默认) +：增加权限 -：删除权限 =：设置权限 chmod u+x file # file 的属主增加执行权限 chmod 751 file # file 的属主分配读、写、执行(7)的权限，给 file 的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限 chmod u=rwx,g=rx,o=x file # 上例的另一种形式 chmod =r file # 为所有用户分配读权限 chmod 444 file # 同上例 chmod a-wx,a+r file # 同上例 chmod -R u+r directory # 递归地给 directory 目录下所有文件和子目录的属主分配读的权限 chmod 4755 # 设置 UID，给属主分配读、写和执行权限，给组和其他用户分配读、执行的权限。 特殊权限 # SUID 仅用二进制于可执行文件，执行者将具有该文件的所有者的权限。 SGID 执行者将具有该文件的所属用户组的权限。 SBIT 仅用于目录，用来阻止非文件的所有者删除文件，仅有自己和 root 才有权力删除。 SUID # ls -ld /usr/bin/passwd：</description></item><item><title>网络管理</title><link>http://shipengqi.github.io/os-learn/docs/commands/06_network/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/os-learn/docs/commands/06_network/</guid><description>网络管理 # net-tools 是 CentOS 7 之前的版本使用的网络管理工具，而 iproute2 是 CentOS 7 之后主推的网络管理工具。
net-tools # net-tools 包括：
ifconfig：网卡配置。 route：网关配置。 netstat：查看网络状态。 iproute2 # ip：包含了 ifconfig 和 route 的功能。 ss：Socket Statistics 的缩写，和 netstat 类似，但是更快更强。 使用网络工具 # ifconfig 查看网卡 # 执行 ifconfig 查看网卡。
一般第一块网卡是 eth0。也可能是：
eno1 板载网卡 ens33 PCI-E 网卡 enp0s3 无法获取物理信息的 PCI-E 网卡 都不匹配就使用 eth0。
配置网卡名称 # 在管理服务器集群时，网卡名称不同，会不好管理。如何配置网卡名称？
首先，网卡命名规则受两个参数影响，分别是 biosdevname 和 net.ifnames。grup 是系统启动时，引导内核的工具。
编辑 /etc/default/grup 文件，在 GRUP_CMDLINE_LINUX 对应的命令后面添加（或修改）参数 biosdevname=0 net.ifnames=0，就可以传递到内核。 /etc/default/grup 需要运行 grup2-mkconfig -o /boot/grup2/grup.</description></item><item><title>包管理器</title><link>http://shipengqi.github.io/os-learn/docs/commands/07_package_manage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/os-learn/docs/commands/07_package_manage/</guid><description>包管理器 # 对于 Windows 系统，最方便的方式就是下载 exe，也就是安装文件。下载后我们直接双击安装即可。 对于 Linux 来讲，也是类似的方法，你可以下载 rpm 或者 deb。这个就是 Linux 下面的安装包。Linux 现在常用的有两大体系，一个是 CentOS 体系，一个是 Ubuntu 体系，前者使用 rpm，后者使用 deb。
CentOS 下面使用 rpm -i jdk-XXX_linux-x64_bin.rpm 进行安装，Ubuntu 下面使用 dpkg -i jdk-XXX_linux-x64_bin.deb。其中 -i 就是 install 的意思。
rpm -qa 和 dpkg -l 可以查看安装的软件列表，-q 就是 query，a 就是 all，-l 的意思就是 list。
rpm，yum：CentOS 和 RedHat 使用 yum 包管理器，安装包的格式为 rpm。 apt：Ubuntu 和 Debian 使用 apt 包管理器，安装包的格式为 deb。 rpm 包格式 # bind-9.8.2-0.47.rc1.el6.x86_64.rpm：
软件名，如 bind 软件版本，9.8.2-0 是软件版本，版本号格式通常为 主版本号.</description></item><item><title>grup</title><link>http://shipengqi.github.io/os-learn/docs/commands/08_grup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/os-learn/docs/commands/08_grup/</guid><description> grup # grup 是内核启动的引导软件。
CentOS 6 grup 所有文件需要手动修改。CentOS 7 提供了命令行工具。
配置文件：
/etc/default/grup 默认的 grup 配置文件。 /etc/grup.d/ /boot/grup2/grup.cfg，这个文件不应该直接修改，应该修改默认的配置文件 grup2-mkconfig -o /boot/grup2/grup.cfg，该命令会生成新的 grup 配置文件 默认配置文件 /etc/default/grup：
GRUB_TIMEOUT=5 GRUB_DISTRIBUTOR=&amp;#34;$(sed &amp;#39;s, release .*$,,g&amp;#39; /etc/system-release)&amp;#34; GRUB_DEFAULT=saved GRUB_DISABLE_SUBMENU=true GRUB_TERMINAL_OUTPUT=&amp;#34;console&amp;#34; GRUB_CMDLINE_LINUX=&amp;#34;crashkernel=auto rd.lvm.lv=rhel/root rd.lvm.lv=rhel/swap rhgb quiet&amp;#34; GRUB_DISABLE_RECOVERY=&amp;#34;true&amp;#34; ~</description></item><item><title>进程管理</title><link>http://shipengqi.github.io/os-learn/docs/commands/09_process/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/os-learn/docs/commands/09_process/</guid><description>进程管理 # 进程的生命周期是可管理的。
查看进程 # ps pstree top 进程也是树形结构。进程和权限密不可分。
ps # 执行 ps 查看当前终端的可以看到的进程，p 代表 processes，也就是进程；s 代表 snapshot，也就是快照：
[root@pooky ~]# ps PID TTY TIME CMD 8974 pts/2 00:00:00 bash 12550 pts/2 00:00:00 ps ps -e 查看所有终端的进程：
[root@pooky ~]# ps -e PID TTY TIME CMD 1 ? 00:50:59 systemd 2 ? 00:00:06 kthreadd 3 ? 00:00:01 ksoftirqd/0 5 ? 00:00:00 kworker/0:0H 7 ? 00:00:00 migration/0 8 ? 00:00:00 rcu_bh 9 ?</description></item><item><title>systemctl</title><link>http://shipengqi.github.io/os-learn/docs/commands/10_systemd/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/os-learn/docs/commands/10_systemd/</guid><description>systemctl # systemctl 是 Linux 的服务管理工具，在 CentOS 6 以前使用的是 service 这个管理工具。
service 的配置文件在 /etc/init.d。
/usr/lib/systemd/ststem
systemctl start|stop|restart|status|reload|enable|disable &amp;lt;service name&amp;gt;</description></item><item><title>SELinux</title><link>http://shipengqi.github.io/os-learn/docs/commands/11_selinux/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/os-learn/docs/commands/11_selinux/</guid><description>SELinux # 安全增强型 Linux（Security-Enhanced Linux）简称 SELinux，它是一个 Linux 内核模块，也是 Linux 的一个安全子系统。
没有使用 SELinux 的 Linux 是通过用户的权限和文件权限来做安全控制，这叫做 DAC（自主访问控制）。最致命问题是，root 用户不受任何管制，系统上任何资源都可以无限制地访问。
使用了 SELinux 的 Linux 中，会给用户，文件，进程都打上一个标签。一个资源是否能被访问，要用户，文件和进程的标签一致，并且类型一致，才被允许访问。这叫做 MAC（强制访问控制）。
SELinux 保证了安全，但是会降低机器性能，因为处理文件的时候要额外处理 SELinux 的权限，一般生产环境下 SELinux 是关闭的。
查看 SELinux # getenforce 查看 SELinux 的模式 /usr/sbin/sestatus [root@pooky ~]# getenforce Permissive [root@pooky ~]# /usr/sbin/sestatus SELinux status: enabled SELinuxfs mount: /sys/fs/selinux SELinux root directory: /etc/selinux Loaded policy name: targeted Current mode: permissive Mode from config file: permissive Policy MLS status: enabled Policy deny_unknown status: allowed Max kernel policy version: 31 SELinux 会有三种模式：</description></item><item><title>内存和磁盘</title><link>http://shipengqi.github.io/os-learn/docs/commands/12_mem_disk/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/os-learn/docs/commands/12_mem_disk/</guid><description>内存和磁盘 # 查看内存和磁盘的使用率 # 查看内存的使用率 # free top [root@pooky ~]# free total used free shared buff/cache available Mem: 16266780 1091532 7315128 157456 7860120 14383564 Swap: 0 0 0 [root@pooky ~]# free -m total used free shared buff/cache available Mem: 15885 1065 7144 153 7675 14046 Swap: 0 0 0 [root@pooky ~]# free -g total used free shared buff/cache available Mem: 15 1 6 0 7 13 Swap: 0 0 0 -m 和 -g 分别是指以 MB 和 GB 为单位显示。buff/cache 是进程使用的缓存。available 是释放掉 cache 后的可用内存。</description></item><item><title>查看系统状态</title><link>http://shipengqi.github.io/os-learn/docs/commands/13_sar/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/os-learn/docs/commands/13_sar/</guid><description>查看系统状态 # sar # [root@pooky ~]# sar -u 1 10 Linux 3.10.0-862.el7.x86_64 (pooky.hpeswlab.net) 09/01/2020 _x86_64_ (8 CPU) 09:06:43 PM CPU %user %nice %system %iowait %steal %idle 09:06:44 PM all 0.13 0.00 0.13 0.00 0.00 99.75 09:06:45 PM all 0.38 0.00 0.13 0.00 0.00 99.50 09:06:46 PM all 0.25 0.00 0.37 0.00 0.00 99.38 09:06:47 PM all 0.13 0.00 0.00 0.00 0.00 99.87 09:06:48 PM all 0.12 0.00 0.25 0.00 0.</description></item><item><title>Shell</title><link>http://shipengqi.github.io/os-learn/docs/commands/14_shell/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/os-learn/docs/commands/14_shell/</guid><description>Shell # shell 是 Linux 的命令解释器，解释用户对操作系统的操作。CentOS 默认使用的 shell 是 bash。例如，执行 ls 命令时，会先被 shell 对命令和参数进行解释，再交给内核执行。
/bin/bash 的位置是用于配置登录后的默认交互命令行的，不像 Windows，登录进去是界面，其实就是 explorer.exe。而 Linux 登录后的交互命令行是一个解析脚本的程序，默认是 /bin/bash。
执行命令的方式：
bash ./test.sh 创建一个子进程来运行 test.sh ./test.sh 创建一个子进程来运行 test.sh，需要 Sha-Bang ，也就是脚本文件开头的 #!/bin/bash 来判断使用哪种 shell。 source ./test.sh 在当前进程运行 test.sh。也就是说 test.sh 里面执行的命令会影响当前 bash 进程。比如 test.sh 里面只有一行命令为 cd /var ，当前进程会切换到 /var。如果是 bash ./test.sh 当前 bash 就不会切换目录，只是在子进程切换了目录。 . test.sh . 是 source 的另一种写法。 如果希望脚本对当前运行环境产生影响，就使用 source 来执行。
Linux 启动过程 # BIOS （基本输入输出系统）引导，在主板上执行，选择引导介质 MBR 硬盘引导 BootLoader(grub) 启动和引导 Linux 内核，确定内核版本 kernel systemd 系统初始化 shell 管道 # 管道是进程间通信的一种方式。| 管道符，可以将前一个命令的结果传递给后面的命令。</description></item><item><title>脚本控制</title><link>http://shipengqi.github.io/os-learn/docs/commands/15_script_priority/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/os-learn/docs/commands/15_script_priority/</guid><description>脚本控制 # 脚本控制一般分为两种：
脚本的优先级控制 通过信号控制 脚本优先级控制 # nice 和 renice 可以调整脚本的优先级，调整资源的占用，如 CPU。 避免不可控的死循环 死循环会导致 CPU 占用过高 死循环会导致死机，创建大量的子进程，叫做 fock 炸弹。如 .(){.|.&amp;amp;};.，可以当做 func(){func|func &amp;amp;}; func。 ulimit -a 可以查看当前的终端的系统限制：
[root@pooky ~]# ulimit -a core file size (blocks, -c) 0 data seg size (kbytes, -d) unlimited scheduling priority (-e) 0 file size (blocks, -f) unlimited pending signals (-i) 63408 max locked memory (kbytes, -l) 64 max memory size (kbytes, -m) unlimited open files (-n) 1024 pipe size (512 bytes, -p) 8 POSIX message queues (bytes, -q) 819200 real-time priority (-r) 0 stack size (kbytes, -s) 8192 cpu time (seconds, -t) unlimited max user processes (-u) 63408 # 用户的最大进程数 virtual memory (kbytes, -v) unlimited file locks (-x) unlimited 当 fock 炸弹创建大量的进程，超过 max user processes 的限制时，系统就会停止响应，因为 CPU 在不停的创建子进程。</description></item><item><title>操作文本</title><link>http://shipengqi.github.io/os-learn/docs/commands/16_text_operation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/os-learn/docs/commands/16_text_operation/</guid><description>操作文本 # 文本搜索一般会使用正则表达式。
元字符 # 常用的元字符：
. 匹配除了换行符外的任意一个字符 * 匹配任意个跟它前面的字符 [] 匹配方括号中的字符类中的任意一个，比如 [Hh]ello 就可以匹配 hello 和 Hello。 ^ 匹配开头 $ 匹配结尾 \ 转义字符 扩展元字符：
+ 匹配前面的正则表达式至少出现一次 ? 匹配前面的正则表达式出现一次或者零次 | 匹配前面或者后面的正则表达式 grep # grep 用来查找文件里符合条件的字符串。 grep 会把符合条件的行显示出来。
[root@pooky init.d]# grep password /root/anaconda-ks.cfg # Root password [root@pooky init.d]# grep -i password /root/anaconda-ks.cfg -i 忽略大小写 # Root password [root@pooky ~]# grep pass.... /root/anaconda-ks.cfg # 可以使用元字符 . 匹配任意一个字符 auth --enableshadow --passalgo=sha512 # Root password [root@pooky ~]# grep pass.</description></item><item><title>防火墙</title><link>http://shipengqi.github.io/os-learn/docs/commands/17_firewall/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/os-learn/docs/commands/17_firewall/</guid><description>防火墙 # 防火墙分为两类：
软件防火墙，CentOS 6 的默认防火墙是 iptables，CentOS 7 的默认防火墙是 firewalld，底层都是使用内核中的 netfilter。 包过滤防火墙，主要用于数据包的过滤，数据包转发。 应用层防火墙，可以控制应用程序的具体的行为。 硬件防火墙 iptables # iptables的结构：
iptables -&amp;gt; Tables -&amp;gt; Chains -&amp;gt; Rules tables 由 chains 组成，而 chains 又由 rules 组成。
表（tables）提供特定的功能，iptables 包含四个规则表：
filter 包过滤 nat 网络地址转换 mangle 包重构(修改) raw 数据跟踪处理 链（chains）是数据包传播的路径，每一条链其实就是众多规则中的一个检查清单，每一条链中可以有一条或数条规则。
当一个数据包到达一个链时，iptables 就会从链中第一条规则开始检查，看该数据包是否满足规则所定义的条件。如果满足，系统就会根据该条规则所定义的方法处理该数据包； 否则 iptables 将继续检查下一条规则，如果该数据包不符合链中任一条规则，iptables 就会根据该链预先定义的默认策略来处理数据包。
iptables 的规则链：
INPUT 接收的的数据包使用此规则链中的策略 OUTPUT 发送的数据包使用此规则链中的策略 FORWARD 转发数据包时使用此规则链中的策略 PREROUTING 目的地址转换 POSTROUTING 源地址转换 iptables [-t 表] 命令选项 [规则链] 规则，-t 默认使用的是 filter。</description></item><item><title>SSH</title><link>http://shipengqi.github.io/os-learn/docs/commands/18_ssh/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/os-learn/docs/commands/18_ssh/</guid><description>SSH # SSH（Secure Shell）是一种网络协议，用于加密两台计算机之间的通信，并且支持各种身份验证机制。主要用于服务器登录和各种加密通信。
历史上，网络主机之间的通信是不加密的，属于明文通信。这使得通信很不安全。SSH 就是为了解决这个问题而诞生的。
SSH 的软件架构是服务器-客户端模式（Server - Client）。
SSH 客户端 # 基本用法：
# 不指定用户名，使用客户端的当前用户名，作为远程服务器的登录用户名 $ ssh hostname # 指定用户名 $ ssh user@hostname # -l 参数，用户名和主机名可以分开 $ ssh -l username host # -p 指定端口，默认连接服务器的 22 端口 $ ssh -p 8821 foo.com # 连接服务器，并立刻执行 command，非交互模式 ssh username@hostname command 客户端连接流程 # ssh 连接远程服务器，如果是第一次连接某一台服务器，会出现下面的提示：
The authenticity of host &amp;#39;16.187.189.94 (16.187.189.94)&amp;#39; can&amp;#39;t be established. ECDSA key fingerprint is SHA256:Vybt22mVXuNuB5unE++yowF7lgA/9/2bLSiO3qmYWBY. Are you sure you want to continue connecting (yes/no)?</description></item><item><title>FTP</title><link>http://shipengqi.github.io/os-learn/docs/commands/19_ftp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/os-learn/docs/commands/19_ftp/</guid><description>FTP # ftp 协议的全称是文件传输协议。
FTP 采用两个 TCP 连接来传输一个文件：
控制连接：服务器以被动的方式，打开众所周知用于 FTP 的端口 21，客户端则主动发起连接。该连接将命令从客户端传给服务器，并传回服务器的应答。常用的命令有： list 获取文件目录 reter 取一个文件 store 存一个文件 数据连接：每当一个文件在客户端与服务器之间传输时，就创建一个数据连接。 FTP 的两种模式 # 两种模式都是站在 FTP 服务器的角度来说的。
主动模式（PORT） # 客户端随机打开一个大于 1024 的端口 N，向服务器的命令端口 21 发起连接，同时开放 N+1 端口监听，并向服务器发出 port N+1 命令，由服务器从自己的数据端口 20，主动连接到客户端指定的数据端口 N+1。
被动模式（PASV） # 当开启一个 FTP 连接时，客户端打开两个任意的本地端口 N（大于 1024）和 N+1。第一个端口连接服务器的 21 端口，提交 PASV 命令。然后，服务器会开启一个任意的端口 P（大于 1024），返回 227 entering passive mode 消息，里面有 FTP 服务器开放的用来进行数据传输的端口。客 户端收到消息取得端口号之后，会通过 N+1 号端口连接服务器的端口 P，然后在两个端口之间进行数据传输。
vsftpd # vsftpd 实现了 ftp 协议。</description></item><item><title>NFS</title><link>http://shipengqi.github.io/os-learn/docs/commands/20_nfs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/os-learn/docs/commands/20_nfs/</guid><description> NFS # NFS 在 Linux 中会默认安装。
NFS 的主配置文件：/etc/exports。
[root@SGDLITVM0905 ~]# cat /etc/exports /data/share *(rw,sync,all_squash) /data/share2 10.222.77.0/24(rw,sync,insecure,no_subtree_check,no_root_squash) /var/vols/itom/core *(rw,sync,anonuid=1999,anongid=1999,root_squash) ... /data/share2 是要共享目录，而且必须要存在。 10.222.77.0/24 表示允许 IP 在该 10.222.77.0/24 网段的客户端挂载。设置为 * 即允许所有客户端挂载，如 /home *(ro,sync,insecure,no_root_squash)，设置 /home 目录允许所有客户端只读挂载。 一个目录可以配置多个 IP 权限，/data/share 10.0.0.1(rw) 10.0.0.2(ro)，表示 10.0.0.1 访问时是读写权限，10.0.0.2 访问时是只读权限，注意 IP 和括号之间不要有空格，否则会当做两个配置。 目录设置：
ro 只读访问 rw 读写访问 sync 确保数据写入时从内存同步到磁盘 async 将数据先保存在内存缓冲区中，必要时才写入磁盘 secure nfs 通过 1024 以下的安全 TCP/IP 端口发送 insecure nfs 通过 1024 以上的端口发送 root_squash 将 root 用户及所属组都映射为匿名用户或用户组（默认设置） no_root_squash 与 rootsquash 取反 anonuid=xxx 将远程访问的所有用户都映射为匿名用户，并指定该用户为本地用户（UID=xxx） anongid=xxx 将远程访问的所有用户组都映射为匿名用户组账户，并指定该匿名用户组账户为本地用户组账户（GID=xxx） wdelay 检查是否有相关的写操作，如果有则将这些写操作一起执行，这样可以提高效率（默认设置） no_wdelay 若有写操作则立即执行，应与 sync 配合使用 hide 在 nfs 共享目录中不共享其子目录 no_hide 共享 nfs 目录的子目录 subtree_check 如果共享 /usr/bin 之类的子目录时，强制 nfs 检查父目录的权限（默认） no_subtree_check 不检查父目录权限 all_squash 将远程访问的所有普通用户及所属组都映射为匿名用户或用户组（nfsnobody） no_all_squash 与 all_squash 取反（默认设置） [root@SGDLITVM0905 ~]# showmount -e localhost # 查看指定主机有哪些共享目录 Export list for localhost: /data/share * /var/vols/demochart/demochart-db-volume * /var/vols/demochart/demochart-data-volume * /var/vols/demochart/demochart-conf-volume * [root@SGDLITVM0905 ~]# ls /data/share testnfs [root@SGDLITVM0905 ~]# mount -t nfs localhost:/data/share /mnt # 挂载指定主机 localhost 下的共享目录 /data/share 到 /mnt [root@SGDLITVM0905 ~]# ls /mnt testnfs [root@SGDLITVM0905 ~]# cd /mnt [root@SGDLITVM0905 ~]# touch testnfs2</description></item><item><title>DNS</title><link>http://shipengqi.github.io/os-learn/docs/commands/21_dns/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/os-learn/docs/commands/21_dns/</guid><description>DNS # DNS（Domain Name System 的缩写）域名系统。 FQDN（Full Qualified Domain Name）完全限定域名。FQDN 由两部分组成:主机名和域名。例如 www.baidu.com，主机名是 www，主机位于域名 baidu.com 中。
BIND # DNS 主要靠 BIND 这个软件来实现。
安装 yum install bind bind-utils 启动 systemctl start named.service 配置文件 # 主配置文件 /etc/named.conf。</description></item><item><title>内核升级</title><link>http://shipengqi.github.io/os-learn/docs/commands/22_kernel_upgrade/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/os-learn/docs/commands/22_kernel_upgrade/</guid><description> 内核升级 # rpm 格式内核 # 查看内核版本：
[root@pooky ~]# uname -r 3.10.0-862.el7.x86_64 [root@pooky ~]# 安装指定的内核版本：yum install kernel-3.10.0
升级内核：yum update，升级内核和其他软件包
源码编译安装内核 # 安装依赖：
yum install gcc gcc-c++ make ncurses-devel openssl-devel elfutils-libelf-devel 下载并解压缩内核：
https://www.kernel.org tar xvf linux-5.1.10.tar.xz -C /usr/src/kernels 配置内核参数编译参数，进入内核源码目录：
cd /usr/src/kernels/linux-5.1.10 make menuconfig|allyesconfig|allnoconfig，不同于 ./configure ，因为内核有很多参数需要配置。 menuconfig，会显示一个配置菜单，可以自己选择配置 allyesconfig，选择所有配置 allnoconfig，所有配置都不选择 使用当前系统内核配置：
cp /boot/config-&amp;lt;kernelversion&amp;gt;.&amp;lt;platform&amp;gt; /usr/src/kernels/linux-5.1.10/.config，例如 cp /boot/config-config-3.10.0-862.el7.x86_64 /usr/src/kernels/linux-5.1.10/.config 编译安装 # lscpu，查看 cpu，可以查看内核的数量 make -j2 all ，编译，j2 表示使用两个内核编译。all 表示使用所有编译选项编译 make modules_install 安装内核模块，make install 安装内核 rebot 之后新的内核就会引导界面。选择新的内核。</description></item><item><title>pty</title><link>http://shipengqi.github.io/os-learn/docs/commands/23_pty_tty/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://shipengqi.github.io/os-learn/docs/commands/23_pty_tty/</guid><description>pty # pty（pseudo terminal）伪终端。tty 可以直接理解为终端。
tty # tty 全称为 Teletypes（电传打字机），是通过串行线用打印机键盘通过阅读和发送信息的东西，后来这东西被键盘和显示器取代，所以现在叫终端比较合适。
随着 linux 的发展，终端固定再内核层过于僵化，某些进程需要自主实现一个终端模拟器，比如 ssh，xterm。而 tty 完全由内核接管。用户态无法使用 tty 的功 能，于是 linux 提出将终端仿真移动至用户态，这就是 pty 的由来。
当创建一个伪终端时，会在 /dev/pts 目录下创建一个设备文件：/dev/pts/8。
pty # pty 由 master 和 slave 两端构成，在任何一端的输入都会传达到另一端。与 tty 不同，系统中并不存在 pty 这种文件，它是由 pts（pseudo-terminal slave） 和 ptmx（pseudo-teiminal master）两种设备文件来实现的。
pts # pts（pseudo-terminal slave）即伪终端的 slave 端。在 Linux 的 /dev/pts/ 文件夹下有对应设设备文件。可以通过 tty 命令查看当前用户的登录终端：
[root@shcCDFrh75vm7 ~]# tty /dev/pts/0 当我们设备文件 /dev/pts/0 进行输出时，屏幕上会显示相应输出：
[root@shcCDFrh75vm7 ~]# echo hello &amp;gt;/dev/pts/0 hello [root@shcCDFrh75vm7 ~]# 如果访问别的 slave 文件，比如 /dev/pts/9，则会返回权限不足错误（root 除外）。</description></item></channel></rss>