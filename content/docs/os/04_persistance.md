# 持久性

## IO 设备

输入输出设备大致可以分为两类：块设备（block device）和字符设备（character device）。

- 块设备将信息存储在固定大小的块中，每个块都有自己的地址，如硬盘。
- 自读设备发送和接收字节流。不用考虑任何块结构，不能寻址，如鼠标。

### 标准设备

CPU 并不直接和设备交互，它们中间有一个叫做**设备控制器**的组件，如硬盘有磁盘控制器，USB 有 USB 控制器，显示器有视频控制器。
这些控制器就行代理商一样，它们知道如何应对硬盘，鼠标等设备的行为。

一个标准设备包含两个部分：

1. 一部分是向系统其它部分展现的硬件接口硬件也是需要接口的，这些接口让系统软件来控制它的操作。因此所有设备都有自己的特定接口以及典型的交互协议。
2. 第二部分是内部结构。这部分包含设备相关的特定实现，负责具体实现设备展示给体统的抽象接口。简单的十倍一般用一个或几个芯片来实现他们的功能。复杂的设备会包含简单的 CPU，通用内存，特定芯片等。如 RAID 控制器会包含上千固件（firmware，硬件设备中的软件）。

一个简化的设备包含三个寄存器：

1. 状态寄存器，用于查看当前设备的状态
2. 命令寄存器，用于通知设备执行某个具体任务
3. 数据寄存器，将数据传给设备，或者从设备接收数据

### 利用中断减少 CPU 开销

利用中断减少 CPU 开销。有了中断，CPU 不需要再轮询设备，而是向设备发出一个请求，然后就可以让对应的进程睡眠，切换执行其他任务。当设备完成可操作，会抛出一个**硬件中断**，引发 CPU 跳转执行操作系统预先定义好的**中断处理程序**。中断处理程序时一小段操作系统代码，它会结束之前的请求（比如从设备读取到了数据或者错误码）并且幻想等待 IO 的进程并继续执行。

这提高了 CPU 的利用率。

但是使用中断并不总是最佳的方案。加入一个非常高性能的设备，它处理请求非常快：一般在 CPU 第一次轮询时就可以返回结果。此时如果使用中断，反而会使系统变慢：切换到其他进程，处理中断，再切换回之前的进程，这代价是不小的。

采用**混合策略**，先尝试轮询一小段时间，如果设备没有完成操作，再使用中断。

**最好不使用中断的场景是网络**。网络端接收大量数据包，如果每一次都发生中断，可能导致系统发生活锁（livelock），也就是不断的处理中断而无法处理用户层的请求。

另一个基于中断的优化是**合并**。设备在抛出中断之前等待一小段时间，在等待的期间，可能有其他请求很快完成，可以将多次中断合并成一次中断抛出，降低处理中断的代价。但是等待的时间太长会增加请求的延迟。

一般的流程是，一个设备驱动程序初始化的时候，要先注册一个该设备的中断处理函数。中断返回的那一刻是进程切换的时机。中断的时候，触发的函数是 `do_IRQ`。这个函数是中断处理的统一入口。在这个函数里，可以找到设备驱动程序注册的中断处理函数 `Handler`，然后执行它处理中断。

![](interrupt-flow.jpg)

### 利用 DMA

如果使用编程的 IO 将一大块数据传给设备，CPU 会因为琐碎的任务变得负载很重，浪费资源，更好是用于运行其他进程。

![](cpu-dma.jpg)

进程 1 在运行过程中需要向磁盘写一些数据，所以开始进行 IO 操作，将数据从内存拷贝到磁盘（标记 c 的过程）。拷贝技术后，磁盘的 IO 操作开始执行，此时 CPU 才会处理其他请求。

CPU 的时间会浪费在向设备传输数据或从设备传出数据的过程中。如何才能分离这项工作，从而提高 CPU 的利用率？

解决方案就是使用 DMA（Direct Memory Access）。DMA 可以协调完成内存和设备间的数据传递，不需要 CPU 介入。

为了将数据传递给设备，操作系统会告诉 DMA 数据在内存的位置，要拷贝的大小及拷贝到那个设备。之后操作系统就可以处理其他请求了。当 DMA 完成任务后，DMA 控制器会抛出一个终端来告诉操作系统自己已经完成了数据传输。

DMA 有点儿像一些比较大的代理商，不但能够帮你代购代销，而且自己有能力售前、售后和技术支持，实施部署都能自己搞定。

![](dma-flow.jpg)

### 设备交互

有两种方式实现设备的交互：

1. 使用指令。例如在 x86 上，in 和 out 指令可以用来与设备进行交互。当需要发送数据给设备时，调用者指定一个存入数据的特定寄存器及一个代表设备的特定端口。执行这个指令就可以实现期望的行为。操作系统是唯一可以直接与设备交互的实体。
2. 内存映射 IO（memory- mapped IO）。通过这种方式，硬件将设备寄存器作为内存地址提供。当需要访问设备寄存器时，操作系统装载（读取）或者存入（写入）到该内存地址；然后硬件会将装载/存入转移到设备上，而不是物理内存。

### 设备驱动程序

虽然设备控制器像代理商一样可以帮我们屏蔽很多设备细节，但是每种设备的控制器的寄存器，换乘区等使用模式，指令都不相同，对于操作系统来说，需要有个组件来转对处理与设备控制器的对接，屏蔽不同设备控制器的差异。

如何实现一个设备无关的操作系统？比如文件系统，开发一个文件系统可以工作在 SCSI 硬盘，IDE 硬盘等设备之上，并且希望这个文件系统不那么清楚对这些不同设备发出的读写请求的全部细节。

利用抽象技术。在最底层，操作系统有部分软件知道设备如何工作，这部分软件就是**设备驱动程序**，所有设备交互的细节都封装在其中。

设备控制器不属于操作系统的一部分，但是设备驱动程序属于操作系统的一部分。因为所有需要插入系统的设备都需要安装对应的驱动程序，所以久而久之，驱动程序的代码在整个内核代码中的占比越来越大。查看 Linux 内核代码会发现，超过 70% 的代码都是各种驱动程序。

设备驱动程序是面向设备控制器的，不同的设备，驱动程序也不同。但是对于操作系统而言，设备驱动程序应该有统一的接口。

### 用文件系统接口屏蔽驱动程序的差异