# 虚拟化

什么是虚拟化？

假设有一个桃子，这是真实的桃子，称为物理桃子。很多人想吃这个桃子，如果要给每个人一个属于他们自己的桃子，把给每个人的桃子称为虚拟桃子。通过某种方式从物理桃子创造出的许多虚拟桃子，在这种假象中，每个人看起来都有一个物理桃子，实际上不是。每个人都不知道在和别人分享同一个物理桃子。

以 CPU 为例，虚拟化做的就是将计算机的 CPU 虚拟成多个 CPU 并分给每个进程使用，因为每个进程都以为自己在独占 CPU，实际上只有一个 CPU。

## 进程

程序本身没有生命周期，它只是存储在磁盘上的一些指令或数据。**进程就是运行中的程序**。物理机上只有少量的 CPU，操作系统如何实现有无数个 CPU 的假象？

虚拟化 CPU，通过让一个进程只运行一个时间片，然后切换到其他进程。这就是**时分共享** CPU 技术。CPU 由于被共享，那么每个进程的运行就会慢一点。

### 进程 API

`fork()` 和 `exec()` 这两个系统调用可以创建新的进程。

#### fork

系统调用 fork 创建新进程，但是这个接口非常奇怪。

```c
printf("hello world (pid:%d)\n", (int) getpid());
int rc = fork();
if (rc < 0) {
    fprintf(stderr, "fork failed\n");
    exit(1);
} else if (rc == 0) {
    printf("hello, I am child (pid:%d)\n", (int) getpid());
} else {
    printf("hello. I am parent of %d (pid:%d)\n", rc, (int) getpid());
}
```

输出：

```bash
hello world (pid:29146)
hello. I am parent of 29147 (pid:29146)
hello, I am child (pid:29147)
```

第一行输出的是当前进程 PID。然后使用 fork 创建了新的进程（子进程），新的进程几乎与调用进程（父进程）完全一样，在操作系统看来有两个完全一样的程序在运行，并都从 fork 系统调用中返回。子进程不会从 main 函数开始执行（hello world 只输出了一次），而是从 fork 返回，好像是它自己调用了 fork。

子进程并不是完全拷贝了父进程，子进程拥有独立的地址空间，寄存器等，但是它从 fork 返回的值是不同的。**子进程得到的返回值是 0，父进程得到的返回值是子进程的 PID**。

如果在单个 CPU 的系统上运行，父子这两个进程的运行顺序是不确定的。

#### wait

wait 会等待子进程运行

#### exec

exec 系统调用也是创建进程，不过它可以运行与父进程不同的程序。exec 指定可执行程序和参数，exec 会从可执行程序中加载代码和静态数据，并用它复写自己的代码段，堆、栈及其他内存空间都会被重新初始化。然后操作系统执行该程序，传入参数。因此它并没有创建新的进程，而是直接将当前运行的程序换位不同的运行程序。

#### fork 和 exec

fork 和 exec 这中设计，使 shell 在 fork 之后和 exec 之前可以执行代码的机会，可以在运行新程序前改变环境。

#### shell 如何运行一条命令

1. shell 也是一个程序，它首先显示一个提示符，等待用户输入。
2. 当用户输入某条命令时，shell 会在文件系统中找到这个可执行程序，调用 fork 创建新进程
3. 调用 exec 的某个变体来执行这个可执行程序
4. 调用 wait 等待命令执行完成
5. 子进程结束后，shell 从 wait 返回并输出一个提示符，等待用户的下一个输入。

fork 和 exec  分离的设计可以实现很多功能：`wc p1.c > output.txt`。

上面的例子中，shell 创建子进程，在调用 exec 之前，关闭了标准输出，打开 `output.txt` 文件，使 wc 的输出被发送到了文件，而不是标准输出。

虚拟化 CPU 是通过时分共享实现的，但是这种机制要面对两个问题：

1. 性能，如何实现不增加系统开销的情况下实现虚拟化？
2. 如何有效的运行进程，同时保留系统对 CPU 的控制权？因为操作系统负责资源管理，如果没有控制权，一个进程就可以无限制的运行，或者访问没有权限的信息。
