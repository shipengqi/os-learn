# 虚拟化

什么是虚拟化？

假设有一个桃子，这是真实的桃子，称为物理桃子。很多人想吃这个桃子，如果要给每个人一个属于他们自己的桃子，把给每个人的桃子称为虚拟桃子。通过某种方式从物理桃子创造出的许多虚拟桃子，在这种假象中，每个人看起来都有一个物理桃子，实际上不是。每个人都不知道在和别人分享同一个物理桃子。

以 CPU 为例，虚拟化做的就是将计算机的 CPU 虚拟成多个 CPU 并分给每个进程使用，因为每个进程都以为自己在独占 CPU，实际上只有一个 CPU。

## 进程

程序本身没有生命周期，它只是存储在磁盘上的一些指令或数据。**进程就是运行中的程序**。物理机上只有少量的 CPU，操作系统如何实现有无数个 CPU 的假象？

虚拟化 CPU，通过让一个进程只运行一个时间片，然后切换到其他进程。这就是**时分共享** CPU 技术。CPU 由于被共享，那么每个进程的运行就会慢一点。

### 进程 API

`fork()` 和 `exec()` 这两个系统调用可以创建新的进程。

#### fork

系统调用 fork 创建新进程，但是这个接口非常奇怪。

```c
printf("hello world (pid:%d)\n", (int) getpid());
int rc = fork();
if (rc < 0) {
    fprintf(stderr, "fork failed\n");
    exit(1);
} else if (rc == 0) {
    printf("hello, I am child (pid:%d)\n", (int) getpid());
} else {
    printf("hello. I am parent of %d (pid:%d)\n", rc, (int) getpid());
}
```

输出：

```bash
hello world (pid:29146)
hello. I am parent of 29147 (pid:29146)
hello, I am child (pid:29147)
```

第一行输出的是当前进程 PID。然后使用 fork 创建了新的进程（子进程），新的进程几乎与调用进程（父进程）完全一样，在操作系统看来有两个完全一样的程序在运行，并都从 fork 系统调用中返回。子进程不会从 main 函数开始执行（hello world 只输出了一次），而是从 fork 返回，好像是它自己调用了 fork。

子进程并不是完全拷贝了父进程，子进程拥有独立的地址空间，寄存器等，但是它从 fork 返回的值是不同的。**子进程得到的返回值是 0，父进程得到的返回值是子进程的 PID**。

如果在单个 CPU 的系统上运行，父子这两个进程的运行顺序是不确定的。

#### wait

wait 会等待子进程运行

#### exec

exec 系统调用也是创建进程，不过它可以运行与父进程不同的程序。exec 指定可执行程序和参数，exec 会从可执行程序中加载代码和静态数据，并用它复写自己的代码段，堆、栈及其他内存空间都会被重新初始化。然后操作系统执行该程序，传入参数。因此它并没有创建新的进程，而是直接将当前运行的程序换位不同的运行程序。

#### fork 和 exec

fork 和 exec 这中设计，使 shell 在 fork 之后和 exec 之前可以执行代码的机会，可以在运行新程序前改变环境。

#### shell 如何运行一条命令

1. shell 也是一个程序，它首先显示一个提示符，等待用户输入。
2. 当用户输入某条命令时，shell 会在文件系统中找到这个可执行程序，调用 fork 创建新进程
3. 调用 exec 的某个变体来执行这个可执行程序
4. 调用 wait 等待命令执行完成
5. 子进程结束后，shell 从 wait 返回并输出一个提示符，等待用户的下一个输入。

fork 和 exec  分离的设计可以实现很多功能：`wc p1.c > output.txt`。

上面的例子中，shell 创建子进程，在调用 exec 之前，关闭了标准输出，打开 `output.txt` 文件，使 wc 的输出被发送到了文件，而不是标准输出。

虚拟化 CPU 是通过时分共享实现的，但是这种机制要面对两个问题：

1. 性能，如何实现不增加系统开销的情况下实现虚拟化？
2. 如何有效的运行进程，同时保留系统对 CPU 的控制权？因为操作系统负责资源管理，如果没有控制权，一个进程就可以无限制的运行，或者访问没有权限的信息。

#### 受限制的操作

用户模式下，进程不能完全访问硬件资源。操作系统运行在内核模式下，此模式下可以访问机器的全部资源。用户程序可以通过内核提供的系统调用，来执行特权操作，如访问文件系统，创建销毁进程，进程间通信等。

要执行系统调用，进程必须执行特殊的**陷阱**（`trap`）指令。该指令跳入内核并将特权级别提升到内核模式。完成后，操作系统调用**陷阱返回**（`return-from-trap`）指令，返回到发起调用的用户程序中，同时将特权降级到用户模式。

#### 进程间切换

一个 CPU 如果正在运行一个进程，那么意味这操作系统没有运行，操作系统如何获得 CPU 的控制权？

协作方式，等待系统调用，陷入内核，操作系统可以获取 CPU 控制权。

非协作方式，如果某个进程不进行系统调用，就需要**时钟中断**。时钟设备可以每隔几毫秒产生一次中断，操作系统的中断处理程序就会运行，此时操作系统重新获得 CPU 的控制权。然后操作系统可以停止一个进程，启动另一个进程。这属于硬件功能。

##### 保存和恢复上下文

操作系统获得了控制权以后，无论是通过系统调用协作还是时钟中断，都必须由调度程序决定切换到哪个进程。

切换进程，OS 就会执行一些底层代码，即**上下文切换**。

上下文切换：操作系统为当前执行的进程保存一些寄存器的值到它的内核栈，并且为即将执行的进程把保存在内核栈中的寄存器值恢复到寄存器。

### 进程调度

`周转时间 = 完成时间 - 到达时间`

任务的周转时间等于任务完成时间减去任务到达系统的时间。

#### 先进先出

FIFO

#### 最短任务优先

SJF 是非抢占式的

#### 最短完成时间优先

最短完成时间优先（STCF）就是在 SJF 的基础上添加了抢占

#### 响应时间

如果任务只使用 CPU，那么唯一得衡量是周转时间，STCF 是一个很好的策略。

响应时间定义为从任务到达系统到首次运行的时间。

`响应时间 = 首次运行 - 到达时间`

#### 轮转

轮转（Round-Robin，RR）调度算法的思想很简单：RR 在一个时间片（time slice，也叫做调度量子）内运行一个工作，然后切换到下一个运行队列中的任务，而不是运行一个任务直到结束。反复执行知道所有的任务完成。RR 有时被称为**时间切片**。时间片的长度必须是时钟中断周期的倍数，比如时钟中断间隔是 10ms，那么时间片长度可以是 10ms，20ms 等。

时间片长度越短，RR 在响应时间上越快。时间片太短也有问题，上下文切换的成本会影响整体性能。

上下文切换的成本不止是保存和回复寄存器的操作。程序运行是，在高速缓存，TLB 等建立了大量的状态，切换到另一个工作会导致这些状态丢失。

#### 结合 IO

### 多级反馈队列

对于 SJF 和 STCF 通过先执行最短完成时间的工作，但是操作系统通常不知道工作要运行多久，但这又是算法必需的。

轮转虽然降低了响应时间，但是周转时间却很差。

多级反馈队列（Multi-level Feedback Queue，MLFQ），要解决两个文图，优化周转时间和响应时间。

**MLFQ 中有许多独立的队列，每个队列有不同的优先级。一个工作只能存在于一个队列中。MLFQ 总是有限执行优先级高的队列中的工作。同一个队列中的工作有同样的优先级，这种情况下，采用轮转调度**。

MLFQ 的关键就在于如何设置**优先级**。MLFQ 会根据工作运行中的行为来调整优先级。如，一个工作不断放弃 CPU 去等待键盘的输入，那么就可能是交互型进程，会被保持高优先级。如果一个工作长时间占用 CPU，那么就会被降低优先级。MLFQ 就是在进程运行中学习其行为，预测未来的行为。

优先级调整规则：

- 规则 1：如果 A 的优先级 > B 的优先级，运行 A（不运行 B）。
- 规则 2：如果 A 的优先级 = B 的优先级，轮转运行 A 和 B。
- 规则 3：工作进入系统时，放在最高优先级（最上层队列）。
- 规则 4：工作用完整个时间片后，降低其优先级（移入下一个队列）。如果工作在其时间片以内主动释放 CPU，则优先级不变。一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次CPU），就降低其优先级（移入低一级队列）。
- 规则 5：经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。解决了两个问题，首先，如果太多的交互型进程，就会不断占用 CPU，会导致长工作永远无法得到 CPU。所以这个规则，加入到最高级优先级队列，不会让长工作饿死。其次，

### 比例份额

比例份额调度程序，也叫做公平份额调度程序。目标就是确保每一个工作获得一定比例的 CPU 时间，而不是优化周转时间和响应时间。并没有被广泛应用。

### 多处理器调度

## 内存

操作系统提供了一个物理内存抽象，**地址空间**。运行中的程序看到的系统内存就是地址空间。

### 内存操作 API

程序的内存一般分两种：

- 栈内存，一般由编译器自动分配和释放，存储函数的入参，局部变量，这些参数会随着函数的创建而创建，函数的返回而消亡，一般不会在程序中长期存在。
- 堆内存，在 C 中，由程序员显示的申请和释放，在 Go 中由内存分配器分配并由垃圾收集器负责回收。这是长期内存。

忘记分配内存，没有分配足够的内存，忘记初始化分配的内存，忘记释放内存，在用完之前释放内存（悬挂指针），反复释放内存

#### malloc

#### free

### 地址转换

基于硬件的**地址转换**
