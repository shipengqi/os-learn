---
title: Linux 内存
weight: 2
---

# Linux 内存

## 虚拟内存

Linux 给每个进程提供了一个**独立的虚拟地址空间**，并且是**连续的**。虚拟地址空间分为两部分**内核空间**和**用户空间**。

进程在**用户态**时，只能访问用户空间内存。只有进入内核态时，才能访问内核空间内存。每个进程的内核空间，其实关联的都是相同的物理内存。

每个进程的地址空间是很大的，所有进程的虚拟内存加起来会比物理内存大的多。所以并不是所有的虚拟内存都会分配物理内存。只有实际使用的虚拟内存才会分配物理内存，通过**内存映射**管理。

将虚拟内存地址映射到物理内存地址，内核为每个进程维护了一张**页表**，记录虚拟地址和物理地址的映射关系：

![](memory-map.png)

页表实际存储在 CPU 的内存管理单元 MMU 中。处理器可以直接通过硬件，找出要访问的内存。

而当进程访问的虚拟地址在页表中查不到时，系统会产生一个**缺页异常**，进入内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。

Linux 通过 TLB（Translation Lookaside Buffer）来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，TLB 也需要刷新，内存的访问也会随之变慢。特别是在多处理器系统上，缓存是被多个处理器共享的，刷新缓存不仅会影响当前处理器的进程，还会影响共享缓存的其他处理器的进程。

TLB 其实就是 MMU 中页表的高速缓存。由于进程的虚拟地址空间是独立的，而 TLB 的访问速度又比 MMU 快得多，所以，通过减少进程的上下文切换，减少 TLB 的刷新次数，就可以提高 TLB 缓存的使用率，进而提高 CPU 的内存访问性能。

**页**是内存映射的最小单位，一般是 4 KB。每一次内存映射，都需要关联 4 KB 或者 4 KB 整数倍的内存空间。

页的大小是 4 KB，那么一个 32 位的系统就需要 100 多万个页表项（4 GB/4 KB），一个页表项 4 字节，那么一个页表大概需要 4 MB 才可以实现地址空间的映射。每个进程都需要一个页表，100 个进程就需要 400 MB 的内存。Linux 通过**多级页表**和**大页（HugePage）**来解决这个问题。

大页，顾名思义，就是比普通页更大的内存块，常见的大小有 2MB 和 1GB。大页通常用在使用大量内存的进程上，比如 Oracle、DPDK 等。

### 多级页表

以一个二级页表为例：

![](multi-page-struct.png)

一个 12 MB 的进程，虚拟地址 32 位，PT1 有 10 位，也就是顶级页表只能有 `2^10 = 1024` 个页表项。PT2 也是 10 位，那么二级页表也有 1024 个页表项。二级页表的每个页表项对应一个页帧（4 KB），那么一个二级页表能表示的地址空间是 4 MB（1024*4 KB）。二级页表的页帧号加上 Offset，就是物理地址。

MMU 先通过 PT1 找到顶级页表中的一个页表项，这个页表项对应了一个二级页表。找到二级页表后，在通过 PT2 找到二级页表中的页表项，也就是虚拟地址所在页面的页帧号，用该页帧号加上 Offset，就构成了物理地址。

Linux 使用四级页表来管理内存页，虚拟地址分为 5 部分，前 4 部分用来选择页，最后一部分表示偏移量：

![](four-level-page.png)

## Buffer 和 Cache

```bash
[root@pooky ~]# free -m
              total        used        free      shared  buff/cache   available
Mem:          15885        1065        7144         153        7675       14046
Swap:             0           0           0
```

包含了物理内存 Mem 和交换分区 Swap 的具体使用情况，比如总内存、已用内存、缓存、可用内存等。

- `buff/cache` 是进程使用的缓存。缓存是 Buffer 和 Cache 两部分的总和。
- `available` 是释放掉 cache 后的可用内存。

Buffer 是缓冲区，而 Cache 是缓存，两者都是数据在内存中的临时存储。

`free` 的数据来自 `/proc/meminfo`。

**Buffer 是对磁盘数据的缓存，而 Cache 是文件数据的缓存，它们既会用在读请求中，也会用在写请求中**。

磁盘是一个块设备，可以划分为不同的分区；在分区之上再创建文件系统，挂载到某个目录，之后才可以在这个目录中读写文件。 其实 Linux 中“一切皆文件”，而文章中提到的“文件”是普通文件，磁盘是块设备文件，这些大家可以执行 `ls -l <路径>`。 在读写普通文件时，会经过文件系统，由文件系统负责与磁盘交互；而读写磁盘或者分区时，就会跳过文件系统，也就是所谓的 `裸 I/O` 。这两种读写方式所使用的缓存是不同的，也就是 Cache 和 Buffer 区别。

## 内存泄漏

对于一个进程，看到的内存是虚拟内存，由系统通过页表映射为物理内存。

当一个进程 malloc 申请内存后，系统并不会马上分配物理内存，而是在首次访问时，才通过缺页异常陷入内核中分配内存。

进程的内存空间内，分为多个不同的段，只读段，数据段，堆，栈以及文件映射。

- 栈内存由系统管理，系统自动分配和回收，不会出现内存泄漏。
- 堆内存由应用程序自己管理，除非程序退出，否则不会被系统自动回收，而是需要调用 free 等函数来释放。如果没有正确释放内存，就会出现内存泄漏。
- 只读段，包括程序的代码和常量，由于是只读的，不会再去分配新的内存，所以也不会产生内存泄漏。
- 数据段，包括全局变量和静态变量，这些变量在定义时就已经确定了大小，所以也不会产生内存泄漏。
- 内存映射段，包括动态链接库和共享内存，其中共享内存由程序动态分配和管理。所以，如果程序在分配后忘了回收，就会导致跟堆内存类似的泄漏问题。

**内存泄漏的危害非常大，这些忘记释放的内存，不仅应用程序自己不能访问，系统也不能把它们再次分配给其他应用**。内存泄漏不断累积，甚至会耗尽系统内存。

虽然系统可以通过 OOM（Out of Memeory）杀死进程，但是在 OOM 之前，可能已经引发了严重的性能问题。

### 内存泄漏分析

内存泄漏问题，应该关注内存使用的变化趋势。

```bash
# 每隔 3 秒输出一组数据
$ vmstat 3
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
0  0      0 6601824  97620 1098784    0    0     0     0   62  322  0  0 100  0  0
0  0      0 6601700  97620 1098788    0    0     0     0   57  251  0  0 100  0  0
0  0      0 6601320  97620 1098788    0    0     0     3   52  306  0  0 100  0  0
0  0      0 6601452  97628 1098788    0    0     0    27   63  326  0  0 100  0  0
2  0      0 6601328  97628 1098788    0    0     0    44   52  299  0  0 100  0  0
0  0      0 6601080  97628 1098792    0    0     0     0   56  285  0  0 100  0  0
```

上面的输出中，内存的 free 列在不停的变化，并且是下降趋势；而 buffer 和 cache 基本保持不变。内存一直在身高升高，并不能说明是有内存泄漏，因为程序运行中需要内存是可能会增大的。

如何确定是否有内存泄漏？

- memleak，一个专门用来检测内存泄漏的工具，可以跟踪系统或指定进程的内存分配、释放请求，然后定期输出一个未释放内存和相应调用栈的汇总情况（默认 5 秒）。

## Swap

当发生了内存泄漏，或者运行了大内存的应用，导致内存资源紧张时，会导致两种结果：内存回收和 OOM 杀死进程。

内存回收就是系统释放掉可以回收的内存，比如 Buffer 和 Cache。它们在内存管理中，被叫做**文件页**。

大部分文件页都可以直接回收，有需要时再从磁盘重新读取就可以了。但是那些被应用程序修改过的，还没有写入磁盘的数据（脏页），需要先写入磁盘，再释放内存。

脏页刷入磁盘的方式：

1. 应用程序通过系统调用 fsync，把脏页同步到磁盘。
2. 有内核线程 pdflush 负责刷新。

程序动态分配的堆内存，叫做**匿名页**。这些内存在分配后可能很少被访问。Swap 机制就是把这些不常访问的内存先写入磁盘，然后释放这些内存，给其他需要的进程使用。再次访问时，从磁盘读入内存。

### Swap 原理

Swap 有两个过程：

- 换出，就是把进程暂时不用的内存数据存储到磁盘，并释放这些内存。
- 换入，在进程再次访问这些内存的时候，把它们从磁盘中读到内存中。

常见的电脑的休眠和快速开机也是基于 Swap。在休眠时，把系统内存存入磁盘，再次开机时，从磁盘中加载到内存，可以节省程序初始化的过程。

什么时候需要回收内存？

一个场景就是，有新的大块内存分配请求，但是剩余内存不足。这个时候系统就需要回收一部分内存（比如 Buffer 和 Cache），进而尽可能地满足新内存请求。这个过程通常被称为**直接内存回收**。

除了直接内存回收，还有一个专门的内核线程用来定期回收内存，也就是 `kswapd0`。为了衡量内存的使用情况，`kswapd0` 定义了三个内存阈值（watermark，也称为水位），分别是

页最小阈值（pages_min）、页低阈值（pages_low）和页高阈值（pages_high）。剩余内存，则使用 pages_free 表示。

![](watermark.png)

### swappiness

这些回收的内存既包括了文件页，又包括了匿名页。

- 对文件页的回收，当然就是直接回收缓存，或者把脏页写回磁盘后再回收。
- 而对匿名页的回收，其实就是通过 Swap 机制，把它们写入磁盘后再释放内存。

实际回收内存时，到底该先回收哪一种？

其实，Linux 提供了一个 `/proc/sys/vm/swappiness` 选项，用来调整使用 Swap 的积极程度。

swappiness 的范围是 0-100，数值越大，越积极使用 Swap，也就是更倾向于回收匿名页；数值越小，越消极使用 Swap，也就是更倾向于回收文件页。

### Swap 升高分析

内存资源紧张时，Linux 通过**直接内存回收**和**定期扫描**的方式，来释放文件页和匿名页，以便把内存分配给更需要的进程使用。

- 文件页的回收比较容易理解，直接清空缓存，或者把脏数据写回磁盘后，再释放缓存就可以了。
- 而对不常访问的匿名页，则需要通过 Swap 换出到磁盘中，这样在下次访问的时候，再次从磁盘换入到内存中就可以了。

开启 Swap 后，你可以设置 `/proc/sys/vm/min_free_kbytes`，来调整系统定期回收内存的阈值，也可以设置 `/proc/sys/vm/swappiness`，来调整文件页和匿名页的回收倾向。

通常，降低 Swap 的使用，可以提高系统的整体性能。几种常见的降低方法：

- 禁止 Swap，现在服务器的内存足够大，所以除非有必要，禁用 Swap 就可以了。随着云计算的普及，大部分云平台中的虚拟机都默认禁止 Swap。
- 如果实在需要用到 Swap，可以尝试降低 swappiness 的值，减少内存回收时 Swap 的使用倾向。
- 响应延迟敏感的应用，如果它们可能在开启 Swap 的服务器中运行，你还可以用库函数 `mlock` 或者 `mlockall` 锁定内存，阻止它们的内存换出。

## 内存性能分析

### 内存性能指标

### 内存分析工具
