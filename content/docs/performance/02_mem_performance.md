# Linux 内存

## 虚拟内存

Linux 给每个进程提供了一个**独立的虚拟地址空间**，并且是**连续的**。虚拟地址空间分为两部分**内核空间**和**用户空间**。

进程在**用户态**时，只能访问用户空间内存。只有进入内核态时，才能访问内核空间内存。每个进程的内核空间，其实关联的都是相同的物理内存。

每个进程的地址空间是很大的，所有进程的虚拟内存加起来会比物理内存大的多。所以并不是所有的虚拟内存都会分配物理内存。只有实际使用的虚拟内存才会分配物理内存，通过**内存映射**管理。

将虚拟内存地址映射到物理内存地址，内核为每个进程维护了一张**页表**，记录虚拟地址和物理地址的映射关系：

![](memory-map.png)

页表实际存储在 CPU 的内存管理单元 MMU 中。处理器可以直接通过硬件，找出要访问的内存。

而当进程访问的虚拟地址在页表中查不到时，系统会产生一个**缺页异常**，进入内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。

Linux 通过 TLB（Translation Lookaside Buffer）来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，TLB 也需要刷新，内存的访问也会随之变慢。特别是在多处理器系统上，缓存是被多个处理器共享的，刷新缓存不仅会影响当前处理器的进程，还会影响共享缓存的其他处理器的进程。

TLB 其实就是 MMU 中页表的高速缓存。由于进程的虚拟地址空间是独立的，而 TLB 的访问速度又比 MMU 快得多，所以，通过减少进程的上下文切换，减少 TLB 的刷新次数，就可以提高 TLB 缓存的使用率，进而提高 CPU 的内存访问性能。

**页**是内存映射的最小单位，一般是 4 KB。每一次内存映射，都需要关联 4 KB 或者 4 KB 整数倍的内存空间。

页的大小是 4 KB，那么一个 32 位的系统就需要 100 多万个页表项（4 GB/4 KB），一个页表项 4 字节，那么一个页表大概需要 4 MB 才可以实现地址空间的映射。每个进程都需要一个页表，100 个进程就需要 400 MB 的内存。Linux 通过**多级页表**和**大页（HugePage）**来解决这个问题。

大页，顾名思义，就是比普通页更大的内存块，常见的大小有 2MB 和 1GB。大页通常用在使用大量内存的进程上，比如 Oracle、DPDK 等。

### 多级页表

以一个二级页表为例：

![](multi-page-struct.png)

一个 12 MB 的进程，虚拟地址 32 位，PT1 有 10 位，也就是顶级页表只能有 `2^10 = 1024` 个页表项。PT2 也是 10 位，那么二级页表也有 1024 个页表项。二级页表的每个页表项对应一个页帧（4 KB），那么一个二级页表能表示的地址空间是 4 MB（1024*4 KB）。二级页表的页帧号加上 Offset，就是物理地址。

MMU 先通过 PT1 找到顶级页表中的一个页表项，这个页表项对应了一个二级页表。找到二级页表后，在通过 PT2 找到二级页表中的页表项，也就是虚拟地址所在页面的页帧号，用该页帧号加上 Offset，就构成了物理地址。

Linux 使用四级页表来管理内存页，虚拟地址分为 5 部分，前 4 部分用来选择页，最后一部分表示偏移量：

![](four-level-page.png)

## Buffer 和 Cache

```bash
[root@pooky ~]# free -m
              total        used        free      shared  buff/cache   available
Mem:          15885        1065        7144         153        7675       14046
Swap:             0           0           0
```

包含了物理内存 Mem 和交换分区 Swap 的具体使用情况，比如总内存、已用内存、缓存、可用内存等。

- `buff/cache` 是进程使用的缓存。缓存是 Buffer 和 Cache 两部分的总和。
- `available` 是释放掉 cache 后的可用内存。

Buffer 是缓冲区，而 Cache 是缓存，两者都是数据在内存中的临时存储。

free 的数据来自 `/proc/meminfo`。

**Buffer 是对磁盘数据的缓存，而 Cache 是文件数据的缓存，它们既会用在读请求中，也会用在写请求中**。

磁盘是一个块设备，可以划分为不同的分区；在分区之上再创建文件系统，挂载到某个目录，之后才可以在这个目录中读写文件。 其实 Linux 中“一切皆文件”，而文章中提到的“文件”是普通文件，磁盘是块设备文件，这些大家可以执行 `ls -l <路径>`。 在读写普通文件时，会经过文件系统，由文件系统负责与磁盘交互；而读写磁盘或者分区时，就会跳过文件系统，也就是所谓的 `裸 I/O` 。这两种读写方式所使用的缓存是不同的，也就是 Cache 和 Buffer 区别。

## 内存泄漏

对于一个进程，看到的内存是虚拟内存，由系统通过页表映射为物理内存。

当一个进程 malloc 申请内存后，系统并不会马上分配物理内存，而是在首次访问时，才通过缺页异常陷入内核中分配内存。

进程的内存空间内，分为多个不同的段，只读段，数据段，堆，栈以及文件映射。

- 栈内存由系统管理，系统自动分配和回收，不会出现内存泄漏。
- 堆内存由应用程序自己管理，除非程序退出，否则不会被系统自动回收，而是需要调用 free 等函数来释放。如果没有正确释放内存，就会出现内存泄漏。
- 只读段，包括程序的代码和常量，由于是只读的，不会再去分配新的内存，所以也不会产生内存泄漏。
- 数据段，包括全局变量和静态变量，这些变量在定义时就已经确定了大小，所以也不会产生内存泄漏。
- 内存映射段，包括动态链接库和共享内存，其中共享内存由程序动态分配和管理。所以，如果程序在分配后忘了回收，就会导致跟堆内存类似的泄漏问题。

**内存泄漏的危害非常大，这些忘记释放的内存，不仅应用程序自己不能访问，系统也不能把它们再次分配给其他应用**。内存泄漏不断累积，甚至会耗尽系统内存。

虽然系统可以通过 OOM（Out of Memeory）杀死进程，但是在 OOM 之前，可能已经引发了严重的性能问题。

### 内存泄漏分析

