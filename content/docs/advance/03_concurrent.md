# 并发

线程类似于独立的进程，只有一点区别：它们共享地址空间，可以访问相同的数据。

单个线程的状态和进程状态非常类似，线程有程序计数器（PC），记录从哪里获取指令。有一组寄存器。从一个线程切换到另一个线程，必定发生上下文切换，类似进程间的上下文切换。进程将状态保存到**进程控制块**（Process Control Block，PCB）。**线程控制块**（Thread Control Block，TCB），保存每个线程的状态。
一点主要区别：**地址空间保持不变（即不需要切换当前使用的页表）**。

线程和进程的另一个主要区别：栈。传统的进程地址空间只有一个栈，一般位于地址空间的底部。

![](process-thread.jpg)

在多线程的进程中，每个线程独立运行，都有一个栈。所有位于栈上的变量、参数、返回值和其他放在栈上的东西，将被放置在有时称为**线程本地（thread-local）存储**的地方，即相关线程的栈。

**线程的运行顺序是不确定的**。

## 线程 API

- `pthread_create()` 创建线程
- `pthread_join()` 等待线程完成
- `pthread_mutex_lock()` 加锁
- `pthread_mutex_unlock()` 释放锁
- `pthread_cond_wait()` 使调用线程进入休眠状态。条件变量，当线程之间必须发生某种信号时，如果一个线程在等待另一个线程继续执行某些操作，条件变量就很有用
- `pthread_cond_signal()` 唤醒线程

## 锁

锁的实现目标：

1. 提供互斥
2. 公平性，当锁可用时，没一个竞争线程是否有公平的机会抢到锁？是否有线程会饿死，一直无法抢到？
3. 性能，使用锁会增加时间开销。

### 控制中断

这是最早的互斥解决方案之一，就是在临界区关闭中断。这是为单处理器系统开发的。

```c
void lock() {
  DisabkeInterrputs();
}

void unlock() {
  EnableInterrputs();
}
```

通过在临界区之前关闭中断（使用特殊的硬件指令），保证临界区的代码不会被中断，从而原子的执行。结束之后重新打开中断。

缺点：

1. 恶意程序调用 lock 之后，一直死循环，系统无法重新获得控制权，只能重启。
2. 不止多处理器，如果多个线程运行在不同的 CPU，当每个线程都试图进入临界区时，关闭中断也没有用。
3. 关闭中断导致中断丢失，可能导致系统问题。比如磁盘设备完成了读取请求，蛋 CPU 错失了这一事实，操作系统如何唤醒等待读取的进程？

### 原子交换

硬件支持锁，测试并设置指令，也叫原子交换。

用一个变量来标志锁是否被某些线程占用。第一个线程进入临界区，调用 `lock()`，检查标志是否为 1（这里不是 1），然后设置标志为 1，表明线程持有该锁。结束临界区时，线程调用 `unlock()`，清除标志，表示锁未被持有。

```c
typedef struct lock_t { int flag; } lock_t;

void init(lock_t *mutex) {
  // 0 -> lock is available, 1 -> held
  mutex->flag = 0;
}

void lock(lock_t *mutex) {
  while (mutex->flag == 1) // TEST the flag
  ; // spin-wait (do nothing)
  mutex->flag = 1; // now SET it!
}

void unlock(lock_t *mutex) {
  mutex->flag = 0;
}
```

问题：

1. 正确性。通过适时的（不合时宜的？）中断，我们很容易构造出两个线程都将标志设置为 1，都能进入临界区的场景。显然没有满足最基本的要求：互斥。
2. 性能。线程在等待已经被持有的锁时，采用自旋等待的技术，就是不停的检查标志的值。自旋等待其他线程释放锁的时候会浪费时间。

### 可用的自旋锁

上面的想法没有硬件的支持是无法实现的。一些系统提供了指令，支持创建简单的锁。在 x86 上指令是 `xchg` （atomic exchange，原子交换）。

### 使用队列：休眠代替自旋

### 两阶段锁

Linux 采用的锁方案，称为两阶段锁。两阶段锁在第一个阶段会先自旋一段时间，尝试获取锁。如果第一阶段没有获取到锁，第二阶段调用者会睡眠，直到锁可用。
更常见的方式是在循环中自旋固定的次数，然后使用 futex 睡眠。

### 小结

当前的锁实现：一些硬件的支持（指令）和操作系统的支持（Linux 的 futex）。

## 信号量

信号量是有一个整数值的对象，可以用两个函数来操作。`sem_wait()` `sem_post()`。因为信号量初始值能够决定其行为，所以要先初始化信号量，才能调用其他函数与之交互。

`sem_wait()` 当信号量的值大于等于 1 时，会立刻返回。当小于 1 时，会使调用线程挂起，直到之后得一个 post 操作。也可能多个调用线程都调用了 `sem_wait()`，因此都在队列中等待被唤醒。

`sem_post()` 直接增加信号量，如果有等待线程，唤醒其中一个。当信号量为负数时，这个值就是等待线程的个数。

## 基于事件的并发

并发不止可以使用线程来实现，基于事件的并发是另一种方式（node.js）。

### 事件循环

不用线程如何实现并发？

等待某个事件发生，放它发生时，检查事件类型，然后做响应的工作（可能是 IO 请求）。

基于事件的并发都是基于一个简单的数据结构，事件循环。

主循环等待耨写事件发生，然后依次处理这些发生的时间。

如何决定那个时间发生，尤其对于网络和磁盘 IO？

### select 和 poll

事件循环如何接受时间？大多数系统提供了基本的 API，select 或 poll 系统调用。

这些接口对程序的支持很简单：检查是否有任何应该关注的进入 IO。如，假 web 服务器希望检查是否有网络数据包到达。

假定一个请求从客户端进入服务器，要从磁盘读取文件并将其内容返回给发出请求的客户端（很像简单的 HTTP 请求）。为了处理这样的请求，某些事件处理程序最终将不得不发出 `open()` 系统调用来打开文件，然后通过一系列 `read()` 调用来读取文件。当文件被读入内存时，服务器可能会开始将结果发送到客户端。

`open()` 和 `read()` 调用都可能向存储系统发出 IO 请求，因此可能需要很长时间才能提供服务。

但是，使用基于事件的方法时，没有其他线程可以运行：只是主事件循环。这意味着如果一个事件处理程序发出一个阻塞的调用，整个服务器就会这样做：阻塞直到调用完成。当事件循环阻塞时，系统处于闲置状态，因此是潜在的巨大资源浪费。

### 异步 IO

为了解决上面的问题，操作系统引入了新的方法来向磁盘系统发出 IO 请求，也就是异步 IO。这些接口使应用程序能够发出 IO 请求，并在 IO 完成前立即将控制权返回给调用者，另外的接口让应用程序能够确定各种 IO 是否已经完成。

如，macOS 提供的 AIO 控制块。

```c
struct aiocb {
    int            aio_fildes; /* File descriptor */
    off_t          aio_offset; /* File offset */
    volatile void  *aio_buf;   /* Location of buffer */
    size_t         aio_nbytes; /* Length of transfer */
};
```

要向文件发出异步读取，程序首先填充此结构：要读取文件的饿文件描述符（`aio_fildes`），文件内的偏移量（`aio_offset`）以及长度（`aio_nbytes`），最后是应该复制读取结构的目标内存位置（`aio_buf`）。

发出异步调用来读取文件：`int aio_read(struct *aiocbp);`。如果成功会立即返回，程序继续工作。

如任何知道 IO 何时完成，并且缓冲区有了请求的数据？

通过 API `int aio_error(const struct aiocb *aiocbp);`。这个系统调用可以检查 aiocbp 引用的请求是否已经完成。对弈未完成的异步 IO，可以轮询调用 `aio_error` 来确定是否完成。一些系统提供了基于中断（interrupt）的方法。此方法使用 UNIX 信号（signal）在异步 IO 完成时通知应用程序，从而消除了重复询问系统的需要。

在没有异步 IO 的系统中，纯基于事件的方法无法实现。可以使用线程池来管理未完成的 IO。

通常需要组合用于网络的 `select()` 和用于磁盘 IO 的 AIO 调用。
