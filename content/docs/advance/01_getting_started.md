---
title: na
weight: 1
draft: true
---

Linux 学习的六个阶段：

熟练使用 Linux 命令
使用 Linux 进行程序设计
了解 Linux 内核机制
阅读 Linux 内核代码
实验定制 Linux 组件
生产实践



## 进程管理

Linux 创建进程的系统调用叫 `fork`，这个名字很奇怪，中文叫“分支”。为啥启动一个新进程叫“分支”呢？

在 Linux 里，要创建一个新的进程，需要一个老的进程调用 fork 来实现，其中老的进程叫作**父进程**，新的进程叫作**子进程**。

当父进程调用 fork 创建进程的时候，子进程将各个子系统为父进程创建的数据结构也全部拷贝了一份，甚至**连程序代码也是拷贝过来的**。按理说，如果不进行特殊的处理，父进
程和子进程都按相同的程序代码进行下去，这样就没有意义了。

所以，我们往往会这样处理：对于 fork 系统调用的返回值，如果当前进程是子进程，就返回 0；如果当前进程是父进程，就返回子进程的进程号。这样首先在返回值这里就有了一个区分，
然后通过 `if-else` 语句判断，如果是父进程，还接着做原来应该做的事情；如果是子进程，需要请求另一个系统调用 `execve` 来执行另一个程序，这个时候，子进程和父进程就彻底分
道扬镳了，也即产生了一个分支（fork）了。

**操作系统启动的时候先创建一个所有用户进程的“祖宗进程”**。

有时候，父进程要关心子进程的运行情况，可以使用系统调用 `waitpid`，父进程可以调用它，将子进程的进程号作为参数传给它，这样父进程就知道子进程运行完了没有，成功与否。

## 内存管理

操作系统中，每个进程都有自己的内存，互相之间不干扰，有独立的进程内存空间。

对于进程的内存空间来讲，放程序代码的这部分，称为**代码段**（Code Segment）。

存放进程运行中产生数据的这部分，我们称为**数据段**（Data Segment）。其中局部变量的部分，在当前函数执行的时候起作用，当进入另一个函数时，这个变量
就释放了；也有动态分配的，会较长时间保存，指明才销毁的，这部分称为**堆**（Heap）。

一个进程的内存空间是很大的，32 位的是 4G，64 位的就更大了，我们不可能有这么多物理内存。就像一个公司的会议室是有限的，作为老板，你不可能事先都给项目组
分配好。哪有这么多会议室啊，一定是需要的时候再分配。

所以，进程自己不用的部分就不用管，只有进程要去使用部分内存的时候，才会使用内存管理的系统调用来登记，说自己马上就要用了，希望分配一部分内存给它，但是
这还不代表真的就对应到了物理内存。只有真的写入数据的时候，发现没有对应物理内存，才会触发一个中断，现分配物理内存。

当分配的内存数量比较小的时候，使用 `brk`，会和原来的堆的数据连在一起，这就像多分配两三个工位，在原来的区域旁边搬两把椅子就行了。当分配的内存数量比较大的时候，使用 `mmap`，
会重新划分一块区域，也就是说，当办公空间需要太多的时候，索性来个一整块。

## 文件管理

程序、文档、照片等，哪怕关机再开机也能不丢的，就需要放在文件系统里面。

文件之所以能做到这一点，一方面是因为**介质**，另一方面是因为**格式**。

对于文件的操作，下面这六个系统调用是最重要的：

1. 对于已经有的文件，可以使用 open 打开这个文件，close 关闭这个文件；
2. 对于没有的文件，可以使用 create 创建文件；
3. 打开文件以后，可以使用 lseek 跳到文件的某个位置；
4. 可以对文件的内容进行读写，读的系统调用是 read，写是 write。

Linux 里有一个特点，那就是**一切皆文件**。

- 启动一个进程，需要一个程序文件，这是一个**二进制文件**。
- 启动的时候，要加载一些配置文件，例如 yml、properties 等，这是**文本文件**；启动之后会打印一些日志，如果写到硬盘上，也是文本文件。
- 但是如果我想把日志打印到交互控制台上，在命令行上唰唰地打印出来，这其实也是一个文件，是**标准输出 stdout 文件**。
- 这个进程的输出可以作为另一个进程的输入，这种方式称为**管道**，管道也是一个文件。
- 进程可以通过网络和其他进程进行通信，建立的 **Socket**，也是一个文件。
- 进程需要访问外部设备，**设备**也是一个文件。
- 文件都被存储在文件夹里面，其实**文件夹**也是一个文件。
- 进程运行起来，要想看到进程运行的情况，会在 `/proc` 下面有对应的**进程号**，还是一系列文件。

每个文件，Linux 都会分配一个**文件描述符**（File Descriptor），这是一个**整数**。有了这个文件描述符，就可以使用系统调用，查看或者干预进程运行的方方面面。

## 信号处理

经常遇到的信号有以下几种：

- 在执行一个程序的时候，在键盘输入“CTRL+C”，这就是中断的信号，正在执行的命令就会中止退出；
- 如果非法访问内存，例如你跑到别人的会议室，可能会看到不该看的东西；
- 硬件故障，设备出了问题，当然要通知项目组；
- 用户进程通过 kill 函数，将一个用户信号发送给另一个进程。

对于一些不严重的信号，可以忽略，该干啥干啥，但是像 SIGKILL（用于终止一个进程的信号）和 SIGSTOP（用于中止一个进程的信号）是不能忽略的，可以执行对于该信号的默认
动作。每种信号都定义了默认的动作，例如硬件故障，默认终止；也可以提供信号处理函数，可以通过 sigaction 系统调用，注册一个信号处理函数。

提供了信号处理服务，项目执行过程中一旦有变动，就可以及时处理了。

## 进程间通信

首先就是发个消息，不需要一段很长的数据，这种方式称为消息队列（Message Queue）。由于一个公司内的多个项目组沟通时，这个消息队列是在内核里的，我们可以通过msgget创建一个新的队列，msgsnd将消息发送到消息队列，而消息接收方可以使用msgrcv从队列中取消息。

当两个项目组需要交互的信息比较大的时候，可以使用共享内存的方式，也即两个项目组共享一个会议室（这样数据就不需要拷贝来拷贝去）。大家都到这个会议室来，就可以完成沟通了。这时候，我们可以通过shmget创建一个共享内存块，通过shmat将共享内存映射到自己的内存空间，然后就可以读写了。

但是，两个项目组共同访问一个会议室里的数据，就会存在“竞争”的问题。如果大家同时修改同一块数据咋办？这就需要有一种方式，让不同的人能够排他地访问，这就是信号量的机制Semaphore。

这个机制比较复杂，我这里说一种简单的场景。

对于只允许一个人访问的需求，我们可以将信号量设为 1。当一个人要访问的时候，先调用sem_wait。如果这时候没有人访问，则占用这个信号量，他就可以开始访问了。如果这个时候另一个人要访问，也会调用 sem_wait。由于前一个人已经在访问了，所以后面这个人就必须等待上一个人访问完之后才能访问。当上一个人访问完毕后，会调用sem_post将信号量释放，于是下一个人等待结束，可以访问这个资源了。


## 网络通信

一台 Linux 要和另一台 Linux 交流，这时候，我们就需要用到网络服务。

不同机器的通过网络相互通信，要遵循相同的网络协议，也即 **TCP/IP 网络协议栈**。Linux 内核里有对于网络协议栈的实现。

网络服务是通过套接字 Socket 来提供服务的。Socket 这个名字很有意思，可以作“插口”或者“插槽”讲。虽然我们是写软件程序，但是你可以想象成弄一根
网线，一头插在客户端，一头插在服务端，然后进行通信。因此，在通信之前，双方都要建立一个 Socket。

## 系统调用

Glibc 是 Linux 下使用的开源的标准 C 库，它是 GNU 发布的 libc 库。Glibc 为程序员提供丰富的 API，除了例如字符串处理、数学运算等用户态服务之外，最
重要的是封装了操作系统提供的系统服务，即系统调用的封装。

每个特定的系统调用对应了至少一个 Glibc 封装的库函数，比如说，系统提供的打开文件系统调用 sys_open 对应的是 Glibc 中的 open 函数。

有时候，Glibc 一个单独的 API 可能调用多个系统调用，比如说，Glibc 提供的 printf 函数就会调用如 sys_open、sys_mmap、sys_write、sys_close 等等系统调用。

多个 API 也可能只对应同一个系统调用，如 Glibc 下实现的 malloc、calloc、free 等函数用来分配和释放内存，都利用了内核的 sys_brk 的系统调用。





# 操作系统的一些概念

操作系统主要利用了一种通用的技术，叫做**虚拟化**。将物理资源，如 CPU，内存，磁盘等转换为更通用且更易于使用的虚拟形式。操作系统提供了一系列**系统调用**（system call），可以实现运行程序，分配内存或者访问文件等。

CPU，内存，磁盘都是系统资源，操作系统的主要角色就是管理资源。还需要对其虚拟化。处理并发和持久化的问题。

## 虚拟化 CPU

## 虚拟化内存

## 并发

## 持久性

硬件一输入输出 `I/O` 设备的形式出现。硬盘是操作系统中用于持久保存数据的存储设备。

**文件系统**是管理磁盘的软件。文件系统也是操作系统的一部分。

操作系统不会为每个进程创建虚拟磁盘，通常用户需要共享文件中的信息。

## 历史

操作系统早期的时候，只是一些常用的函数库。

之后，由于意识到操作系统的代码的特殊性，它控制了设备。因此诞生了系统调用的概念。

操作系统真正兴起在小型机时代，操作系统一次运行多个程序，大量作业被加载到内存中，并在他们之间快速切换，提供 CPU 的利用率。这种切换非常重要，因为 IO 设备很慢，在处理 IO 时让程序占着 CPU，会浪费 CPU 时间。由于支持多个程序和重叠运行，内存保护就变得重要。我们不希望一个程序访问另一个程序的内存。

之后出现了开源的 UNIX 系统。UNIX 汇聚了许多了不起的思想，创造了简单强大的系统。

个人计算机时代，Windows 系统出现。
