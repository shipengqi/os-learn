[{"id":0,"href":"/os-learn/docs/commands/01_view_text/","title":"查看文件内容","section":"Linux 常用命令","content":" 查看文件内容 # cat：显示文件的所有内容。 more：读取文件，但不需要读取整个文件到内存中，支持向下翻页。 less：more 的反义词，支持上下翻页。尽量使用 less 这种不需要读取全部文件的指令，因为在线上执行 cat 是一件非常危险的事情，这可能导致线上服务器资源不足。 head：查看文件开头。 head -5 \u0026lt;file\u0026gt;：显示文件前 5 行的内容。 tail：查看文件结尾： tail -n 5 \u0026lt;file\u0026gt;：显示文件尾部 5 行的内容。 -f：同步显示更新内容。 wc：统计文件内容。 wc -l \u0026lt;file\u0026gt;：统计指定文件中的内容有多少行。 "},{"id":1,"href":"/os-learn/docs/commands/02_tar/","title":"打包压缩","section":"Linux 常用命令","content":" 打包压缩 # Linux 里面打包和压缩是分开的两个命令：\ntar：打包备份，tar -cf /tmp/backup.tar /etc 把 /etc 目录打包到 /tmp/backup.tar 文件。 -c：打包 -f：指定打包的文件。 -x：从备份文件中还原文件，tar -xf /tmp/backup.tar -C /root 把 /tmp/backup.tar 文件还原到 /root 目录下，需要解压缩就加上 -z 或者 -j 参数。 -C：还原到指定的目录。 -z：打包的同时使用 gzip 压缩文件，一般后缀会加上 .gz 来表明备份文件的压缩方式，比如 tar -czf /tmp/backup.tar.gz /etc。tgz 是 .tar.gz 的简写。 -j：打包的同时使用 bzip2 压缩文件，一般后缀会加上 .bz2 或者 bzip2 来表明备份文件的压缩方式，比如 tar -cjf /tmp/backup.tar.bz2 /etc。tbz2 是 .tar.bz2 的简写。 -v|--verbose：显示指令执行过程。 tar -cf - /etc：- 表示将 tar 压缩包写入到标准输出，而不是写入文件。 gzip、bzip2 压缩，gzip 压缩更快，bzip2 压缩比例更高。 "},{"id":2,"href":"/os-learn/docs/commands/03_vim/","title":"vim","section":"Linux 常用命令","content":" vim # vim 的四种模式：命令模式，输入模式，底线命令模式，可视模式。\n命令模式 # 启动 vim 就会直接进入命令模式。此状态下敲击键盘识别为命令，而非输入字符。比如此时按下 i，会进入输入模式。\ni a o I A O 都是进入输入模式，区别在于： i：从光标所在位置前面开始插入 I：在当前行首插入 a：从光标所在位置后面开始输入 A：在当前行尾插入 o：在光标所在行下方新增一行并进入输入模式 O：在当前上面一行插入 yy：复制整行内容，例如 3yy 就是复制光标以下的 3 行内容。 y$：复制当前光标到行尾内容 p：粘贴 dd：剪切或者删除光标所在行，20dd 则是删除光标以下的 20 行。 d$：剪切或者删除光标到行尾内容 u：撤销上一次操作 ctrl + r：如果错误的撤销了，可以使用 ctrl + r 恢复。 x：删除当前光标后的一个字符。 G：移动到最后一行，20G 则会移动到第 20 行（可配合 :set nu）。 gg：移动到第一行 :：切换到底线命令模式，也就是在 vim 编辑器的最下面一行输入命令。 输入模式 # 在命令模式下按下 i 就进入了输入模式。\nESC，退出输入模式，切换到命令模式 底线命令模式 # 在命令模式下按下 : 就进入了底线命令模式。底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。\nq：退出 vim。 q!：不保存修改，退出 vim。 w：保存文件 wq 或者 x：保存并退出。 set nu：显示行号 set nonu：取消行号 /：向前搜索 ?：向后搜索 n：向下查找 N：向上查找 s/old/new：用来替换字符串，默认只替换光标所在的行，要替换所有的行使用 %s/old/new，例如 %s/abc/ABC，如果要全局替换所有匹配到的字符使用 %s/old/new/g。 按 ESC 键可随时退出底线命令模式。 可视模式 # 当需要对文件内容进行批量操作时使用，在命令行模式下，可进入不同的可视模式：\nv：字符可视模式，文本选择是以字符为单位的。 V：行可视模式，文本选择是以行为单位的。 ctrl + v：块可视模式，配合 d 和 I 可以进行块操作。例如多行注释，可以 ctrl + v 进入块可视模式，然后上下移动光标，选中添加注释的块，然后按 I，在插入 #，再按两次 ESC，就可以实现多行注释。如果要取消多行注释，可以 ctrl + v 进入块可视模式，然后上下移动光标，选中添加注释的块，然后按 d 来删除 #。 "},{"id":3,"href":"/os-learn/docs/commands/04_user_manage/","title":"用户管理","section":"Linux 常用命令","content":" 用户管理 # Linux 是一个多用户平台，允许多个用户同时登录系统工作。但为了方便分配每个用户的权限，Linux 还支持用户组（Group）。组是多个用户的集合，组可以为成员们分配某一类权限。每个用户可以在多个组，这样就可以利用组给用户快速分配权限。\n用户 # Linux 系统的用户存放在 /etc/passwd 文件中。/etc/shadow 是用户密码相关的文件。\nuseradd：创建用户。useradd pooky 添加了一个用户 pooky。 id pooky 验证 pooky 用户是否存在。root 用户的 uid 是 0。普通用户的 uid 如果改为 0，那就会具有 root 用户的权限。 -g：指定用户组。useradd -g group1 user2 创建用户 user2 并加入到用户组 group1。添加用户时，不指定用户组，就会默认创建和用户名同名的用户组。 userdel：删除用户。userdel pooky 删除用户 pooky。 -r：会删除用户的 home 目录，否则会保留。 passwd：修改密码。 passwd pooky 设置用户 pooky 的密码。直接输入 passwd 会修改当前用户的密码。 usermod：修改用户属性 -d：修改用户 home 目录。usermod -d /hmoe/pookyh pooky 把 pooky 的 home 目录改为 pookyh。 -g：修改用户组。usermod -g group1 pooky 将 pooky 的用户组改为 group1。 chage：修改用户密码的过期信息。 用户组 # Linux 用户组的信息存放在 /etc/group 文件中。\ngroupadd：创建用户组 groupadd group1 groupdel：删除用户组 用户切换 # su 切换用户 su - user1，切换到用户 user1。- 表示同时切换用户环境。exit 退回上个用户。 sudo 以 root 用户身份执行命令。 visudo # su 切换到 root 是需要密码的，如果普通用户想要使用 root 权限，就需要告诉他密码，这是有风险的。因此，就出现了 sudo。\nsudo 命令，可以使 root 权限，有针对性授权给指定的普通用户，而且不需要告诉普通用户 root 的密码。使用 sudo 的前提就是通过配置 /etc/sudoers 文件来授权。\nvisudo 就是编辑 /etc/sudoers 文件的命令。\n## Allows people in group pooky to run all commands %pooky ALL=(ALL) ALL ## Without a password %pooky ALL=(ALL) NOPASSWD: ALL ## Allows members of the users group to mount and unmount the cdrom as root %users ALL=/sbin/mount /mnt/cdrom, /sbin/unmount /mnt/cdrom ## Allows members of the usrs froup to shutdown this system %users localhost=/sbin/shutdown -h now 上面的示例，%pooky 表示 pooky 用户组，如果要表示 pooky 用户，则去掉 %。\nALL=(ALL) 表示在哪些主机可以执行哪些命令。Linux 可以通过 ssh 远程登录，也可以本地登录（localhost）。ALL 表示远程和本地登录都允许。 localhost=/sbin/shutdown -h no 表示本地主句只允许一条命令 /sbin/shutdown -h now。 如果多条命令用逗号分隔，ALL=/sbin/mount /mnt/cdrom, /sbin/unmount /mnt/cdrom 表示 /sbin/mount /mnt/cdrom 和 /sbin/unmount /mnt/cdrom 这两条命令允许执行。 NOPASSWD: ALL 表示普通用户执行管理员权限的密码不需要密码。只有一个 ALL 表示需要密码。 用户和用户组的配置文件 # 用户配置文件 /etc/passwd：\n# 用户名:是否需要密码验证:UID:GID:注释:用户 home 目录:用户登录使用的命令解释器 root:x:0:0:root:/root:/bin/bash bin:x:1:1:bin:/bin:/sbin/nologin daemon:x:2:2:daemon:/sbin:/sbin/nologin # ... root:x 中 x 表示此用户有密码，真正的密码保存在 /etc/shadow 文件中。如果没有 x，表示此用户没有密码。 可以直接编辑这个文件来新建用户。比如添加一行 user1:x:1000:1000::/home/user1:/bin/bash，添加了 user1 用户。用户 home 目录需要手动创建。 可以修改 UID 来修改权限，比如把 UID 改为 0，用户就会拥有 root 权限。 /sbin/nologin 表示不允许登录。 /etc/shadow 保存用户和密码信息，此文件只有 root 用户可以浏览和操作，最大限度地保证了密码的安全：\n# 用户名:加密的密码: root:$6$PcVZ4yj4vlMjqmkL$RUHwggR7gPD0SnjTF1WnStHi2If0hSJnc4M/oVTfD0omJxVGhQgnQhBKRNPiwcBSeL72IerSphnEVdaomgjx./::0:99999:7::: bin:*:17492:0:99999:7::: daemon:*:17492:0:99999:7::: # ... 第二个部分的密码即使相同，但是显示也会不同，更加安全。 用户组配置文件 /etc/group：\n# 用户组名:是否需要密码验证:GID:用户组中的用户列表 root:x:0: bin:x:1: daemon:x:2: daemon2:x:3:bin,daemon2 # ... 用户组中的用户列表：如果为空，表示该用户组是这个用户的初始组，例如 daemon:x:2: 就表示 daemon 这个用户组是用户 daemon 的初始组。每个用户只能属于一个初始组。 "},{"id":4,"href":"/os-learn/docs/commands/05_file_perm/","title":"文件权限","section":"Linux 常用命令","content":" 文件权限 # 查看文件权限 # ls -l 可以查看文件的权限信息：\n-rwxr-xr-x. 1 root root 12059203 Jun 12 2019 renewCert -rwxr-xr-x 第一个字符表示类型 - 表示普通文件。rwxr-xr-x 这 9 个字符表示权限，前面 3 个字符 rwx 表示当前用户的权限，中间 3 个字符 r-x 表示所属用户组的权限，后 3 个字符 r-x 表示其他用户的权限。 1 硬链接的数目。 root root 分别表示文件所属的用户和用户组。 对于普通文件 r, w, x 分别表示：读，写，执行权限。用数字表示就是：r=4，w=2，x=1。 对于目录文件 r, rx, wx 分别表示：进入目录，显示目录内的文件，修改目录内文件的权限。\n文件类型 # -：普通文件。 d：目录文件。 b：块设备文件，存储数据以供系统存取的接口设备，简单说就是硬盘。 c：字符设备文件，串行端口的接口设备，例如键盘、鼠标等等。 l：符号链接（类似 Windows 中的快捷方式）。 p：命名管道文件。 s：套接字文件。 修改文件权限 # chmod：修改文件，目录的权限。 chmod u+x /test，chmod 755 /test。 chown 修改所属用户，用户组。 chown user1 /test 修改 /test 的所属用户为 user1。 chown :group1 /test 修改 /test 的所属用户组为 group1。 chown user1:group1 /test 修改 /test 的所属用户为 user1，用户组为 group1。 chgrp 只修改所属用户组。 chgrp group1 /test 修改 /test 的所属用户组为 group1。 chmod # u：用户，对应个 rwxr-xr-x 中的前三个字符 g：用户组，对应个 rwxr-xr-x 中中间的三个字符 o：其它用户，对应个 rwxr-xr-x 中后面的三个字符 a：所有用户(默认) +：增加权限 -：删除权限 =：设置权限 chmod u+x file # file 的属主增加执行权限 chmod 751 file # file 的属主分配读、写、执行(7)的权限，给 file 的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限 chmod u=rwx,g=rx,o=x file # 上例的另一种形式 chmod =r file # 为所有用户分配读权限 chmod 444 file # 同上例 chmod a-wx,a+r file # 同上例 chmod -R u+r directory # 递归地给 directory 目录下所有文件和子目录的属主分配读的权限 chmod 4755 # 设置 UID，给属主分配读、写和执行权限，给组和其他用户分配读、执行的权限。 特殊权限 # SUID：仅用二进制于可执行文件，执行者将具有该文件的所有者的权限。 SGID：执行者将具有该文件的所属用户组的权限。 SBIT：仅用于目录，用来阻止非文件的所有者删除文件，仅有自己和 root 才有权力删除。 SUID # ls -ld /usr/bin/passwd：\n-rwsr-xr-x. 1 root root 27832 Jan 30 2014 /usr/bin/passwd -rws 这里的 s 表示，在执行 /usr/bin/passwd 时，会以文件的属主，也就是 root 身份来执行。\n如果要设置 SUID，使用 chmod 4xxx \u0026lt;file\u0026gt;, 4 加上原有的权限就可以了。\nSGID # -rwxr-sr-x. 1 root mlocate 39832 Jan 30 2014 /usr/bin/mlocate* r-s，s 出现在用户组的 x 权限的位置，执行者将具有该文件的所属用户组的权限。\nSBIT # drwxrwxrwt. 14 root root 4096 Aug 18 20:11 tmp rwt 里的 t 就表示该文件仅 root 和自己可以删除。\n如果要设置 SBIT，使用 chmod 1xxx \u0026lt;file\u0026gt;, 4 加上原有的权限就可以了。\n"},{"id":5,"href":"/os-learn/docs/commands/06_network/","title":"网络管理","section":"Linux 常用命令","content":" 网络管理 # net-tools 是 CentOS 7 之前的版本使用的网络管理工具，而 iproute2 是 CentOS 7 之后主推的网络管理工具。\nnet-tools # net-tools 包括：\nifconfig：网卡配置。 route：网关配置。 netstat：查看网络状态。 iproute2 # ip：包含了 ifconfig 和 route 的功能。 ss：Socket Statistics 的缩写，和 netstat 类似，但是更快更强。 使用网络工具 # ifconfig 查看网卡 # 执行 ifconfig 查看网卡。\n一般第一块网卡是 eth0。也可能是：\neno1 板载网卡 ens33 PCI-E 网卡 enp0s3 无法获取物理信息的 PCI-E 网卡 都不匹配就使用 eth0。\n配置网卡名称 # 在管理服务器集群时，网卡名称不同，会不好管理。如何配置网卡名称？\n首先，网卡命名规则受两个参数影响，分别是 biosdevname 和 net.ifnames。grup 是系统启动时，引导内核的工具。\n编辑 /etc/default/grup 文件，在 GRUP_CMDLINE_LINUX 对应的命令后面添加（或修改）参数 biosdevname=0 net.ifnames=0，就可以传递到内核。 /etc/default/grup 需要运行 grup2-mkconfig -o /boot/grup2/grup.cfg 才会更新 grup，被内核读取。 reboot 规则：\nbiosdevname net.ifnames 网卡名 0 1 ens33（default） 1 0 em1 0 0 eth0 网线的连接状态 # mii-tool \u0026lt;网卡名称\u0026gt;。\n查看网关 # route，常用命令是 route -n，因为 route 会尝试解析主机名，也就是将 IP 转换为域名，可能耗时较长。\n配置网卡 # ifconfig \u0026lt;网卡\u0026gt; \u0026lt;IP\u0026gt; [netmask 子网掩码] 配置网卡的 IP。注意如果是远程登录，修改 IP，可能会直接断开连接。 ifup \u0026lt;网卡\u0026gt; 启动网卡 ifdown \u0026lt;网卡\u0026gt; 关闭网卡 配置网关 # route add default gw \u0026lt;网关 IP\u0026gt; 添加默认网关 route add -host \u0026lt;IP\u0026gt; gw \u0026lt;网关 IP\u0026gt; 添加路由，访问指定 IP 时，使用指定的网关 route add -net \u0026lt;网段\u0026gt; netmask \u0026lt;子网掩码\u0026gt; gw \u0026lt;网关 IP\u0026gt; 添加路由，访问指定网段时，使用指定网关 route del default gw \u0026lt;网关 IP\u0026gt; 删除默认网关 使用 ip 命令 # ip addr ls 相当于 ifconfig ip link set dev eth0 up 相当于 ifup eth0 ip addr add 10.0.0.1/24 dev eth1 相当于 ifconfig eth1 netmask 255.255.255.0 ip route add 10.0.0.1/24 via 192.168.0.1 相当于 route add -net 10.0.0.0 netmask 255.255.255.0 gw 192.168.0.1。 网络故障排查 # ping traceroute mtr nslookup telnet tcpdump netstat ss 如何查看到目标主机的网络状态 # 使用 ping \u0026lt;IP 或者 域名\u0026gt; 查看网络是否是通的。 traceroute 和 mtr 辅助 ping 命令，在 ping 通网络之后，如果网络通信还是有问题，可以使用 traceroute 可以查看网络中每一跳的网络质量。mtr 可以检测网络中是否有丢包。 nslookup 查看域名对应的 IP。 如果主机可以连接，但是服务仍然无法访问，使用 telnet 检查端口状态。 如果端口没有问题，仍然无法访问，可以使用 tcpdump 进行抓包，更细致的查看网络问题。 使用 netstat 和 ss，查看服务范围。 traceroute # traceroute -w 1 www.baidu.com，-w 1 wait，表示某个 IP 超时的最大等待时间为 1 秒。 -n 显示 IP 地址 -m 设置检测数据包的最大存活数值 TTL 的大小 -q 每个网关发送数据包个数 -p UDP 端口 [root@shcCDFrh75vm8 ~]# traceroute -w 1 www.baidu.com traceroute to www.baidu.com (104.193.88.77), 30 hops max, 60 byte packets 1 gateway (16.155.192.1) 0.525 ms 0.635 ms 0.800 ms 2 10.132.24.193 (10.132.24.193) 0.600 ms 0.930 ms 1.137 ms 3 192.168.201.122 (192.168.201.122) 0.826 ms 0.746 ms 0.674 ms 4 192.168.200.45 (192.168.200.45) 2.045 ms 1.978 ms 1.962 ms 5 192.168.203.249 (192.168.203.249) 29.375 ms 29.351 ms 29.275 ms 6 192.168.203.250 (192.168.203.250) 3.892 ms 2.980 ms 2.907 ms 7 192.168.200.185 (192.168.200.185) 68.675 ms 68.636 ms 68.691 ms 8 192.168.200.186 (192.168.200.186) 70.094 ms 70.356 ms 69.995 ms 9 * * * 10 * * * 11 * * * 12 * * * 13 * * * 14 * * * 15 * * * 16 * * * 17 * * * 18 * * * 19 * * * * 表示不支持 traceroute 追踪。\n记录按序列号从 1 开始，每个纪录就是一跳 ，每跳表示一个网关，可以看到每行有三个时间，单位是 ms，之所以是 3 个，其实就是 -q 的默认参数。探测数据包向每个网关发送三个数据包后，网关响应后返回的时间。\nmtr # 运行 mtr 可以查看更详细的网络状态：\nMy traceroute [v0.85] shcCDFrh75vm8.hpeswlab.net (0.0.0.0) Thu Aug 20 22:02:41 2020 Keys: Help Display mode Restart statistics Order of fields quit Packets Pings Host Loss% Snt Last Avg Best Wrst StDev 1. localhost 0.0% 3 0.1 0.1 0.1 0.1 0.0 由于没有与当前主机进行通信，所以只显示了 localhost 的状态。\nHost：IP 地址和域名，按 n 键可以切换 IP 和域名 Loss 表示丢包率。 Snt：设置每秒发送数据包的数量，默认值是 10 可以通过参数 -c 来指定 Last：最近一次的 ping 值 Avg：是平均值 发送 ping 包的平均时延 Best：是最好或者说时延最短的 Wrst：是最差或者说时延最长的 StDev：标准偏差 nslookup # nslookup \u0026lt;域名\u0026gt;：\n[root@shcCDFrh75vm8 ~]# nslookup www.baidu.com Server: 16.187.185.202 Address: 16.187.185.202#53 Non-authoritative answer: www.baidu.com canonical name = www.a.shifen.com. # 别名 www.a.shifen.com canonical name = www.wshifen.com. Name: www.wshifen.com Address: 104.193.88.77 Name: www.wshifen.com Address: 104.193.88.123 Server 域名解析服务器 IP。\ntelnet # telnet \u0026lt;IP 或 域名\u0026gt; \u0026lt;端口\u0026gt;\n[root@SGDLITVM0905 ~]# telnet www.baidu.com 80 Trying 104.193.88.77... Connected to www.baidu.com. Escape character is \u0026#39;^]\u0026#39;. 上面的示例说明端口是通的，输入 quit 退出。\ntcpdump # [root@shcCDFrh75vm8 ~]# tcpdump tcpdump: verbose output suppressed, use -v or -vv for full protocol decode listening on virbr0, link-type EN10MB (Ethernet), capture size 262144 bytes 抓到的数据包会实时显示出来。\n常用的操作：\ntcpdump -i eth1 监听指定网口的数据包。不指定的情况下默认监听第一个网口，一般是 eth0。 tcpdump -i any -n 监听所有网口的数据包。-n 不解析域名。 tcpdump host 192.155.17.1 ，截获所有 IP 为 192.155.17.1 的主机接收和发送的所有数据包。 tcpdump -c 20 截获 20 个数据包就结束。-c 指定数据包的数量。 tcpdump -i eth0 src host hostname\u0026gt; 截获从主机 hostname 发送的所有数据包 tcpdump -i eth0 src host hostname 监听所有发送到主机 hostname 的数据包 tcpdump udp port 123 监听 123 端口的 udp 数据包。就是监听 ntp 的服务端口。 tcpdump tcp port 23 and host 192.155.17.1 监听 23 端口，从主机 192.155.17.1 接收或发出的 tcp 数据包。就是监听 telnet 包。 tcpdump tcp port 23 and host 192.155.17.1 -w /tmp/test.dump，-w 表示包截获的数据 dump 到文件中。 netstat # 查看 Linux 中网络系统状态信息。\n[root@shcCDFrh75vm8 ~]# netstat -ntp Active Internet connections (w/o servers) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 16.155.194.49:22 10.5.41.247:57470 ESTABLISHED 394/sshd: root@pts/ tcp 0 0 16.155.194.49:22 10.5.41.247:64890 ESTABLISHED 25497/sshd: root@pt tcp 0 0 16.155.194.49:22 10.5.41.247:57450 ESTABLISHED 6479/sshd: root@not tcp 0 180 16.155.194.49:22 15.122.72.86:51641 ESTABLISHED 25305/sshd: root@pt [root@shcCDFrh75vm8 ~]# netstat -ntpl Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 127.0.0.1:6012 0.0.0.0:* LISTEN 25305/sshd: root@pt tcp 0 0 0.0.0.0:2049 0.0.0.0:* LISTEN - tcp 0 0 0.0.0.0:45060 0.0.0.0:* LISTEN - tcp 0 0 0.0.0.0:111 0.0.0.0:* LISTEN 791/rpcbind tcp 0 0 0.0.0.0:20048 0.0.0.0:* LISTEN 1341/rpc.mountd tcp 0 0 192.168.122.1:53 0.0.0.0:* LISTEN 1832/dnsmasq tcp 0 0 0.0.0.0:50037 0.0.0.0:* LISTEN 1325/rpc.statd tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1320/sshd tcp 0 0 127.0.0.1:631 0.0.0.0:* LISTEN 1321/cupsd tcp 0 0 127.0.0.1:25 0.0.0.0:* LISTEN 1674/master tcp 0 0 127.0.0.1:6010 0.0.0.0:* LISTEN 25497/sshd: root@pt tcp 0 0 127.0.0.1:6011 0.0.0.0:* LISTEN 394/sshd: root@pts/ tcp6 0 0 ::1:6012 :::* LISTEN 25305/sshd: root@pt tcp6 0 0 :::35712 :::* LISTEN 1325/rpc.statd tcp6 0 0 :::2049 :::* LISTEN - tcp6 0 0 :::36773 :::* LISTEN - tcp6 0 0 :::111 :::* LISTEN 791/rpcbind tcp6 0 0 :::20048 :::* LISTEN 1341/rpc.mountd tcp6 0 0 :::22 :::* LISTEN 1320/sshd tcp6 0 0 ::1:631 :::* LISTEN 1321/cupsd tcp6 0 0 ::1:6010 :::* LISTEN 25497/sshd: root@pt tcp6 0 0 ::1:6011 :::* LISTEN 394/sshd: root@pts/ 常用的参数：\n-n 不解析域名 -p 显示进程号 -l 显示监听（LISTEN）服务 -t 显示 tcp 协议 -i 显示网卡列表 ss # 属于 iproute2 工具包，类似 netstat，参数类似，显示格式不同。\n[root@shcCDFrh75vm8 ~]# ss -ntpl State Recv-Q Send-Q Local Address:Port Peer Address:Port LISTEN 0 128 127.0.0.1:6012 *:* users:((\u0026#34;sshd\u0026#34;,pid=25305,fd=9)) LISTEN 0 64 *:2049 *:* LISTEN 0 64 *:45060 *:* LISTEN 0 128 *:111 *:* users:((\u0026#34;rpcbind\u0026#34;,pid=791,fd=8)) LISTEN 0 128 *:20048 *:* users:((\u0026#34;rpc.mountd\u0026#34;,pid=1341,fd=8)) LISTEN 0 5 192.168.122.1:53 *:* users:((\u0026#34;dnsmasq\u0026#34;,pid=1832,fd=6)) LISTEN 0 128 *:50037 *:* users:((\u0026#34;rpc.statd\u0026#34;,pid=1325,fd=8)) LISTEN 0 128 *:22 *:* users:((\u0026#34;sshd\u0026#34;,pid=1320,fd=3)) LISTEN 0 128 127.0.0.1:631 *:* users:((\u0026#34;cupsd\u0026#34;,pid=1321,fd=12)) LISTEN 0 100 127.0.0.1:25 *:* users:((\u0026#34;master\u0026#34;,pid=1674,fd=13)) LISTEN 0 128 127.0.0.1:6010 *:* users:((\u0026#34;sshd\u0026#34;,pid=25497,fd=9)) LISTEN 0 128 127.0.0.1:6011 *:* users:((\u0026#34;sshd\u0026#34;,pid=394,fd=9)) LISTEN 0 128 ::1:6012 :::* 网络服务管理 # service network start|stop|restart|status chkconfig --list network systemctl list-unit-files NetworkManager.service systemctl start|stop|restart|status NetworkManager systemctl enable|disable NetworkManager CentOS 7 中，systemctl 是 service 的替代品。\nnetwork 和 NetworkManager 是两套网络管理工具，应该只使用其中一套，禁用另一套。CentOS 6 之前只有 network 服务。\n配置文件 # /etc/sysconfig/network-scripts/ifcfg-eth0 网卡配置文件，名称是动态的。eth0 对应的是网卡的名称。 /etc/hosts host 文件。 查看 network 状态 # [root@shcCDFrh75vm8 ~]# service network status Configured devices: lo Profile_1 ens32 Currently active devices: lo ens32 virbr0 docker0 重新初始化设置：\n[root@shcCDFrh75vm8 ~]# service network restart Restarting network (via systemctl) # 其实还是使用的 systemctl 这条命令会还原之前使用命令做的配置。\n使用 systemctl 管理 NetworkManager。\n查看服务：\n[root@shcCDFrh75vm8 ~]# systemctl list-unit-files NetworkManager.service UNIT FILE STATE NetworkManager.service enabled 1 unit files listed. 关闭 network 服务 # [root@shcCDFrh75vm8 ~]# chkconfig --list network # 查看 Note: This output shows SysV services only and does not include native systemd services. SysV configuration data might be overridden by native systemd configuration. If you want to list systemd services use \u0026#39;systemctl list-unit-files\u0026#39;. To see services enabled on particular target use \u0026#39;systemctl list-dependencies [target]\u0026#39;. network 0:off 1:off 2:on 3:on 4:on 5:on 6:off [root@shcCDFrh75vm8 ~]# chkconfig --level 2345 network off # 禁用 Note: This output shows SysV services only and does not include native systemd services. SysV configuration data might be overridden by native systemd configuration. If you want to list systemd services use \u0026#39;systemctl list-unit-files\u0026#39;. To see services enabled on particular target use \u0026#39;systemctl list-dependencies [target]\u0026#39;. network 0:off 1:off 2:on 3:on 4:on 5:on 6:off 网卡配置文件 # [root@shcCDFrh75vm8 network-scripts]# cat ifcfg-ens32 HWADDR=00:50:56:b0:71:0e NAME=ens32 DEVICE=ens32 DNS1=16.187.185.201 DNS2=16.187.185.202 DOMAIN=hpeswlab.net ONBOOT=yes # 开机时是否启用该网卡 USERCTL=no PEERDNS=no BOOTPROTO=dhcp # dhcp 动态分配 IP ，\u0026#34;none\u0026#34; 静态 IP # 静态 IP 需要的配置 #IPADDR=\u0026lt;IP\u0026gt; #NETMASK=\u0026lt;子网掩码\u0026gt; #GATEWAY=\u0026lt;网关 IP\u0026gt; check_link_down() { return 1; } ZONE=public 使配置生效：\nservice network restart # 或者 systemctl restart NetworkManager 修改主机名 # 执行 hostname 可以查看当前主机名。\n# 临时修改主机名 hostname pooky75vm8.lab.net # 永久生效，重启也不会改变 hostnamectl set-hostname pooky75vm8.lab.net 有些服务是依赖主机名的，修改主机名会影响这些服务。需要修改 host 文件 /etc/hosts，添加一行映射：127.0.0.1 pooky75vm8.lab.net。\n否则某些服务启动时，可能会卡住。\nLinux 路由表 # 指记录路由信息的表(可以单路由表，也可以多路由表)。\n[root@shcCDFrh75vm7 container]# route Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface default gateway 0.0.0.0 UG 100 0 0 ens32 16.155.192.0 0.0.0.0 255.255.248.0 U 100 0 0 ens32 192.168.99.0 0.0.0.0 255.255.255.0 U 0 0 0 testbridge 192.168.122.0 0.0.0.0 255.255.255.0 U 0 0 0 virbr0 [root@shcCDFrh75vm7 container]# route -n # 查看默认路由表 Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface 0.0.0.0 16.155.192.1 0.0.0.0 UG 100 0 0 ens32 16.155.192.0 0.0.0.0 255.255.248.0 U 100 0 0 ens32 192.168.99.0 0.0.0.0 255.255.255.0 U 0 0 0 testbridge 192.168.122.0 0.0.0.0 255.255.255.0 U 0 0 0 virbr0 列 描述 Destination 目标网络或目标主机。当值为 default（0.0.0.0）时，表示这个是默认网关，所有数据都发到这个网关 Gateway 网关地址，0.0.0.0 表示对应的 Destination 跟本机在同一个网段，通信时不需要经过网关 Genmask Destination 的子网掩码，Destination 是主机时需要设置为 255.255.255.255，是默认路由时会设置为 0.0.0.0 Flags 标记 Metric 路由距离，到达指定网络所需的中转数 Ref 路由项引用次数 Use 此路由项被路由软件查找的次数 Iface 网卡名字 Flags 含义：\nU 路由是活动的 H 目标是个主机 G 需要经过网关 R 恢复动态路由产生的表项 D 由路由的后台程序动态地安装 M 由路由的后台程序修改 ! 拒绝路由 当在一台 linux 机器上要访问一个目标 ip 时：\n如果本机有目标 ip，则会直接访问本地; 如果本地没有目标 ip 用 route -n 查看路由，如果路由条目里包含了目标 ip 的网段，则数据包就会从对应路由条目后面的网卡出去 如果没有对应网段的路由条目，则全部都走网关 如果网关也没有，则报错：网络不可达 因为本机 ens32 这个网卡有 16.155.192.0/21 这个网段的 IP，所以就会默认产生类似下面的路由条目\n16.155.192.0 0.0.0.0 255.255.248.0 U 100 0 0 ens32 ens32 网卡的 IP：\n[root@shcCDFrh75vm7 container]# ip addr 2: ens32: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:50:56:b0:31:14 brd ff:ff:ff:ff:ff:ff inet 16.155.197.5/21 brd 16.155.199.255 scope global noprefixroute dynamic ens32 valid_lft 118238sec preferred_lft 118238sec inet6 fe80::6833:a88a:7b0f:285c/64 scope link noprefixroute valid_lft forever preferred_lft forever 那么根据规则和上面的路由表，如果要访问 16.155.192.11 这个IP，会怎么走？\n会通过 16.155.192.0/255.255.248.0 这个路由条目后面指示的 ens33 网卡去寻找 16.155.192.11。\n如果要访问 119.75.217.26 这个 IP，请问会怎么走？\n会通过网关 16.155.192.1 去寻找。\nroute 命令 # route 命令可以显示或设置 Linux 内核中的路由表，主要是静态路由。\n# route [add|del] [-net|-host] target [netmask Nm] [gw Gw] [[dev] If] add：增加一条路由规则 del：删除一条路由规则 -net：目的地址是一个网络 -host：目的地址是一个主机 target：目的网络或主机 netmask：目的地址的网络掩码 gw：路由数据包通过的网关 dev：为路由指定的网络接口 在 CentOS 中默认的内核配置已经包含了路由功能，但默认并没有在系统启动时启用此功能。开启 Linux 的路由功能可以通过调整内核的网络参数来实现。要 配置和调整内核参数可以使用 sysctl 命令。例如：要开启 Linux 内核的数据包转发功能可以使用如下的命令。\nsysctl -w net.ipv4.ip_forward=1 # or vi /etc/sysctl.conf net.ipv4.ip_forward = 1 # 查看是否支持转发 sysctl net.ipv4.ip_forward 对于局域网中的 Linux 主机，要想访问 Internet，需要将局域网的网关 IP 地址设置为这个主机的默认路由。可以在 /etc/rc.local 中添加 route 命令来保证路由设置永久有效。\n"},{"id":6,"href":"/os-learn/docs/commands/07_package_manage/","title":"包管理器","section":"Linux 常用命令","content":" 包管理器 # 对于 Windows 系统，最方便的方式就是下载 exe 文件，也就是安装文件。下载后我们直接双击安装即可。\n对于 Linux 来讲，也是类似的方法，你可以下载 rpm 或者 deb。这个就是 Linux 下面的安装包。Linux 现在常用的有两大体系，一个是 CentOS 体系，一个是 Ubuntu 体系，前者使用 rpm，后者使用 deb。\nCentOS 下面使用 rpm -i jdk-XXX_linux-x64_bin.rpm 进行安装，Ubuntu 下面使用 dpkg -i jdk-XXX_linux-x64_bin.deb。其中 -i 就是 install 的意思。\nrpm -qa 和 dpkg -l 可以查看安装的软件列表，-q 就是 query，a 就是 all，-l 的意思就是 list。\nrpm，yum：CentOS 和 RedHat 使用 yum 包管理器，安装包的格式为 rpm。 apt：Ubuntu 和 Debian 使用 apt 包管理器，安装包的格式为 deb。 rpm 包格式 # bind-9.8.2-0.47.rc1.el6.x86_64.rpm：\n软件名，如 bind。 软件版本，9.8.2-0 是软件版本，版本号格式通常为 主版本号.次版本号.修正号。47 是发布版本号，表示这个 rpm 软件包是第几次编译生成的。 系统版本，如 el6，表示支持的系统版本是 CentOS 6，el7 就是支持的系统版本是 CentOS 7。 平台，如 x86_64。 特殊名称： devel：表示这个 rpm 包是软件的开发包。 noarch：说明这样的软件包可以在任何平台安装和运行，不需要特定的硬件平台。 rpm 命令 # 常用参数：\n-q 查询，rpm -qa 查询当前系统安装了那些 rpm 包，-a 查询所有。rpm -q vim-common 查询 vim-common 是否安装。 -i 安装，rpm -i bind-9.8.2-0.47.rc1.el6.x86_64.rpm 安装指定软件包 -e 卸载一个或多个，rpm -e bind 卸载软件包 yum # 相当于 Windows 上的软件管家。\nyum 包管理器解决的问题：\nrpm 包的安装可能有依赖关系，如： $ rpm -i vim-enhanced-7.4.160-5.el7.x86_64.rpm 错误：依赖检测失败： vim-common = 2:7.4.160-5.el7 被 vim-enhanced-7.4.160-5.el7.x86_64 需要 安装 vim-enhanced 需要先安装 vim-common 包。这时候就需要先去下载 vim-common 包，再安装 vim-common 包，才能安装 vim-enhanced。\n依赖多的时候，就需要手动的管理。\n软件包来源不可靠。 yum 源 # 软件管家会有一个统一的服务端，来保存这些软件，但是我们不知道服务端在哪里。而 Linux 允许我们配置从哪里下载这些软件，下载地址就在配置文件里面。也就是 yum 源。\nhttp://mirror.centos.org/centos/7/ 访问国内镜像源，会比较快：\nhttps://developer.aliyun.com/mirror/ http://tel.mirrors.163.com/ yum 配置文件 # yum 源配置文件： /etc/yun.repos.d/CentOS-Base.repo。\n使用国内的镜像源，可以直接下载源配置文件：\n先将源文件备份：mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup。 再替换原来的文件：wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo 。 运行 yum makecache 生成缓存。 文件内容：\n[base] # 表示基础应用的包 name=CentOS-$releasever - Base - mirrors.aliyun.com failovermethod=priority # baseurl 表示包所在的源的路径 baseurl=http://mirrors.aliyun.com/centos/$releasever/os/$basearch/ http://mirrors.aliyuncs.com/centos/$releasever/os/$basearch/ http://mirrors.cloud.aliyuncs.com/centos/$releasever/os/$basearch/ gpgcheck=1 # 检测是否被篡改 gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7 yum 命令 # install：安装 remove：卸载 list|grouplist：查看 update：更新 "},{"id":7,"href":"/os-learn/docs/commands/08_grup/","title":"grup","section":"Linux 常用命令","content":" grup # grup 是内核启动的引导软件。\nCentOS 6 grup 所有文件需要手动修改。CentOS 7 提供了命令行工具。\n配置文件：\n/etc/default/grup：默认的 grup 配置文件。 /etc/grup.d/ /boot/grup2/grup.cfg：这个文件不应该直接修改，应该修改默认的配置文件。 grup2-mkconfig -o /boot/grup2/grup.cfg：该命令会生成新的 grup 配置文件。 默认配置文件 /etc/default/grup：\nGRUB_TIMEOUT=5 GRUB_DISTRIBUTOR=\u0026#34;$(sed \u0026#39;s, release .*$,,g\u0026#39; /etc/system-release)\u0026#34; GRUB_DEFAULT=saved GRUB_DISABLE_SUBMENU=true GRUB_TERMINAL_OUTPUT=\u0026#34;console\u0026#34; GRUB_CMDLINE_LINUX=\u0026#34;crashkernel=auto rd.lvm.lv=rhel/root rd.lvm.lv=rhel/swap rhgb quiet\u0026#34; GRUB_DISABLE_RECOVERY=\u0026#34;true\u0026#34; ~ "},{"id":8,"href":"/os-learn/docs/commands/09_process/","title":"进程管理","section":"Linux 常用命令","content":" 进程管理 # 进程的生命周期是可管理的。\n查看进程 # ps pstree top 进程也是树形结构。进程和权限密不可分。\nps # 执行 ps 查看当前终端的可以看到的进程，p 代表 processes，也就是进程；s 代表 snapshot，也就是快照：\n[root@pooky ~]# ps PID TTY TIME CMD 8974 pts/2 00:00:00 bash 12550 pts/2 00:00:00 ps ps -e 查看所有终端的进程：\n[root@pooky ~]# ps -e PID TTY TIME CMD 1 ? 00:50:59 systemd 2 ? 00:00:06 kthreadd 3 ? 00:00:01 ksoftirqd/0 5 ? 00:00:00 kworker/0:0H 7 ? 00:00:00 migration/0 8 ? 00:00:00 rcu_bh 9 ? 00:26:58 rcu_sched 10 ? 00:00:00 lru-add-drain 11 ? 00:00:23 watchdog/0 12 ? 00:00:23 watchdog/1 13 ? 00:00:04 migration/1 14 ? 00:00:02 ksoftirqd/1 16 ? 00:00:00 kworker/1:0H 17 ? 00:00:25 watchdog/2 18 ? 00:00:00 migration/2 19 ? 00:00:01 ksoftirqd/2 21 ? 00:00:00 kworker/2:0H 22 ? 00:00:25 watchdog/3 23 ? 00:00:04 migration/3 24 ? 00:00:02 ksoftirqd/3 ps -A 和 ps -e 一样。 ps -ef：显示所有进程，包含命令信息，-f 包含更多描述字段。 ps -eLf：显示线程。 ps -au：显示详细的信息。 ps -aux：显示所有用户的进程。 ps -u root：显示 root 用户的进程。 pstree # 查看进程之间的关系。\n[root@pooky ~]# pstree systemd─┬─ModemManager───2*[{ModemManager}] ├─NetworkManager─┬─dhclient │ └─2*[{NetworkManager}] ├─VGAuthService ├─2*[abrt-watch-log] ├─abrtd ├─accounts-daemon───2*[{accounts-daemon}] ├─alsactl ├─at-spi-bus-laun─┬─dbus-daemon───{dbus-daemon} │ └─3*[{at-spi-bus-laun}] ├─at-spi2-registr───2*[{at-spi2-registr}] ├─atd ├─auditd─┬─audispd─┬─sedispatch │ │ └─{audispd} │ └─{auditd} ├─avahi-daemon───avahi-daemon ├─chronyd ├─colord───2*[{colord}] ├─crond ├─cupsd ├─2*[dbus-daemon───{dbus-daemon}] ├─dbus-launch ├─dnsmasq───dnsmasq ├─dockerd─┬─containerd───27*[{containerd}] │ └─45*[{dockerd}] ├─gdm─┬─X───9*[{X}] │ ├─gdm-session-wor─┬─gnome-session-b─┬─gnome-shell─┬─ibus-daemon─┬─ibus-dconf───3*[{ibus-dconf}] │ │ │ │ │ ├─ibus-engine-sim───2*[{ibus-engine-sim+ │ │ │ │ │ └─2*[{ibus-daemon}] │ │ │ │ └─32*[{gnome-shell}] │ │ │ ├─gsd-a11y-keyboa───3*[{gsd-a11y-keyboa}] │ │ │ ├─gsd-a11y-settin───3*[{gsd-a11y-settin}] │ │ │ ├─gsd-clipboard───2*[{gsd-clipboard}] │ │ │ ├─gsd-color───3*[{gsd-color}] │ │ │ ├─gsd-datetime───2*[{gsd-datetime}] │ │ │ ├─gsd-housekeepin───2*[{gsd-housekeepin}] │ │ │ ├─gsd-keyboard───3*[{gsd-keyboard}] │ │ │ ├─gsd-media-keys───3*[{gsd-media-keys}] │ │ │ ├─gsd-mouse───2*[{gsd-mouse}] │ │ │ ├─gsd-power───3*[{gsd-power}] │ │ │ ├─gsd-print-notif───2*[{gsd-print-notif}] │ │ │ ├─gsd-rfkill───2*[{gsd-rfkill}] │ │ │ ├─gsd-screensaver───2*[{gsd-screensaver}] │ │ │ ├─gsd-sharing───3*[{gsd-sharing}] │ │ │ ├─gsd-smartcard───4*[{gsd-smartcard}] │ │ │ ├─gsd-sound───3*[{gsd-sound}] │ │ │ ├─gsd-wacom───2*[{gsd-wacom}] │ │ │ ├─gsd-xsettings───3*[{gsd-xsettings}] │ │ │ └─3*[{gnome-session-b}] │ │ └─2*[{gdm-session-wor}] │ └─3*[{gdm}] ├─gssproxy───5*[{gssproxy}] ├─ibus-portal───2*[{ibus-portal}] ├─ibus-x11───2*[{ibus-x11}] ├─irqbalance ├─ksmtuned───sleep ├─libvirtd───16*[{libvirtd}] ├─lsmd ├─lvmetad ├─master─┬─pickup │ └─qmgr ├─mcelog ├─packagekitd───2*[{packagekitd}] ├─polkitd───5*[{polkitd}] ├─pulseaudio───{pulseaudio} ├─rhnsd ├─rhsmcertd ├─rpc.idmapd ├─rpc.mountd ├─rpc.statd ├─rpcbind ├─rsyslogd───2*[{rsyslogd}] ├─rtkit-daemon───2*[{rtkit-daemon}] ├─smartd ├─sshd─┬─2*[sshd───bash] │ ├─sshd───3*[sftp-server] │ └─sshd───bash───pstree ├─systemd-journal ├─systemd-logind ├─systemd-udevd ├─udisksd───4*[{udisksd}] ├─upowerd───2*[{upowerd}] ├─vmtoolsd───{vmtoolsd} ├─wpa_supplicant └─xdg-permission-───2*[{xdg-permission-}] top # top 显示进程和系统信息。其实和 ps 差不多，只不过显示的是实时数据。\n[root@pooky ~]# top top - 21:01:33 up 62 days, 10:40, 3 users, load average: 0.05, 0.03, 0.05 Tasks: 240 total, 1 running, 239 sleeping, 0 stopped, 0 zombie %Cpu(s): 0.1 us, 0.1 sy, 0.0 ni, 99.8 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st KiB Mem : 16266780 total, 7581412 free, 1100140 used, 7585228 buff/cache KiB Swap: 0 total, 0 free, 0 used. 14404532 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 936 root 20 0 1210844 37064 14992 S 0.7 0.2 583:14.27 containerd 16865 root 20 0 162096 2376 1576 R 0.7 0.0 0:00.13 top 786 avahi 20 0 62372 2276 1812 S 0.3 0.0 341:04.74 avahi-daemon 805 root 20 0 2208132 91280 26176 S 0.3 0.6 349:03.69 dockerd 2067 gdm 20 0 755416 32672 9388 S 0.3 0.2 271:23.92 gsd-color 1 root 20 0 194124 7264 4188 S 0.0 0.0 51:00.39 systemd 2 root 20 0 0 0 0 S 0.0 0.0 0:06.19 kthreadd 3 root 20 0 0 0 0 S 0.0 0.0 0:01.14 ksoftirqd/0 5 root 0 -20 0 0 0 S 0.0 0.0 0:00.00 kworker/0:0H 7 root rt 0 0 0 0 S 0.0 0.0 0:00.88 migration/0 8 root 20 0 0 0 0 S 0.0 0.0 0:00.00 rcu_bh 9 root 20 0 0 0 0 S 0.0 0.0 26:59.02 rcu_sched 10 root 0 -20 0 0 0 S 0.0 0.0 0:00.00 lru-add-drain 11 root rt 0 0 0 0 S 0.0 0.0 0:23.27 watchdog/0 12 root rt 0 0 0 0 S 0.0 0.0 0:23.57 watchdog/1 13 root rt 0 0 0 0 S 0.0 0.0 0:04.91 migration/1 14 root 20 0 0 0 0 S 0.0 0.0 0:02.78 ksoftirqd/1 16 root 0 -20 0 0 0 S 0.0 0.0 0:00.00 kworker/1:0H 17 root rt 0 0 0 0 S 0.0 0.0 0:25.69 watchdog/2 18 root rt 0 0 0 0 S 0.0 0.0 0:00.70 migration/2 19 root 20 0 0 0 0 S 0.0 0.0 0:01.22 ksoftirqd/2 21 root 0 -20 0 0 0 S 0.0 0.0 0:00.00 kworker/2:0H 22 root rt 0 0 0 0 S 0.0 0.0 0:25.11 watchdog/3 23 root rt 0 0 0 0 S 0.0 0.0 0:04.72 migration/3 24 root 20 0 0 0 0 S 0.0 0.0 0:02.66 ksoftirqd/3 26 root 0 -20 0 0 0 S 0.0 0.0 0:00.00 kworker/3:0H 27 root rt 0 0 0 0 S 0.0 0.0 0:29.23 watchdog/4 28 root rt 0 0 0 0 S 0.0 0.0 0:02.59 migration/4 第一行：\n21:01:33 up 62 days 表示从系统开机到现在的运行时间。 3 users 表示当前有 3 个用户登录 load average: 0.05, 0.03, 0.05 系统平均负载，三个值分别表示 1 分钟，5 分钟，15 分钟内的平均负载。 第二行：\n240 total 表示有 240 个进程在运行 1 running, 239 sleeping, 0 stopped, 0 zombie 运行的进程有不同的状态。这里就表示有 1 个 running 状态的进程，239 个 sleeping 状态的进程。 第三行 CPU 使用情况：\n0.1 us, 0.1 sy, 0.0 ni, 99.8 id 0.0 wa，其中 0.1 us 表示用户控件占用百分之 0.1 的 CPU，0.1 sy 表示内核空间占用百分之 0.7 的 CPU，0.0 ni 表示改变过优先级的进程 CPU 占比，99.8 id 表示空闲 CPU 占比，wa 表示 IO 等待，0.0 hi 硬件中断（hardware IRQ） CPU 占比，0.0 si 软件中断 CPU 占比。 %Cpu(s) 显示的是多个 CPU 的平均值，如果想查看每个 CPU 对应的使用率，按数字键 1，就会展开所有的 CPU。 第四行，内存的使用率：\n16266780 total, 7581412 free, 1100140 used, 7585228 buff/cache 表示内存总量为 16266780，剩余可用内存为 7581412，已使用内存 1100140， 7585228 buff/cache 表示正在用来读写的缓存。 第五行，交换分区，当物理内存不够时，就需要使用 swap：\n0 total, 0 free, 0 used. 14404532 avail Mem，0 used 表示没有使用 swap，说明物理内存还够用。 再下面的信息是动态的进程信息：\nPR 进程优先级 NI nice 值。值越小优先级越高，最小 -20 ，最大 20（用户设置最大 19） VIRT 进程虚拟内存的大小，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内。 RES 是常驻内存的大小，也就是进程实际使用的物理内存大小，不包括 Swap 和共享内存。 SHR 是共享内存的大小，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等。 S 进程状态 %CPU 进程占用 CPU 百分比 %MEM 进程占用物理内存百分比。 TIME+ 进程运行时间 常用参数：\n-d 指定信息刷新的时间间隔。也可以使用按键 s 交互命令来改变。 -p 指定进程 ID ，值显示指定进程的状态。 -i 不显示闲置或者僵死进程。 -c 显示完整的命令。 进程控制 # 调整进程的优先级 nice 范围从 -20 到 19，值越小表示优先级越高，抢占资源就越多。 renice 重新设置优先级。 进程的作业控制 \u0026amp; 符号，后台运行进程，./a.sh \u0026amp;。 jobs 命令。 nice # a.sh 是一个死循环的脚本：\n#!/bin/bash echo $$ while : do : done 然后修改运行权限并运行：\n[root@pooky ~]# ./a.sh 23248 打开一个新的终端，top 基本视图中，按数字 1，可监控每个逻辑 CPU 的状况：\n[root@pooky ~]# top -p 23294 top - 07:53:53 up 62 days, 21:33, 4 users, load average: 0.47, 0.15, 0.09 Tasks: 1 total, 1 running, 0 sleeping, 0 stopped, 0 zombie %Cpu0 : 0.0 us, 0.0 sy, 0.0 ni,100.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st %Cpu1 : 0.0 us, 0.0 sy, 0.0 ni,100.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st %Cpu2 : 0.0 us, 0.0 sy, 0.0 ni,100.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st %Cpu3 :100.0 us, 0.0 sy, 0.0 ni, 0.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st %Cpu4 : 0.0 us, 0.0 sy, 0.0 ni,100.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st %Cpu5 : 0.0 us, 0.0 sy, 0.0 ni,100.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st %Cpu6 : 0.0 us, 0.0 sy, 0.0 ni,100.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st %Cpu7 : 0.0 us, 0.0 sy, 0.0 ni,100.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st KiB Mem : 16266780 total, 7566888 free, 1105816 used, 7594076 buff/cache KiB Swap: 0 total, 0 free, 0 used. 14390072 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 23294 root 20 0 113176 1192 1008 R 100.0 0.0 0:23.15 a.sh 可以看到进程已经占满了一个 CPU。进程的状态栏中 PR 就是进程的优先级， NI 就是 nice 值。\n重新设置优先级，先把进程退出，然后使用 nice 命令设置：\n[root@pooky ~]# nice -n 10 ./a.sh 23780 # 打开新的终端 [root@pooky ~]# top -p 23780 top - 07:58:04 up 62 days, 21:37, 4 users, load average: 0.45, 0.47, 0.25 Tasks: 1 total, 1 running, 0 sleeping, 0 stopped, 0 zombie %Cpu(s): 0.2 us, 0.1 sy, 12.5 ni, 87.2 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st KiB Mem : 16266780 total, 7567992 free, 1104504 used, 7594284 buff/cache KiB Swap: 0 total, 0 free, 0 used. 14391492 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 23780 root 30 10 113176 1188 1004 R 92.4 0.0 0:11.20 a.sh 如果要对已经运行的进程，不想停掉进程，来设置 nice 值，可以使用 renice：\n[root@pooky ~]# renice -n 15 23780 24155 (process ID) old priority 10, new priority 15 # 打开新的终端 [root@pooky ~]# top -p 23780 jobs # 加上 \u0026amp; 可以使进程后台运行，要把后台运行的进程掉回前台，使用 jobs 命令：\n[root@pooky ~]# ./a.sh \u0026amp; [1] 24397 [root@pooky ~]# jobs [1]+ Running ./a.sh \u0026amp; [root@pooky ~]# fg 1 ./a.sh 运行 fg \u0026lt;job 号\u0026gt; 将进程调回前台。\n前台进程调到后台 # [root@pooky ~]# ./a.sh 24682 ^Z [1]+ Stopped ./a.sh [root@pooky ~]# top -p 24682 top - 08:12:06 up 62 days, 21:51, 5 users, load average: 0.07, 0.50, 0.45 Tasks: 1 total, 0 running, 0 sleeping, 1 stopped, 0 zombie %Cpu(s): 0.8 us, 0.8 sy, 0.0 ni, 98.4 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st KiB Mem : 16266780 total, 7564728 free, 1107784 used, 7594268 buff/cache KiB Swap: 0 total, 0 free, 0 used. 14388276 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 24682 root 20 0 113176 1188 1008 T 0.0 0.0 0:01.81 a.sh ctrl + z 可以将前台进程调度到后台，但是状态是停止的。状态栏 S 的值是 T 就表示已停止。\n要想恢复继续到前台就使用 jobs 加 fg。如果想要恢复到后台运行使用 bd \u0026lt;job 号\u0026gt;。\nkill # kill -l 可以查看所有信号：\n[root@pooky ~]# kill -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1 11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM 16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP 21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ 26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR 31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+3 38) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+8 43) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-7 58) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-2 63) SIGRTMAX-1 64) SIGRTMAX 一共有 64 个信号。常用的 ctrl + c 就是 SIGINT 信号。\nkill -\u0026lt;信号的编号\u0026gt; \u0026lt;进程号\u0026gt; 比如 kill -9 28317 杀死 28317 进程，不受任何阻断。注意 1 号进程是杀不掉的。\n守护进程 # 使用 nohup （no hang up）和 \u0026amp; （表示后台运行） 运行命令，nohup 命令会忽略 hangup 信号。 守护（daemon）进程，如 linux 的 service。 nohup # 当我们在终端运行一个进程时，如果终端关闭，那么进程也会被杀死，如果不想进程被杀死，可以使用 nohup 命令：\n[root@pooky ~]# nohup tail -f /var/log/messages \u0026amp; [1] 11725 nohup: ignoring input and appending output to ‘nohup.out’ nohup 即使关掉终端，进程依然运行。\u0026amp; 是后台运行。命令的输出会输出到 nohup.out。\n执行 ps -ef | grep tail 查看进程：\n[root@pooky ~]# ps -ef | grep tail root 11725 10056 0 21:06 pts/1 00:00:00 tail -f /var/log/messages root 11840 10056 0 21:08 pts/1 00:00:00 grep --color=auto tail 关闭终端，再次查看：\n[root@pooky 1320]# ps -ef | grep tail root 11725 1 0 21:06 ? 00:00:00 tail -f /var/log/messages root 11911 11454 0 21:09 pts/2 00:00:00 grep --color=auto tail 11725 进程还在，但是父进程变成了 1。因为 11725 的父进程终端被关掉了，11725 就变成了孤儿进程，孤儿进程会被 1 号进程（systemd）收留。 daemon 进程其实也是类似的原理，自动结束了父进程，被 1 号进程收留。\n进程的信息会输出到 /proc/ 目录下：\n[root@pooky 1320]# cd /proc/11725 [root@pooky 11725]# ll cwd lrwxrwxrwx. 1 root root 0 Aug 24 21:13 cwd -\u0026gt; /root [root@pooky 11725]# ll fd total 0 l-wx------. 1 root root 64 Aug 24 21:13 0 -\u0026gt; /dev/null l-wx------. 1 root root 64 Aug 24 21:13 1 -\u0026gt; /root/nohup.out l-wx------. 1 root root 64 Aug 24 21:08 2 -\u0026gt; /root/nohup.out lr-x------. 1 root root 64 Aug 24 21:13 3 -\u0026gt; /var/log/messages lr-x------. 1 root root 64 Aug 24 21:13 4 -\u0026gt; anon_inode:inotify ll cwd 可以看出 tail 命令实在 /root 下执行的，那么 /root 目录就不能被卸载，因为 tail 命令正在使用这个目录。\nfd 文件下，可以查看进程的输入输出。0，1，2 分别是标准输入，标准输出，标准错误输出。0 -\u0026gt; /dev/null 表示标准输入被关掉。\ndaemon # daemon 不需要终端，比如 service。这种进程因为没有终端输出，所以需要日志文件来记录。\n[root@pooky ~]# ps -ef | grep sshd root 1320 1 0 Jun22 ? 00:00:02 /usr/sbin/sshd -D root 6333 1320 0 10:33 ? 00:00:01 sshd: root@pts/0 root 10044 1320 0 20:40 ? 00:00:00 sshd: root@pts/1 root 11442 1320 6 21:02 ? 00:00:00 sshd: root@pts/2 root 11514 11454 0 21:03 pts/2 00:00:00 grep --color=auto sshd [root@pooky ~]# cd /proc/1320 [root@pooky 1320]# ll cwd lrwxrwxrwx. 1 root root 0 Aug 24 21:03 cwd -\u0026gt; / [root@pooky 1320]# ll fd total 0 lr-x------. 1 root root 64 Jun 22 10:21 0 -\u0026gt; /dev/null lrwx------. 1 root root 64 Jun 22 10:21 1 -\u0026gt; socket:[21458] lrwx------. 1 root root 64 Jun 22 10:21 2 -\u0026gt; socket:[21458] lrwx------. 1 root root 64 Jun 22 10:21 3 -\u0026gt; socket:[27755] lrwx------. 1 root root 64 Jun 22 10:21 4 -\u0026gt; socket:[27757] 标准输出指向了 socket。\nscreen # 有些时候在终端跑一些运行时间很长的任务，终端可能因为一些原因断开。screen 的功能，会话恢复，多窗口，会话共享。\n只要 screen 本身没有终止，在其内部运行的会话都可以恢复。这一点对于远程登录的用户特别有用，即使网络连接中断，用户也不会失去对已经打开的命令行会话的控制。 只要再次登录到主机上执行 screen -r 就可以恢复会话的运行。\n执行 screen 命令进入 screen 环境。 ctrl+a 再按 d 退出 screen 环境。 screen -ls 查看 screen 的 session。 screen -r \u0026lt;sessionId\u0026gt; 恢复指定 session。 系统日志 # 系统日志一般在 /var/log 目录下。一些重要的日志：\nmessages：是系统的常规日志。 dmesg：系统内核的启动日志。 secure：系统的安全日志。 cron：系统的计划任务日志。 "},{"id":9,"href":"/os-learn/docs/commands/10_systemd/","title":"systemctl","section":"Linux 常用命令","content":" systemctl # systemctl 是 Linux 的服务管理工具，在 CentOS 6 以前使用的是 service 这个管理工具。\nservice 的配置文件在 /etc/init.d。\n/usr/lib/systemd/ststem\nsystemctl start|stop|restart|status|reload|enable|disable \u0026lt;service name\u0026gt;\n"},{"id":10,"href":"/os-learn/docs/commands/11_selinux/","title":"SELinux","section":"Linux 常用命令","content":" SELinux # 安全增强型 Linux（Security-Enhanced Linux）简称 SELinux，它是一个 Linux 内核模块，也是 Linux 的一个安全子系统。\n没有使用 SELinux 的 Linux 是通过用户的权限和文件权限来做安全控制，这叫做 DAC（自主访问控制）。最致命问题是，root 用户不受任何管制，系统上任何资源都可以无限制地访问。\n使用了 SELinux 的 Linux 中，会给用户，文件，进程都打上一个标签。一个资源是否能被访问，要用户，文件和进程的标签一致，并且类型一致，才被允许访问。这叫做 MAC（强制访问控制）。\nSELinux 保证了安全，但是会降低机器性能，因为处理文件的时候要额外处理 SELinux 的权限，一般生产环境下 SELinux 是关闭的。\n查看 SELinux # getenforce 查看 SELinux 的模式 /usr/sbin/sestatus [root@pooky ~]# getenforce Permissive [root@pooky ~]# /usr/sbin/sestatus SELinux status: enabled SELinuxfs mount: /sys/fs/selinux SELinux root directory: /etc/selinux Loaded policy name: targeted Current mode: permissive Mode from config file: permissive Policy MLS status: enabled Policy deny_unknown status: allowed Max kernel policy version: 31 SELinux 会有三种模式：\nenforcing：强制模式。违反 SELinux 规则的行为将被阻止并记录到日志中。 permissive：宽容模式。违反 SELinux 规则的行为只会记录到日志中。一般为调试用。 disabled：关闭 SELinux。 可以在配置文件 /etc/selinux/config 中配置 SELINUX 的字段。\n# This file controls the state of SELinux on the system. # SELINUX= can take one of these three values: # enforcing - SELinux security policy is enforced. # permissive - SELinux prints warnings instead of enforcing. # disabled - No SELinux policy is loaded. SELINUX=permissive # SELINUXTYPE= can take one of three two values: # targeted - Targeted processes are protected, # minimum - Modification of targeted policy. Only selected processes are protected. # mls - Multi Level Security protection. SELINUXTYPE=targeted SELINUXTYPE 是 SELinux 的策略类型。有三种策略，分别是：\ntargeted：对大部分网络服务进程进行管制。系统默认。 minimum：以 targeted 为基础，仅对选定的网络服务进程进行管制。一般不用。 mls：多级安全保护。对所有的进程进行管制。这是最严格的策略，配置难度非常大。一般不用。 在配置文件中修改模式需要重启系统。\n查看 SELinux 的标签 # ps -Z 查看进程的标签 ls -Z 查看文件或目录的标签 id -Z 查看用户的标签 [root@pooky ~]# ps -Z LABEL PID TTY TIME CMD unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 29783 pts/3 00:00:00 bash unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 30279 pts/3 00:00:00 ps [root@pooky ~]# id -Z unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 [root@pooky ~]# ls -Z -rw-------. root root system_u:object_r:admin_home_t:s0 anaconda-ks.cfg -rw-r--r--. root root unconfined_u:object_r:admin_home_t:s0 app.js -rwxr--r--. root root unconfined_u:object_r:admin_home_t:s0 a.sh drwxr-xr-x. root root unconfined_u:object_r:admin_home_t:s0 cdf drwxr-xr-x. root root unconfined_u:object_r:admin_home_t:s0 cdf-components drwxr-xr-x. root root unconfined_u:object_r:admin_home_t:s0 certificate-controller drwxr-xr-x. root root unconfined_u:object_r:admin_home_t:s0 chatops-docker drwxr-xr-x. root root unconfined_u:object_r:admin_home_t:s0 Desktop drwxr-xr-x. root root unconfined_u:object_r:admin_home_t:s0 Documents drwxr-xr-x. root root unconfined_u:object_r:admin_home_t:s0 Downloads -rw-r--r--. root root unconfined_u:object_r:admin_home_t:s0 go1.13.3.linux-amd64.tar.gz drwxr-xr-x. root root unconfined_u:object_r:admin_home_t:s0 go-fips -rw-------. root root unconfined_u:object_r:admin_home_t:s0 go-fips.tar drwxr-xr-x. root root unconfined_u:object_r:admin_home_t:s0 golang admin_home_t 就表示只有管理员访问 home 目录是才能访问。\n关闭 SELinux # setenforce 0 可以临时的设置 SELinux 的模式为 enforcing，重启之后就恢复了。 /etc/selinux/sysconfig "},{"id":11,"href":"/os-learn/docs/commands/12_mem_disk/","title":"内存和磁盘","section":"Linux 常用命令","content":" 内存和磁盘 # 查看内存和磁盘的使用率 # 查看内存的使用率 # free top [root@pooky ~]# free total used free shared buff/cache available Mem: 16266780 1091532 7315128 157456 7860120 14383564 Swap: 0 0 0 [root@pooky ~]# free -m total used free shared buff/cache available Mem: 15885 1065 7144 153 7675 14046 Swap: 0 0 0 [root@pooky ~]# free -g total used free shared buff/cache available Mem: 15 1 6 0 7 13 Swap: 0 0 0 -m 和 -g 分别是指以 MB 和 GB 为单位显示。buff/cache 是进程使用的缓存。available 是释放掉 cache 后的可用内存。\nSwap 是交换分区，在内存不够用时，系统会自动把一部分暂时不用的内存移动到 swap 中。swap 交换分区使用的是磁盘。进程应该尽量不实用 swap，因为硬盘的读取是非常慢的。\n交换分区在 windows 中叫做虚拟内存。\n查看磁盘的使用率 # fdisk 查看磁盘，磁盘分区。（parted -l 和 fdisk -l 类似） df du fdisk # [root@pooky ~]# fdisk -l # 查看磁盘 Disk /dev/sda: 214.7 GB, 214748364800 bytes, 419430400 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk label type: dos Disk identifier: 0x00078ef0 Device Boot Start End Blocks Id System /dev/sda1 * 2048 4147199 2072576 83 Linux /dev/sda2 4147200 125788159 60820480 8e Linux LVM /dev/sda3 125788160 419430399 146821120 83 Linux Disk /dev/mapper/rhel-root: 205.1 GB, 205084688384 bytes, 400556032 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk /dev/mapper/rhel-swap: 6442 MB, 6442450944 bytes, 12582912 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk /dev/loop0: 107.4 GB, 107374182400 bytes, 209715200 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk /dev/loop1: 2147 MB, 2147483648 bytes, 4194304 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk /dev/mapper/docker-253:0-201326881-pool: 107.4 GB, 107374182400 bytes, 209715200 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 65536 bytes / 65536 bytes 可以看到磁盘文件 /dev/sda，虚拟机一般都是 sd 开头。\n419430400 sectors 表示磁盘 /dev/sda 可以分为多少个扇区。Units = sectors of 1 * 512 = 512 bytes 表示一个扇区的大小是 512 字节。\nDevice Boot Start End Blocks Id System /dev/sda1 * 2048 4147199 2072576 83 Linux 表示 /dev/sda1 这个分区的大小是从第 2048 个扇区到第 4147199 扇区。Boot 为 * 表示当前的系统是在 /dev/sda1 这个分区启动的。\n[root@pooky ~]# ls -l /dev/sd? brw-rw----. 1 root disk 8, 0 Jun 22 10:20 /dev/sda [root@pooky ~]# ls -l /dev/sd?? brw-rw----. 1 root disk 8, 1 Jun 22 10:20 /dev/sda1 brw-rw----. 1 root disk 8, 2 Jun 22 10:20 /dev/sda2 brw-rw----. 1 root disk 8, 3 Jun 22 10:20 /dev/sda3 /dev/sda 的类型是 b 也就是块设备。 disk 8, 0 中 8 表示主设备号（表示磁盘使用的驱动程序），0 是从设备号（确定访问地址），作为参数传给驱动程序。\nsda1 sda2 sda3 是磁盘 sda 的分区。并且它们的主设备号是相同的，也就是使用同样的块设备驱动。\ndf 和 du # df 可以看做是 fdisk 的补充。fdisk 无法看到分区挂载到了那个目录下。\n[root@pooky ~]# df -h Filesystem Size Used Avail Use% Mounted on /dev/mapper/rhel-root 191G 89G 103G 47% / devtmpfs 7.8G 0 7.8G 0% /dev tmpfs 7.8G 0 7.8G 0% /dev/shm tmpfs 7.8G 154M 7.7G 2% /run tmpfs 7.8G 0 7.8G 0% /sys/fs/cgroup /dev/sda1 2.0G 170M 1.9G 9% /boot tmpfs 1.6G 12K 1.6G 1% /run/user/42 tmpfs 1.6G 0 1.6G 0% /run/user/0 查看一个文件的大小：\n[root@pooky ~]# ls -lh /etc/passwd -rw-r--r--. 1 root root 2.3K May 9 2018 /etc/passwd [root@pooky ~]# du /etc/passwd 4 /etc/passwd [root@pooky ~]# du -h 2019.02.0054.zip 1.9G 2019.02.0054.zip du 显示的实际占用的空间，默认单位是 KB。ls -l 查看的文件大小包含了部分空洞的空间。\nLinux 常见的文件系统 # ext4（CentOS 6 默认的文件系统） xfs（CentOS 7 默认的文件系统） NTFS（需要版权，额外安装软件） ext4 # 基本结构：\n超级块，记录整个文件系统的信息，包括多少个文件等等。 超级块副本，超级块的备份，用来恢复超级块。 inode，记录每一个文件，文件名称，大小，编号，权限等。 数据块 （datablock） [root@pooky ~]# ls -i 67162193 anaconda-ks.cfg 67188932 metadata.tar.gz 75649215 app.js 2773685 Music 73006266 a.sh 35743888 newui 470150081 cdf 67362934 ngrok 374494288 cdf-components 67362928 ngrok-stable-linux-amd64.zip 2974620 certificate-controller 73006211 nohup.out 134217848 chatops-docker 134385344 offline-download 101575486 Desktop 67307785 offline-download.zip 101575487 Documents 73006268 offline-download.zip.1 2773684 Downloads 34997822 Pictures 67328576 go1.13.3.linux-amd64.tar.gz 470102230 popeye 469762624 go-fips 338000301 project-layout 67184332 go-fips.tar 67308300 Public 269104077 golang 83775905 renewCert 436767572 gowork 469806872 sactive-bot 168542293 hawk-eye 373471446 sactive-web ls -i 可以查看每一个文件对应的 inode。文件的 inode 是不会记录文件名称的，文件名记录在父节点的 inode 中。文件的内容存储在 datablock 中。文件的读权限，就表示可以读取 datablock 中的内容。目录的读权限就表示读取目录下的文件的名称。\ninode 和 datablock 的结构是链表结构。inode 是头结点。\n文件操作 # touch 创建文件 touch \u0026lt;文件名\u0026gt; cp 复制文件 cp \u0026lt;src\u0026gt; \u0026lt;target\u0026gt; mv 移动文件 mv \u0026lt;src\u0026gt; \u0026lt;target\u0026gt;，如果在同一个目录中移动，那就是重命名操作，inode 并不会改变，操作非常快。如果再同一个分区移动，也会非常快，因为文件被同一个文件系统管理，只是修改 inode 的信息。 rm 删除文件，其实就是将文件名和 inode 的链接断开。这样删除会非常快，即使文件非常大。也使误删除操作，可以恢复。 ln 文件链接 修改文件 # 如果使用 vim 修改文件内容：\n[root@pooky ~]# vim test1 [root@pooky ~]# ls -li test1 67324877 -rw-r--r--. 1 root root 445 Aug 30 15:54 test1 [root@pooky ~]# vim test1 [root@pooky ~]# ls -li test1 67324882 -rw-r--r--. 1 root root 413 Aug 30 15:55 test1 inode 被改变了，67324877 变成了 67324882。vim 其实是创建了一个新的文件，使文件名指向了新的文件。\n当使用 vim 修改文件时，会创建一个 swp 文件，例如 test1.swp，真正修改的就是这个 swp 文件。这样可以保证一致性。\nln # [root@pooky ~]# ls -li test1 67324882 -rw-r--r--. 1 root root 413 Aug 30 15:55 test1 [root@pooky ~]# ln test1 test2 [root@pooky ~]# ls -li test1 test2 67324882 -rw-r--r--. 2 root root 413 Aug 30 15:55 test1 67324882 -rw-r--r--. 2 root root 413 Aug 30 15:55 test2 67324882 -rw-r--r--. 1 这里最后的 1 表示有 1 个文件名和这个 inode 建立了链接。使用 ln 是 test1 test2 建立了链接，指向了同一个 inode 67324882。删除时，只删除一个是不会丢失文件的。ln 不会占用空间，只是在父目录存储了文件名。\nln 不能跨文件系统。因为 inode 是记录在文件系统中的。\n软连接 # 也叫做符号链接。使用 ln -s 创建软连接：\n[root@pooky ~]# ln -s test1 test2 [root@pooky ~]# ls -li test1 test2 67324882 -rw-r--r--. 1 root root 413 Aug 30 15:55 test1 67324865 lrwxrwxrwx. 1 root root 5 Aug 30 16:09 test2 -\u0026gt; test1 test1 test2 的 inode 是不一样的。test2 记录了 test1 的文件路径。类型是 l。\n软连接是可以跨文件系统的，和硬链接的区别是，会创建新的文件。\nfacl # 如果要设置某个用户访问某个文件的权限，可以使用 facl。\ngetfacl，查看文件的访问控制列表 setfacl，设置文件的访问控制 [root@pooky ~]# setfacl -m u:user1:r test1 [root@pooky ~]# getfacl test1 # file: test1 # owner: root # group: root user::rw- user:user1:r-- group::r-- mask::r-- other::r-- setfacl -m u:user1:r test1 表示给 user1 用户设置 test1 文件的只读权限。如果是组，把 u: 改成 g:。r 是只读权限。rw 表示读写权限。\n-m 赋予权限 -x 收回权限，setfacl -x u:user1:r test1。 分区和挂载 # fdisk，fdisk \u0026lt;磁盘设备\u0026gt;，如 fdisk /dev/sdb。 mkfs，fdisk 创建分区之后，要使用分区，需要使用 mkfs。mkfs 支持多种文件系统，如 mkfs.xfs，mkfs.ext4，mkfs.ext3 等等。使用对应的命令来把分区做成对应的文件系统，如 mkfs.ext4 /dev/sdb1，把 /dev/sdb 磁盘下的 /dev/sdb1 分区格式化为 ext4 文件系统。 mount，类似 /dev/sdb1 的块设备文件是不能直接操作的，需要挂载到一个目录。如 mount -t ext4 /dev/sdb1 /mnt/sdb1，把 /dev/sdb1 挂载到 /mnt/sdb1。-t 参数可以省略，mount 命令会自动检测文件系统。 parted，在硬盘大于 2 TB 时使用。使用类似 fdisk。 配置文件 # 上面使用命令行分区，配置是在内存中，机器重启，就会消失。需要修改配置文件： /etc/fstab 才能固话配置。\n# /etc/fstab # Created by anaconda on Mon Mar 18 17:53:42 2019 # # Accessible filesystems, by reference, are maintained under \u0026#39;/dev/disk\u0026#39; # See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info # /dev/mapper/centos7-root / xfs defaults 0 0 UUID=eba30a1f-8f8b-42ee-85b3-7b17dac16e93 /boot xfs defaults 0 0 #UUID=f8332d90-061a-44c4-897c-acd5a16da7e5 swap swap defaults 0 0 # 示例 # 要挂载的设备 要挂载的目录 文件系统 权限 /dev/sdb1 /mnt/sdb1 ext4 defaults 0 0 用户磁盘配额 # xfs 文件系统的用户磁盘配额 quota\nmkfs.xfs /dev/sdb1 格式化分区，-f 强制格式化。 mount -o uquota,gquota /dev/sdb1 /mnt/disk1 挂载 /dev/sdb1 到 /mnt/disk1 目录。-o uquota,gquota 表示这个分区要支持用户和组磁盘配额。 chmod 1777 /mnt/disk1 xfs_quota -x -c 'report -ugibh' /mnt/disk1 查看磁盘配额，执行 report -ugibh。 xfs_quota -x -c 'limit -u isoft=5 ihard=10 user1' /mnt/disk1 限制某个用户的磁盘配额，执行 limit -u isoft=5 ihard=10 user1。 交换分区 # 交换分区是在内存不够用时，在磁盘上开辟一块空间，来扩充内存。\nmkswap，mkswap /dev/sdb2 设置 /dev/sdb2 分区为 swap 的标记。 swapon，swapon /dev/sdb2 打开 swap 分区。可以使用 free 查看 swap 空间是否增加。 swapoff，swapoff /dev/sdb2 关闭 swap 分区。 使用文件方式扩充 swap # dd if=/dev/zero bs=4M count=1024 of=/swapfile，bs=4M 表示 block size 为 4M，count=1024 表示创建 1024 个 block，of=/swapfile 设备文件为 swapfile。创建了一个大小为 1024 * 4M 的 swapfile。 mkswap /swapfile chmod 600 /swapfile swapon /swapfile 配置文件 fstab # # /etc/fstab # Created by anaconda on Mon Mar 18 17:53:42 2019 # # Accessible filesystems, by reference, are maintained under \u0026#39;/dev/disk\u0026#39; # See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info # /dev/mapper/centos7-root / xfs defaults 0 0 UUID=eba30a1f-8f8b-42ee-85b3-7b17dac16e93 /boot xfs defaults 0 0 #UUID=f8332d90-061a-44c4-897c-acd5a16da7e5 swap swap defaults 0 0 # 示例 # 要挂载的设备 要挂载的目录 文件系统 权限 /dev/sdb1 /mnt/sdb1 ext4 defaults 0 0 # 要挂载的设备 挂载的目录是虚拟的所以是swap 文件系统 权限 是否备份 是否开机自检，已经不需要 /swapfile swap swap defaults 0 0 RAID # RAID 技术就是把多块磁盘作为一个组合来使用。\nRAID 0 striping 条带方式，提高单盘的吞吐率。RAID 0 最好由相同容量的两块或两块以上的硬盘组成。如果组成 RAID 0 的两块硬盘大小不一致，则会影响 RAID 0 的性能。这种模式下会先把硬盘分隔出大小相等的区块，当有数据需要写入硬盘时，会把数据也切割成相同大小的区块，然后分别写入各块硬盘。这样就相当于把一个文件分成几个部分同时向不同的硬盘中写入，数据的读/写速度当然就会非常快。RAID 0 没有数据冗余功能，RAID 0 中的任何一块硬盘损坏，RAID 0 中所有的数据都将丟失。 RAID 1 mirroring 镜像方式，提高可靠性。由两块硬盘组成。两块硬盘的大小最好一致，否则总容量以容量小的那块硬盘为主。RAID 1 就具备了数据冗余功能，因为这种模式是把同一份数据同时写入两块硬盘。比如有两块硬盘，组成了 RAID 1，当有数据写入时，相同的数据既写入硬盘 1，也写入硬盘 2。这样相当于给数据做了备份。RAID 1 具有了数据冗余功能，但是硬盘的容量却减少了 50%，因为两块硬盘当中保存的数据是一样的。 RAID 5 有奇偶校验。最少需要由 3 块硬盘组成，当然硬盘的容量也应当一致。当组成 RAID 5 时，同样需要把硬盘分隔成大小相同的区块。当有数据写入时，数据也被划分成等大小的区块，然后循环向 RAID 5 中写入。每次循环写入数据的过程中，在其中一块硬盘中加入一个奇偶校验值（Parity），这个奇偶校验值的内容是这次循环写入时其他硬盘数据的备份。当有一块硬盘损坏时，采用这个奇偶校验值进行数据恢复。RAID 5，只支持一块硬盘损坏之后的数据恢复。 RAID 10 是 RAID 0 和 RAID 1 的结合。先用两块硬盘组成 RAID 1，再用两块硬盘组成另一个 RAID 1，最后把这两个 RAID 1组成 RAID 0，这种 RAID 方法称作 RAID 10。那先组成 RAID 0，再组成 RAID 1 的方法叫作 RAID 01。 在服务器上实现 RAID，可以采用磁盘阵列卡（RAID 卡）来组成 RAID，也就是硬 RAID。RAID 卡上有专门的芯片负责 RAID 任务，因此性能要好得多，而且不占用系统性能，缺点是 RAID 卡比较昂贵。\n软 RAID 是指通过软件实现 RAID 功能，没有多余的费用，但是会占用非常多的 CPU，而且数据的写入速度比硬 RAID 慢。\n软件 RAID 需要安装 mdadm。\n逻辑卷 # LVM （逻辑卷管理器）是 Linux 系统用于对硬盘分区进行管理的一种机制，为了解决硬盘设备在创建分区后不易修改分区大小的缺陷。传统的硬盘分区进行强制扩容或缩容从理论上讲是可行的。但是却可能造成数据的丢失。LVM 技术是在硬盘分区和文件系统之间添加了一个逻辑层，它提供了一个抽象的卷组，可以把多块硬盘进行卷组合并。\n物理卷（PV：Physical Volume）：物理卷是底层真正提供容量，存放数据的设备，它可以是整个硬盘、硬盘上的分区等。 卷组（VG：Volume Group）：卷组建立在物理卷之上，它由一个或多个物理卷组成。即把物理卷整合起来提供容量分配。一个 LVM 系统中可以只有一个卷组，也可以包含多个卷组。 逻辑卷（LV：Logical Volume）：逻辑卷建立在卷组之上，它是从卷组中“切出”的一块空间。它是最终用户使用的逻辑设备。逻辑卷创建之后，其大小可以伸缩。 基本单元（PE：Physical Extents）：具有唯一编号的PE是能被LVM寻址的最小单元。PE 的大小可以指定，默认为 4 MB。PE 的大小一旦确定将不能改变，同一个卷组中的所有的物理卷的PE的大小是一直的 "},{"id":12,"href":"/os-learn/docs/commands/13_sar/","title":"查看系统状态","section":"Linux 常用命令","content":" 查看系统状态 # sar # [root@pooky ~]# sar -u 1 10 Linux 3.10.0-862.el7.x86_64 (pooky.hpeswlab.net) 09/01/2020 _x86_64_ (8 CPU) 09:06:43 PM CPU %user %nice %system %iowait %steal %idle 09:06:44 PM all 0.13 0.00 0.13 0.00 0.00 99.75 09:06:45 PM all 0.38 0.00 0.13 0.00 0.00 99.50 09:06:46 PM all 0.25 0.00 0.37 0.00 0.00 99.38 09:06:47 PM all 0.13 0.00 0.00 0.00 0.00 99.87 09:06:48 PM all 0.12 0.00 0.25 0.00 0.00 99.62 09:06:49 PM all 0.88 0.00 0.63 0.00 0.00 98.50 09:06:50 PM all 0.25 0.00 0.13 0.00 0.00 99.62 09:06:51 PM all 0.25 0.00 0.13 0.00 0.00 99.62 09:06:52 PM all 0.13 0.00 0.00 0.00 0.00 99.87 09:06:53 PM all 0.25 0.00 0.13 0.00 0.00 99.62 Average: all 0.28 0.00 0.19 0.00 0.00 99.54 sar -u 1 10 中 -u 表示查看 cpu 状态。1 表示采样时间间隔，10 表示采样次数。 -r 查看内存。 -b 查看 IO。 -d 查看磁盘。 -q 查看进程。 iftop # iftop 可以用来监控网卡的实时流量（可以指定网段）、反向解析IP、显示端口信息等。如果服务器带宽跑满了，查看跟哪个 ip 通信占用带宽比较多，可以通过 iftop 命令进行查询。\nTX：发送流量 RX：接收流量 TOTAL：总流量 cum：运行 iftop 到目前时间的总流量 peak：流量峰值 rates：分别表示过去 2s 10s 40s 的平均流量 常用参数：\n-i 指定网卡，默认是 eth0，iftop -i eth1 -B 以字节为单位，默认是 bit -n 显示 IP -N 显示端口 -F 显示指定网段的进出流量，iftop -F 10.10.1.0/24，iftop -F 10.10.1.0/255.255.255.0 -p 使用这个参数后，中间的列表显示的本地主机信息，出现了本机以外的IP信息; -b 使流量图形条默认就显示; -P 默认显示 host 和端口信息，iftop -P -m 设置界面最上边的刻度的最大值，刻度分五个大段显示，iftop -m 100M "},{"id":13,"href":"/os-learn/docs/commands/14_shell/","title":"Shell","section":"Linux 常用命令","content":" Shell # shell 是 Linux 的命令解释器，解释用户对操作系统的操作。CentOS 默认使用的 shell 是 bash。例如，执行 ls 命令时，会先被 shell 对命令和参数进行解释，再交给内核执行。\n/bin/bash 的位置是用于配置登录后的默认交互命令行的，不像 Windows，登录进去是界面，其实就是 explorer.exe。而 Linux 登录后的交互命令行是一个解析脚本的程序，默认是 /bin/bash。\n执行命令的方式：\nbash ./test.sh 创建一个子进程来运行 test.sh ./test.sh 创建一个子进程来运行 test.sh，需要 Sha-Bang ，也就是脚本文件开头的 #!/bin/bash 来判断使用哪种 shell。 source ./test.sh 在当前进程运行 test.sh。也就是说 test.sh 里面执行的命令会影响当前 bash 进程。比如 test.sh 里面只有一行命令为 cd /var ，当前进程会切换到 /var。如果是 bash ./test.sh 当前 bash 就不会切换目录，只是在子进程切换了目录。 . test.sh . 是 source 的另一种写法。 如果希望脚本对当前运行环境产生影响，就使用 source 来执行。\nLinux 启动过程 # BIOS （基本输入输出系统）引导，在主板上执行，选择引导介质 MBR 硬盘引导 BootLoader(grub) 启动和引导 Linux 内核，确定内核版本 kernel systemd 系统初始化 shell 管道 # 管道是进程间通信的一种方式。| 管道符，可以将前一个命令的结果传递给后面的命令。\n[root@pooky ~]# cat | ps -f UID PID PPID C STIME TTY TIME CMD root 22804 22792 7 21:52 pts/4 00:00:00 -bash root 22848 22804 0 21:53 pts/4 00:00:00 cat root 22849 22804 0 21:53 pts/4 00:00:00 ps -f 管道符会给前后两个命令分别创建子进程，上面的示例 22848 进程对应 cat，22849 进程对应 ps -f。管道符会把第一个进程的输出和第二个进程的输入建立连接。\n打开另一个终端查看进程信息：\n[root@pooky ~]# cd /proc/22848 [root@pooky 22848]# cd fd [root@pooky fd]# ls -l total 0 lrwx------. 1 root root 64 Sep 2 21:54 0 -\u0026gt; /dev/pts/4 # stdin pts 表示图形终端 l-wx------. 1 root root 64 Sep 2 21:54 1 -\u0026gt; pipe:[14225010] # stdout pipe 表示管道 lrwx------. 1 root root 64 Sep 2 21:53 2 -\u0026gt; /dev/pts/4 如果第二个进程是一个长时间运行的命令，那么对应的 fd 目录下的 0 ，也就是 stdin，也会指向 pipe:[14225010]。\n注意，管道符会创建子进程来执行命令，也就是说，如果在管道符前后执行 cd 某个目录，父进程是不会切换目录的。\n重定向 # 一个进程运行时，会默认打开标准输入（一般是通过键盘，终端进行输入），标准输出，标准错误输出（默认输出到终端）三个文件描述符。 重定向符号其实是把输入和输出和文件建立连接。用文件来代替输入或输出。 输入重定向 # \u0026lt;，wc -l | /etc/passwd 统计 /etc/passwd 内容的行数。 [root@pooky ~]# read var2 \u0026lt; a.txt [root@pooky ~]# echo $var2 将 a.txt 内容读入到变量 var2。\n输出重定向 # \u0026gt;，将输出到文件前会先清空文件内容。echo 123 \u0026gt; /path/to/a/file。 \u0026gt;\u0026gt;，将输出追加到文件。 2\u0026gt;，错误重定向，将错误输出到指定文件。 \u0026amp;\u0026gt;，标准输出和错误输出到指定文件。 2\u0026gt;\u0026amp;1，把 标准错误输出 重定向到 标准输出，ls a.txt b.txt 1\u0026gt;file.out 2\u0026gt;\u0026amp;1 的正确输出和错误输出都重定向到了 file.out 文件中。 1\u0026gt;\u0026amp;2，把 标准输出 重定向到 标准错误输出 变量 # 变量赋值：\na=123，= 左右不能有空格。 let a=10+20，变量可以进行计算。 r=$(ls -l /etc)，$() 可以得到命令结果。` ` 反引号也可以得到命令结果。 如果变量值有空格或者特殊字符，可以包含在 \u0026quot;\u0026quot; 或者 '' 中。 默认值，test2=${2-_}，- 好表示当 $2 为空值时，使用 _ 为值。\n变量引用：\n${变量名}，有些情况下也可以使用 $变量名。 变量作用范围：\n变量的默认作用范围是当前 shell 进程。 [root@pooky ~]# a=1 [root@pooky ~]# bash # 进入一个新的 shell 子进程 [root@pooky ~]# echo $a # a 变量的值是空的 [root@pooky ~]# a=2 [root@pooky ~]# exit exit [root@pooky ~]# echo $a # a 变量的值不会被子进程的赋值改变 1 [root@pooky ~]# bash test.sh # bash 打开了一个新的 shell 进程，在 test.sh 中的变量不会作用到父进程 [root@pooky ~]# source test.sh # 可以使用 source 命令，在当前进程执行 test.sh，使变量在父进程生效 export 导出变量，export 设置环境变量是暂时的，可以被子进程读取到，比如在一个终端 export 的变量，在这个终端打开的 shell 子进程都可以读取到这个变量。 unset 删除变量，unsert a 环境变量 # 环境变量，是每个 shell 都可以读取到的变量：\nenv 查看所有环境变量，env | more。 set 也可以查看环境变量。 -e 传回值不等于 0，则立即退出 shell。 -u 执行脚本的时候，如果遇到不存在的变量，Bash 默认忽略它。 -x 默认情况下，脚本执行后，只显示运行结果，这个参数可以显示执行的指令及参数。 -o pipefail -e 参数不适用于管道命令。只要管道符最后一个子命令不失败，管道命令总是会执行成功如 foo 是一个不存在的命令，但是 foo | echo $a 这个管道命令会执行成功。-o pipefail 用来解决这种情况，只要一个子命令失败，整个管道命令就失败，脚本就会终止执行。 $? 上条命令的返回值，不为 0，表示执行失败。 $$ 表示当前进程 PID $0 当前进程的名称 $PATH 命令路径 $PS1 [root@pooky ~]# echo $? 0 [root@pooky ~]# echo $$ 32163 [root@pooky ~]# echo $0 -bash 位置变量：\n$1 $2 \u0026hellip; $n 分别表示第一个参数，第二个，到第 n 个参数。注意第十个参数，要用 ${10}，否则 $ 会默认和 1 结合。 test.sh：\n#!/bin/bash echo \u0026#34;文件名：$0\u0026#34;; echo \u0026#34;第一个参数为：$1\u0026#34;; echo \u0026#34;第二个参数为：$2\u0026#34;; echo \u0026#34;第三个参数为：$3\u0026#34;; [root@pooky ~]# ./test.sh 1 2 3 文件名：./test.sh 第一个参数为：1 第二个参数为：2 第三个参数为：3 环境变量配置文件 # /etc/profile /etc/profile.d ~/.bash_profile ~/.bashrc /etc/bashrc 执行顺序从上到下。\n/etc 目录下的文件对系统中所有用户都永久有效。~ 目录下的文件只对某个用户永久有效。\n配置文件分为 bashrc 和 profile 两种，因为登录用户分为两种，login shell 和 no login shell。比如 su - user1 切换了用户和 home 目录，这属于 login shell。login shell 会执行上面所有的配置文件。如果使用 su user1 ，那么只会执行两个 bashrc 文件。\n修改可上面的配置文件可以使用 source \u0026lt;filename\u0026gt; 使其立即生效。\n数组 # 定义数组 IPS=( 10.0.0.1 10.0.0.2 10.0.0.3)。\n[root@pooky ~]# IPS=( 10.0.0.1 10.0.0.2 10.0.0.3) [root@pooky ~]# echo ${IPS[0]} # 显示执行下标的元素 10.0.0.1 [root@pooky ~]# echo ${IPS[1]} 10.0.0.2 [root@pooky ~]# echo ${IPS[2]} 10.0.0.3 [root@pooky ~]# echo ${IPS} # 显示的是数据第一个元素 10.0.0.3 [root@pooky ~]# echo ${IPS[@]} # 显示数组所有元素 10.0.0.1 10.0.0.2 10.0.0.3 [root@pooky ~]# echo ${#IPS[@]} # 显示数据长度 3 转义和引用 # 特殊字符：\n# 注释 ; 分号 \\ 转义符 \\n \\r \\t 字母转义 \\$ \\\u0026quot; \\\\ 非字母转义 \u0026quot; ' 引号 引用：\n双引号，不完全引用，中间的内容会进行解释。 单引号，完全引用，单引号中间是什么就显示什么，不进行解释。 反引号，可以得到命令结果。和 $() 的功能一样。 [root@pooky ~]# var1=123 [root@pooky ~]# echo \u0026#34;$var1\u0026#34; 123 [root@pooky ~]# echo \u0026#39;$var1\u0026#39; $var1 运算符 # expr 可以用来计算 expr 4 + 5 ，但是只支持整数。 正常的变量赋值，= 右边都被当做字符串，如果右边需要计算可以使用 let，(()) 是 let 的简化。 [root@pooky ~]# ((a=4+5)) [root@pooky ~]# echo $a 9 [root@pooky ~]# b=4+5 [root@pooky ~]# echo $b 4+5 [root@pooky ~]# ((a++)) [root@pooky ~]# echo $a 10 特殊符号 # 引号 \u0026quot;\u0026quot; '' `` 括号 () 打开一个子进程，或者数组定义 $() (()) 执行算数运算 [] [[]] 测试，获取数组下标元素 [ 5 -gt 4 ]，[[]] 就可以使用比较运算符 [[ 5 \u0026gt; 4 ]] \u0026lt;\u0026gt; 输入输出重定向 {} 输出范围 echo {0..9}，会输出 0 1 2 3 4 5 6 7 8 9 运算和逻辑符号 + - * / % \u0026lt; \u0026gt; = \u0026amp;\u0026amp; || ! 转义符号 \\ 其他符号 # 注释 ; 命令分隔符，;; case 语句的分隔符要转义 : 空指令 . 和 source 命令相同 ~ home 目录 , 分隔目录 - 回到上次访问的目录，cd - * 通配符，匹配 0 或多个字符 ? 条件测试，通配符 匹配任意一个字符 $ 取值符号 | 管道 \u0026amp; 后台运行 _ 空格 判断 # $? 得到命令的执行结果，判断是否为 0，非 0 为不正常退出。使用 exit 来退出程序。exit 会返回出错命令的错误码，也可以自定义错误码 exit \u0026lt;code\u0026gt;。 test 命令检查文件或者比较值。测试语句可以简化为 []。[] 的扩展写法 [[]] 支持 \u0026amp;\u0026amp; || \u0026lt; \u0026gt;。test \u0026lt;表达式\u0026gt; 简化为 [ 表达式 ]。常用的测试： 字符串测试 [ str1 = str2 ] [ str1 != str2 ] [ -z str ] -z 表示字符串长度是否为 0 整数测试 [ int1 -eq int2 ] -eq 表示等于，-ge 大于等于，gt 大于，le 小于等于，lt 小于，-ne 不等于。[] 做整数判断时，只能使用 -eq 这种形式。想要使用逻辑运算符 \u0026lt; 等，要使用 [[]]。 文件测试，[ -e file] -e 文件是否存在，-d 文件存在并且是目录，-f 文件存在并且是普通文件，-b 文件存在并且是块文件，-c 文件存在并且是字符设备文件，-x 文件存在并且可执行。 [root@pooky ~]# test -f /etc/passwd [root@pooky ~]# echo $? 0 [root@pooky ~]# test -f /etc/passwd2 [root@pooky ~]# echo $? 1 [root@pooky ~]# [ -d /etc/ ] [root@pooky ~]# echo $? 0 [root@pooky ~]# [ -e /etc/ ] [root@pooky ~]# echo $? 0 [root@pooky ~]# [ 5 -gt 4 ] [root@pooky ~]# echo $? 0 [root@pooky ~]# [[ 5 -gt 4 ]] [root@pooky ~]# echo $? 0 [root@pooky ~]# [ \u0026#34;aaa\u0026#34; = \u0026#34;aaa\u0026#34; ] [root@pooky ~]# echo $? 0 if # if-then 语句：\nif [ 测试条件成立或执行命令返回值为 0 ] then 执行对应的命令 fi 结束 if [ $(ps -ef | grep -c \u0026#34;ssh\u0026#34;) -gt 1 ]; then echo \u0026#34;true\u0026#34;; fi if-else 语句：\nif [ 测试条件成立 ] then 执行对应的命令 else 测试条件不成立，执行对应的命令 fi 结束 if [ $(ps -ef | grep -c \u0026#34;ssh\u0026#34;) -gt 1 ]; then echo \u0026#34;true\u0026#34;; else echo \u0026#34;false\u0026#34; fi if-elif-else 语句：\nif [ 测试条件成立 ] then 执行对应的命令 elif [ 测试条件成立 ] then 执行对应的命令 else 测试条件不成立，执行对应的命令 fi 结束 a=10 b=20 if [ $a == $b ]; then echo \u0026#34;a 等于 b\u0026#34; elif [ $a -gt $b ]; then echo \u0026#34;a 大于 b\u0026#34; elif [ $a -lt $b ]; then echo \u0026#34;a 小于 b\u0026#34; else echo \u0026#34;没有符合的条件\u0026#34; fi 嵌套 if 语句：\nif [ 测试条件成立 ] then 执行对应的命令 if [ 测试条件成立 ] then 执行对应的命令 fi fi 结束 a=10 b=20 c=30 if [ $a == $b ]; then echo \u0026#34;a = b\u0026#34; if [ $a = $c ]; then echo \u0026#34;a = c\u0026#34; fi fi 分支 # case \u0026#34;$变量\u0026#34; in \u0026#34;var1\u0026#34; ) echo \u0026#34;var1\u0026#34; ;; \u0026#34;var2\u0026#34; ) echo \u0026#34;var2\u0026#34; ;; \u0026#34;var3\u0026#34;|\u0026#34;var4\u0026#34; ) echo \u0026#34;var3|var4\u0026#34; ;; * ) # 匹配其他情况 echo \u0026#34;*\u0026#34; ;; esac 循环 # for # for 参数 in 列表 do 执行对应的命令 done 封闭一个循环 使用 {} 得到列表：\nfor i in {1..9} do echo $i done # or for i in {1..9}; do echo $i; done # or for loop in 1 2 3 4 5 do echo \u0026#34;The value is: $loop\u0026#34; done 使用命令得到列表，如把当前目录后缀为 txt 的文件改为后缀为 text：\nfor filename in `ls *.txt` do mv $filename $(basename $filename .txt).text done basename 命令可以得到文件名，不包含后缀名。\nC 风格的 for 循环：\nfor((i = 1; i \u0026lt;= 5; i++)) do echo \u0026#34;$i\u0026#34; done while # while test测试是否成了 do 执行对应的命令 done int=1 while (( $int\u0026lt;=5 )) do echo $int let \u0026#34;int++\u0026#34; done # or a=50 while [ \u0026#34;$a\u0026#34; -le 100 ] do echo $a ((a++)) done # 死循环 while : do echo \u0026#34;.\u0026#34; done until # 和 while 相反，循环条件为 false 时执行，为 true 时停止。\na=0 until [ ! $a -lt 10 ] do echo $a a=`expr $a + 1` done 嵌套循环 # break 和 continue 语句：\nfor filename in /etc/profile.d/*.sh do echo $filename if [ -x $filename ]; then . $filename fi done # or for num in {1..9} do if [ $num -eq 5 ]; then break # 退出循环 # continue 跳过当前循环 echo $num fi done 使用循环处理命令行参数 # 命令行参数可以使用 $1 $2 .. $n 来获取。 $0 表示当前脚本名称 $* 和 $@ 代表所有位置参数。只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 \u0026quot; * \u0026quot; 等价于 \u0026ldquo;1 2 3\u0026rdquo;（传递了一个参数），而 \u0026ldquo;@\u0026rdquo; 等价于 \u0026ldquo;1\u0026rdquo; \u0026ldquo;2\u0026rdquo; \u0026ldquo;3\u0026rdquo;（传递了三个参数）。 $# 传递到脚本的参数个数 for pos in $* do if [ $pos = help ];then fi done # or while [ $# -ge 1 ]; do echo $# echo \u0026#34;do something\u0026#34; shift # 删除第一个参数 done 函数 # 定义函数：\nfunction funcname() { echo \u0026#34;do something\u0026#34; echo $1 echo $2 echo ${10} return 0 } 执行函数：funcname。 函数作用范围的变量：local 变量名 函数的参数：$1 $2 .. $n 返回值：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return 后跟数值 n (0-255)\n函数库 # 系统函数库：/etc/init.d/functions\n导入系统函数库，执行函数 echo_success：\n[root@pooky init.d]# source /etc/init.d/functions [root@pooky init.d]# echo_success [root@pooky init.d]# [ OK ] 自定义函数库：使用 source 导入脚本中的函数\n"},{"id":14,"href":"/os-learn/docs/commands/15_script_priority/","title":"脚本控制","section":"Linux 常用命令","content":" 脚本控制 # 脚本控制一般分为两种：\n脚本的优先级控制 通过信号控制 脚本优先级控制 # nice 和 renice 可以调整脚本的优先级，调整资源的占用，如 CPU。 避免不可控的死循环 死循环会导致 CPU 占用过高 死循环会导致死机，创建大量的子进程，叫做 fock 炸弹。如 .(){.|.\u0026amp;};.，可以当做 func(){func|func \u0026amp;}; func。 ulimit -a 可以查看当前的终端的系统限制：\n[root@pooky ~]# ulimit -a core file size (blocks, -c) 0 data seg size (kbytes, -d) unlimited scheduling priority (-e) 0 file size (blocks, -f) unlimited pending signals (-i) 63408 max locked memory (kbytes, -l) 64 max memory size (kbytes, -m) unlimited open files (-n) 1024 pipe size (512 bytes, -p) 8 POSIX message queues (bytes, -q) 819200 real-time priority (-r) 0 stack size (kbytes, -s) 8192 cpu time (seconds, -t) unlimited max user processes (-u) 63408 # 用户的最大进程数 virtual memory (kbytes, -v) unlimited file locks (-x) unlimited 当 fock 炸弹创建大量的进程，超过 max user processes 的限制时，系统就会停止响应，因为 CPU 在不停的创建子进程。\n捕获信号 # kill 默认发送 15 号信号给进程。 ctrl + c 发送 2 号信号。 9 号信号不可阻塞，trap 是无法捕获的。 有些应用程序，不希望被 ctrl + c 或者 kill 的信号中断，就可以使用 trap 捕获信号，来屏蔽掉这些信号。\n#!/bin/bash trap \u0026#34;echo sig 15\u0026#34; 15 trap \u0026#34;echo sig 2\u0026#34; 2 # 捕获了 ctrl + c 的信号 echo $$ while : do : done 计划任务 # 一次性计划任务 # at [OPTIONS] \u0026lt;系统时间\u0026gt; 命令：\n[root@pooky tmp]# date Thu Sep 10 21:21:13 CST 2020 [root@pooky tmp]# at 21:23 at\u0026gt; echo hello \u0026gt; /tmp/hello.txt at\u0026gt; \u0026lt;EOT\u0026gt; job 2 at Thu Sep 10 21:23:00 2020 [root@pooky tmp]# atq 2 Thu Sep 10 21:23:00 2020 a root [root@pooky tmp]# cat /tmp/hello.txt hello [root@pooky tmp]# ls -l /tmp/hello.txt -rw-r--r--. 1 root root 6 Sep 10 21:23 /tmp/hello.txt at 命令执行计划任务之后，可以使用 ctrl + d 退出。 atq 命令可以查看还没有执行的一次性计划任务。\n选项：\n-m：当 at 的工作完成后，即使没有输出讯息，亦以 email 通知使用者该工作已完成。 -l：at -l 相当于 atq，列出目前系统上面的所有该使用者的 at job。 -d：at -d 相当于 atrm ，可以取消一个在 at job； -v：可以使用较明显的时间格式列出 at job； -c：可以列出后面接的该项工作的实际指令内容。 周期性计划任务 # Linux 默认安装 crontab，用来执行周期性任务。crond 进程会定期检查是否有要执行的任务，如果有，则自动执行。\ncrontab [OPTIONS] [CMD] 命令，配置计划任务的格式，如 0 1 * * * root /user/local/run.sh，每个段分别表示：\nminute hour day month week command minute： 分钟，从 0 到59 之间的任何整数。 hour：小时，从 0 到 23 之间的任何整数。 day：日期，从 1 到 31 之间的任何整数。 month：月份，从 1 到 12 之间的任何整数。 week: 星期几，从 0 到 7 之间的任何整数，0 或 7 代表星期日。 command: 行的命令，可以是系统命令，也可以是脚本文件。要注意命令的路径，如果没有配置 PATH，需要写绝对路径。 各段中还可以使用下面的字符：\n*：代表所有可能的值，例如 month 字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。 ,：可以用逗号隔开的值指定一个列表范围，例如，1,2,5,7,8 -：可以用整数之间的中杠表示一个整数范围，如 1-5 表示 1,2,3,4,5 /：可以用正斜线指定时间的间隔频率，例如 0-23/2 表示每两小时执行一次。同时正斜线可以和星号一起使用，如 */10，如果用在 minute 字段， 表示每十分钟执行一次。 选项：\n-e：设置用户的计划任务 -l：列出用户的计划任务 -r：删除用户的计划任务 -u：指定用户名，如果不指定，默认是当前用户。 /var/spool/cron/ 会有一个与用户同名的文件。\n可以使用命令添加计划任务，也可以修改 /etc/crontab 配置文件：\nSHELL=/bin/bash PATH=/sbin:/bin:/usr/sbin:/usr/bin MAILTO=root # For details see man 4 crontabs # Example of job definition: # .---------------- minute (0 - 59) # | .------------- hour (0 - 23) # | | .---------- day of month (1 - 31) # | | | .------- month (1 - 12) OR jan,feb,mar,apr ... # | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat # | | | | | # * * * * * user-name command to be executed 示例 # * * * * * command 每分钟执行一次 command。\n10,20 * * * * command 每小时的第 10 和第 20 分钟执行一次。\n10,20 8-11 */2 * * command 每隔两天的上午 8 点到 11 点的第 10 和第 20 分钟执行。\n10 1 * * 6,0 /etc/init.d/smb restart 每周六、周日的一点十分重启 smb\n日志 # 计划任务的日志可以查看 /var/log/cron 文件：\n[root@pooky ~]# crontab -e no crontab for root - using an empty one crontab: installing new crontab [root@pooky ~]# tail -f /var/log/cron Sep 10 21:01:02 pooky run-parts(/etc/cron.hourly)[15528]: starting mcelog.cron Sep 10 21:01:02 pooky run-parts(/etc/cron.hourly)[15546]: finished mcelog.cron Sep 10 21:10:01 pooky CROND[16058]: (root) CMD (/usr/lib64/sa/sa1 1 1) Sep 10 21:20:01 pooky CROND[16707]: (root) CMD (/usr/lib64/sa/sa1 1 1) Sep 10 21:30:01 pooky CROND[17353]: (root) CMD (/usr/lib64/sa/sa1 1 1) Sep 10 21:40:01 pooky CROND[17936]: (root) CMD (/usr/lib64/sa/sa1 1 1) Sep 10 21:53:18 pooky crontab[18695]: (root) REPLACE (root) # 表示编辑了一个 job Sep 10 21:53:18 pooky crontab[18695]: (root) END EDIT (root) # 表示完成了编辑 Sep 10 21:54:02 pooky CROND[18769]: (root) CMD (ntpdate ntp.swinfra.net) 上面的示例设置了周期任务 */2 * * * * ntpdate ntp.swinfra.net 每两分钟同步一次时间。\n延时计划任务 # 在有些意外情况下，周期计划任务可能没有执行，比如机器意外关机了。这时候就需要延时计划任务，可以在开机之后再延后运行。\n/etc/cron.d/0hourly：\n# Run the hourly jobs SHELL=/bin/bash PATH=/sbin:/bin:/usr/sbin:/usr/bin MAILTO=root 01 * * * * root run-parts /etc/cron.hourly # 每一个小时的第一分钟 运行 run-parts /etc/cron.hourly run-parts 在调用 /etc/cron.hourly 之后会在某处记录一个标记，表示这一个小时已经运行过。再下次开机时会检查这个标记，如果这个小时已经运行过，就不会再运行。\ncron.hourly 对应的是每小时的延时任务，其他的任务在 /etc/anacrontab 文件中：\n# /etc/anacrontab: configuration file for anacron # See anacron(8) and anacrontab(5) for details. SHELL=/bin/sh PATH=/sbin:/bin:/usr/sbin:/usr/bin MAILTO=root # the maximal random delay added to the base delay of the jobs RANDOM_DELAY=45 # 随机在 0 到 45 之间选择延时时间 # the jobs will be started during the following hours only START_HOURS_RANGE=3-22 # 延时任务在 3 到 22 点之间运行 #period in days delay in minutes job-identifier command 1 5 cron.daily nice run-parts /etc/cron.daily # 延时 5 分钟，就是每天的 3:05 分开始执行延时任务 7 25 cron.weekly nice run-parts /etc/cron.weekly @monthly 45 cron.monthly nice run-parts /etc/cron.monthly 任务锁 # 在运行一个周期任务时，如果该任务执行时间较长，导致下一个周期开始，这样再执行任务就可能冲突。这时候可以使用任务锁来避免这种问题。\nflock -x 来运行，会加上一个排它锁：\n[root@pooky ~]# flock -xn \u0026#34;/tmp/f.lock\u0026#34; -c \u0026#34;/root/test.sh\u0026#34; \u0026ldquo;/tmp/f.lock\u0026rdquo; 就是锁文件。\n选项：\n-s 获得一个共享锁 -x 获得一个独占锁，这是默认的 -u 删除一个锁，通常是不需要的，因为在文件关闭时锁会自动删除 -n 如果没有获得锁，直接失败而不是等待 -w 如果没有获得锁，等待指定时间 -o 在执行命令之前关闭保持锁的文件描述符 -c 运行一个命令 "},{"id":15,"href":"/os-learn/docs/commands/16_text_operation/","title":"操作文本","section":"Linux 常用命令","content":" 操作文本 # 文本搜索一般会使用正则表达式。\n元字符 # 常用的元字符：\n. 匹配除了换行符外的任意一个字符 * 匹配任意个跟它前面的字符 [] 匹配方括号中的字符类中的任意一个，比如 [Hh]ello 就可以匹配 hello 和 Hello。 ^ 匹配开头 $ 匹配结尾 \\ 转义字符 扩展元字符：\n+ 匹配前面的正则表达式至少出现一次 ? 匹配前面的正则表达式出现一次或者零次 | 匹配前面或者后面的正则表达式 grep # grep 用来查找文件里符合条件的字符串。 grep 会把符合条件的行显示出来。\n[root@pooky init.d]# grep password /root/anaconda-ks.cfg # Root password [root@pooky init.d]# grep -i password /root/anaconda-ks.cfg -i 忽略大小写 # Root password [root@pooky ~]# grep pass.... /root/anaconda-ks.cfg # 可以使用元字符 . 匹配任意一个字符 auth --enableshadow --passalgo=sha512 # Root password [root@pooky ~]# grep pass....$ /root/anaconda-ks.cfg # $ 表示结尾 auth --enableshadow --passalgo=sha512 # Root password [root@pooky ~]# grep pass...d$ /root/anaconda-ks.cfg # Root password [root@pooky ~]# grep pass.*$ /root/anaconda-ks.cfg # .* 就表示任意个字符 auth --enableshadow --passalgo=sha512 # Root password user --groups=wheel --name=admin --passwd=$6$Lh0jvsS/YklFVYDM$WjPFI.WaMd3be/qiyFVUQkjEFN0PGQcnRTJFUDejJMUS24DA.M2rJ039hi/ubRiaNY4QNt661FARlxZqL.nCs0 --iscrypted --gecos=\u0026#34;admin\u0026#34; [root@pooky ~]# grep ^# /root/anaconda-ks.cfg # 以 # 为开头的行 #version=DEVEL # System authorization information # Use CDROM installation media # Use graphical install # Run the Setup Agent on first boot # Keyboard layouts # System language # Network information # Root password # System services # System timezone # X Window System configuration information # System bootloader configuration # Partition clearing information # Disk partitioning information [root@pooky ~]# grep \u0026#39;#\u0026#39; *.sh # 当前目录中，查找后缀有 .sh 文件中包含 # 字符串的行 Usage: grep [OPTION]... PATTERN [FILE]... Try \u0026#39;grep --help\u0026#39; for more information. find # find 命令用来在指定目录下查找文件。find \u0026lt;文件路径\u0026gt; \u0026lt;查找条件\u0026gt; [补充条件]。\n[root@pooky ~]# find /etc -name pass* # 查找 /etc 目录下 pass 前缀的文件 /etc/pam.d/passwd /etc/pam.d/password-auth-ac /etc/pam.d/password-auth /etc/openldap/certs/password /etc/passwd /etc/selinux/targeted/active/modules/100/passenger /etc/passwd- [root@pooky ~]# find /etc -regex .*wd$ # 使用正则 -regex /etc/security/opasswd /etc/pam.d/passwd /etc/passwd [root@pooky ~]# find /etc -type f -regex .*wd$ /etc/security/opasswd /etc/pam.d/passwd /etc/passwd 选项： -type : 指定文件类型，如 find -type f 查找普通文件\nsed 和 awk # sed 和 awk 是行编辑器。vim 是全文本编辑器。\nsed # sed 命令一般用于对文本内容做替换：sed [-hnV][-e \u0026lt;script\u0026gt;][-f \u0026lt;script 文件\u0026gt;] [文本文件]，例如：\nsed '/user1/s/user1/u1' /etc/passwd\n选项：\n-e：直接在命令行模式上进行 sed 动作编辑，此为默认选项 -f：将 sed 的动作写在一个文件内，用 –f filename 执行 filename 内的 sed 动作 -i：直接修改文件内容 -n：取消默认的完整输出，只打印模式匹配的行 -r：不需要转义 动作：\ns：替换 sed 's/old/new/' filename sed -e 's/old/new/' -e 's/old/new/' filename ... 可以执行多次替换脚本但是不能省略 -e sed -i 's/old/nnew/' 's/old/new/' filename ... 直接修改文件内容 d：删除 sed /匹配模式/d 删除匹配到的行 a：追加 i：插入 c：更改 r：读取 w：写入，使用和 r 类似 n：读入下一行 p：打印匹配的行 =：打印行号 sed 的工作方式：\n将文件以行为单位读取到内存（模式空间） 使用 sed 的每个脚本对该行进行操作 处理完成后输出该行 [root@SGDLITVM0905 ~]# echo a a a \u0026gt; afile [root@SGDLITVM0905 ~]# sed \u0026#39;s/a/aa/\u0026#39; afile aa a a [root@SGDLITVM0905 ~]# sed \u0026#39;s///abc/\u0026#39; afile # 如果原始字符是 / 和 分隔符冲突会报错 sed: -e expression #1, char 5: unknown option to `s\u0026#39; [root@SGDLITVM0905 ~]# sed \u0026#39;s!/!abc!\u0026#39; afile # 可以把分隔符换成 !，或者其他字符 a a a [root@SGDLITVM0905 ~]# sed -e \u0026#39;s/a/aa\u0026#39; -e \u0026#39;a/aa/bb\u0026#39; afile # 最后的分隔符不能省略 sed: -e expression #1, char 6: unterminated `s\u0026#39; command [root@SGDLITVM0905 ~]# sed -e \u0026#39;s/a/aa/\u0026#39; -e \u0026#39;s/aa/bb/\u0026#39; afile # 执行多个脚本 bb a a [root@SGDLITVM0905 ~]# sed -e \u0026#39;s/a/aa/;s/aa/bb/\u0026#39; afile # 执行多个脚本的简写形式 bb a a [root@SGDLITVM0905 ~]# sed -e \u0026#39;s/a/aa/;s/aa/bb/\u0026#39; afile bfile cfile # 可以修改多个文件 bb a a [root@SGDLITVM0905 ~]# cat afile # 原始文件并没有变化 a a a [root@SGDLITVM0905 ~]# sed -i \u0026#39;s/a/aa/;s/aa/bb/\u0026#39; afile # -i 可以使修改的内容作用到文件 bb a a [root@SGDLITVM0905 ~]# cat afile bb a a [root@SGDLITVM0905 ~]# sed -i \u0026#39;s/a/aa/;s/aa/bb/\u0026#39; afile \u0026gt; bfile # 如果不行修改原始文件，可使用重定向输出到另一个文件 sed 元字符的使用：\n[root@SGDLITVM0905 ~]# head -5 /etc/passwd root:x:0:0:root:/root:/bin/bash bin:x:1:1:bin:/bin:/sbin/nologin daemon:x:2:2:daemon:/sbin:/sbin/nologin adm:x:3:4:adm:/var/adm:/sbin/nologin lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin You have new mail in /var/spool/mail/root [root@SGDLITVM0905 ~]# head -5 /etc/passwd | sed \u0026#39;s/...//\u0026#39; # 表示替换三个任意字符为空 t:x:0:0:root:/root:/bin/bash :x:1:1:bin:/bin:/sbin/nologin mon:x:2:2:daemon:/sbin:/sbin/nologin :x:3:4:adm:/var/adm:/sbin/nologin x:4:7:lp:/var/spool/lpd:/sbin/nologin [root@SGDLITVM0905 ~]# head -5 /etc/passwd | sed \u0026#39;s/s*bin//\u0026#39; # 替换 sbin 或 bin 字符为空 root:x:0:0:root:/root://bash # sed 默认只替换每一行第一次匹配的字符 :x:1:1:bin:/bin:/sbin/nologin daemon:x:2:2:daemon:/:/sbin/nologin adm:x:3:4:adm:/var/adm://nologin lp:x:4:7:lp:/var/spool/lpd://nologin [root@SGDLITVM0905 ~]# sed \u0026#39;s/(aa)|(bb)/!/\u0026#39; afile # 匹配到 aa 或者 bb 替换为 !，() 是分组 [root@SGDLITVM0905 ~]# echo axyzb \u0026gt; cfile [root@SGDLITVM0905 ~]# sed -r \u0026#39;s/(a.*b)/\\1:\\1\u0026#39; cfile # \\1 引用第一个分组的内容，\\n 引用第 n 个分组的内容 axyzb:axyzb 其他动作：\n[root@SGDLITVM0905 ~]# cat bfile b a aa aaa ab abb abbb [root@SGDLITVM0905 ~]# sed \u0026#39;/ab/d\u0026#39; bfile # 删除匹配到 ab 的行 b a aa aaa [root@SGDLITVM0905 ~]# sed \u0026#39;/ab/d;s/a/!/\u0026#39; bfile b ! !a !aa [root@SGDLITVM0905 ~]# sed \u0026#39;/ab/d;=\u0026#39; bfile # = 可以打印行号 1 b 2 a 3 aa 4 aaa [root@SGDLITVM0905 ~]# sed \u0026#39;/ab/i hello\u0026#39; bfile # 匹配到 ab 的行上面插入 hello b a aa aaa hello ab hello abb hello abbb [root@SGDLITVM0905 ~]# sed \u0026#39;/ab/a hello\u0026#39; bfile # 匹配到 ab 的行下面插入 hello b a aa aaa ab hello abb hello abbb hello [root@SGDLITVM0905 ~]# sed \u0026#39;/ab/c hello\u0026#39; bfile # 匹配到 ab 的行改写为 hello b a aa aaa hello hello hello [root@SGDLITVM0905 ~]# sed \u0026#39;/ab/r afile\u0026#39; bfile # 把 afile 的内容插入到匹配到 ab 的行下面 b a aa aaa ab bb a a abb bb a a abbb bb a a sed 多行模式 # 多行模式的处理命令：\nN：将下一行加入到模式空间 D：删除模式空间中的第一个字符到第一个换行符 P：打印模式空间的第一个字符到第一个换行符 [root@SGDLITVM0905 ~]# cat a.txt hel lo [root@SGDLITVM0905 ~]# sed \u0026#39;N\u0026#39; a.txt # 将下一行追加到模式空间 hel lo [root@SGDLITVM0905 ~]# sed \u0026#39;N;s/hel\\nlo/!!!/\u0026#39; a.txt !!! [root@SGDLITVM0905 ~]# sed \u0026#39;N;s/hel.lo/!!!/\u0026#39; a.txt # . 匹配任意字符 !!! [root@SGDLITVM0905 ~]# cat \u0026gt; b.txt \u0026lt;\u0026lt; EOF \u0026gt; hell \u0026gt; o bash hel \u0026gt; lo bash \u0026gt; EOF [root@SGDLITVM0905 ~]# cat b.txt hell o bash hel lo bash [root@SGDLITVM0905 ~]# sed \u0026#39;N;s/\\n//;s/hello bash/hello sed\\n/;P;D\u0026#39; b.txt hello sed hello sed awk # awk 一般用于对文本内容进行统计，按需要的格式进行输出。一般是作为 sed 的一个补充。awk 可以看成是一种编程语言。\nawk 和 sed 的区别：\nawk 用于比较规范的文本处理，用于统计数量并输出指定字段 sed 一般用于把不规范的文本处理为规范的文本 awk 的流程控制：\n输入数据前例程 BEGIN{}，读入数据前执行，做一些预处理操作。 主输入循环 {}，处理读取的每一行。 所有文件读取完成例程 END{}，读取操作完成后执行，做一些数据汇总。 常用的写法是只写主输入循环。\n记录和字段 # 每一行叫做 awk 的记录 使用空格、制表符分隔开的单词叫做字段 可以指定分隔的字段 字段的引用：\nawk 中使用 $1 $2 \u0026hellip; $n 表示每一个字段，$0 表示当前行，awk '{print $1, $2, $3} filename' awk 可以使用 -F 改变字段的分隔符，awk -F ',' '{print $1, $2, $3}' filename，分隔符可以使用正则表达式 [root@SGDLITVM0905 ~]# awk \u0026#39;/^menu/{ print $0 }\u0026#39; /boot/grub2/grub.cfg # 打印以 menu 开头的行的，$0 表示当前行 menuentry \u0026#39;CentOS Linux (3.10.0-957.5.1.el7.x86_64) 7 (Core)\u0026#39; --class centos --class gnu-linux --class gnu --class os --unrestricted $menuentry_id_option \u0026#39;gnulinux-3.10.0-957.el7.x86_64-advanced-9c9da9f8-f77a-4a9a-99e0-e4f238472355\u0026#39; { menuentry \u0026#39;CentOS Linux (3.10.0-957.el7.x86_64) 7 (Core)\u0026#39; --class centos --class gnu-linux --class gnu --class os --unrestricted $menuentry_id_option \u0026#39;gnulinux-3.10.0-957.el7.x86_64-advanced-9c9da9f8-f77a-4a9a-99e0-e4f238472355\u0026#39; { menuentry \u0026#39;CentOS Linux (0-rescue-87b376b725324ec5aaba8f92806dbc8c) 7 (Core)\u0026#39; --class centos --class gnu-linux --class gnu --class os --unrestricted $menuentry_id_option \u0026#39;gnulinux-0-rescue-87b376b725324ec5aaba8f92806dbc8c-advanced-9c9da9f8-f77a-4a9a-99e0-e4f238472355\u0026#39; { [root@SGDLITVM0905 ~]# awk -F \u0026#34;\u0026#39;\u0026#34; \u0026#39;/^menu/{ print $2 }\u0026#39; /boot/grub2/grub.cfg # 以单引号为分隔符 CentOS Linux (3.10.0-957.5.1.el7.x86_64) 7 (Core) CentOS Linux (3.10.0-957.el7.x86_64) 7 (Core) CentOS Linux (0-rescue-87b376b725324ec5aaba8f92806dbc8c) 7 (Core) [root@SGDLITVM0905 ~]# awk -F \u0026#34;\u0026#39;\u0026#34; \u0026#39;/^menu/{ print $1 }\u0026#39; /boot/grub2/grub.cfg menuentry menuentry menuentry [root@SGDLITVM0905 ~]# awk -F \u0026#34;\u0026#39;\u0026#34; \u0026#39;/^menu/{ print x++,$2 }\u0026#39; /boot/grub2/grub.cfg # 使用运算符，显示序号，x 变量没有定义，默认为 0 0 CentOS Linux (3.10.0-957.5.1.el7.x86_64) 7 (Core) 1 CentOS Linux (3.10.0-957.el7.x86_64) 7 (Core) 2 CentOS Linux (0-rescue-87b376b725324ec5aaba8f92806dbc8c) 7 (Core) 表达式 # 赋值操作符：\n=，var1 = \u0026quot;name\u0026quot;，var2 = $1 ++ -- += -= *= /+ %= ^= 算数操作符：\n+ - * / % ^ 系统变量：\nFS 字段分隔符，默认是空格和制表符。 RS 行分隔符，用于分割每一行，默认是换行符。 OFS 输出的字段分隔符，用于打印时分隔字段，默认为空格。 ORS 输出行分隔符，用于打印时分隔记录，默认为换行符。 NR 表示当前处理的是第几行。 FNR 行数。 NF 字段数量，所以最后一个字段内容可以用 $NF 取出，$(NF-1) 代表倒数第二个字段。 [root@SGDLITVM0905 ~]# head -5 /etc/passwd | awk \u0026#39;BEGIN{FS=\u0026#34;:\u0026#34;}{print $1}\u0026#39; # BEGIN{FS=\u0026#34;:\u0026#34;} 表示在读入之前设置字段分隔符为 :，也可以写成 awk -F \u0026#34;:\u0026#34; \u0026#39;{print $1}\u0026#39; root bin daemon adm lp [root@SGDLITVM0905 ~]# head -5 /etc/passwd | awk \u0026#39;BEGIN{FS=\u0026#34;:\u0026#34;}{print $1,$2}\u0026#39; root x # 可以看出输出的字段分隔符默认为空格 bin x daemon x adm x lp x [root@SGDLITVM0905 ~]# head -5 /etc/passwd | awk \u0026#39;BEGIN{FS=\u0026#34;:\u0026#34;;OFS=\u0026#34;-\u0026#34;}{print $1,$2}\u0026#39; # 输出的字段分隔符设置为 - root-x bin-x daemon-x adm-x lp-x [root@SGDLITVM0905 ~]# head -5 /etc/passwd | awk \u0026#39;BEGIN{RS=\u0026#34;:\u0026#34;}{print $0}\u0026#39; # 已 : 为行分隔符，输出每一行 root x 0 0 root /root /bin/bash bin x 1 1 bin /bin /sbin/nologin daemon [root@SGDLITVM0905 ~]# head -5 /etc/passwd | awk \u0026#39;{print NR}\u0026#39; # 显示行号 1 2 3 4 5 [root@SGDLITVM0905 ~]# head -5 /etc/passwd | awk \u0026#39;{print NR, $0}\u0026#39; 1 root:x:0:0:root:/root:/bin/bash 2 bin:x:1:1:bin:/bin:/sbin/nologin 3 daemon:x:2:2:daemon:/sbin:/sbin/nologin 4 adm:x:3:4:adm:/var/adm:/sbin/nologin 5 lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin [root@SGDLITVM0905 ~]# awk \u0026#39;{print FNR, $0}\u0026#39; /etc/hosts /etc/hosts # FNR 会重排行号 1 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 2 #::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 3 4 16.187.191.150 SGDLITVM0905.hpeswlab.net SGDLITVM0905 1 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 2 #::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 3 4 16.187.191.150 SGDLITVM0905.hpeswlab.net SGDLITVM0905 You have new mail in /var/spool/mail/root [root@SGDLITVM0905 ~]# awk \u0026#39;{print NR, $0}\u0026#39; /etc/hosts /etc/hosts # FNR 不会重排行号 1 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 2 #::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 3 4 16.187.191.150 SGDLITVM0905.hpeswlab.net SGDLITVM0905 5 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 6 #::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 7 8 16.187.191.150 SGDLITVM0905.hpeswlab.net SGDLITVM0905 [root@SGDLITVM0905 ~]# head -5 /etc/passwd | awk \u0026#39;BEGIN{FS=\u0026#34;:\u0026#34;}{print NF}\u0026#39; # NF 输出字段数量 7 7 7 7 7 You have new mail in /var/spool/mail/root [root@SGDLITVM0905 ~]# head -5 /etc/passwd | awk \u0026#39;BEGIN{FS=\u0026#34;:\u0026#34;}{print $NF}\u0026#39; # $NF 就可以获取到最后一个字段的内容 /bin/bash /sbin/nologin /sbin/nologin /sbin/nologin /sbin/nologin 关系操作符：\n\u0026lt; \u0026gt; \u0026lt;= \u0026gt;= == != ~ !~ 布尔操作符：\n\u0026amp;\u0026amp; || ! 条件语句：\nif (表达式) awk 语句1 [ else awk 语句2 ] 多个语句可以使用 {} 括起来。\n[root@SGDLITVM0905 ~]# cat score.txt user1 60 61 62 63 64 65 user2 70 71 72 73 74 75 user3 80 81 82 83 84 85 user4 90 91 92 93 94 95 [root@SGDLITVM0905 ~]# awk \u0026#39;{if($2\u0026gt;=80) print $1}\u0026#39; score.txt user3 user4 [root@SGDLITVM0905 ~]# awk \u0026#39;{if($2\u0026gt;=80) print $1; print $2}\u0026#39; score.txt # 这种写法会把所有的第二个字段输出 60 70 user3 80 user4 90 [root@SGDLITVM0905 ~]# awk \u0026#39;{if($2\u0026gt;=80) {print $1; print $2} }\u0026#39; score.txt # 如果想一起输出要加上 {} ，多个语句一起执行 60 70 user3 80 user4 90 while 循环：\nwhile(表达式) awk 语句1 do 循环：\ndo { awk 语句1 }while(表达式) for 循环：\nfor(初始值;判断条件;累加) awk 语句1 可以使用 break 和 continue。\n[root@SGDLITVM0905 ~]# cat score.txt user1 60 61 62 63 64 65 user2 70 71 72 73 74 75 user3 80 81 82 83 84 85 user4 90 91 92 93 94 95 [root@SGDLITVM0905 ~]# head -1 score.txt user1 60 61 62 63 64 65 [root@SGDLITVM0905 ~]# head -1 score.txt | awk \u0026#39;for(c=2;c\u0026lt;=NF;c++) print c\u0026#39; 2 3 4 5 6 7 [root@SGDLITVM0905 ~]# head -1 score.txt | awk \u0026#39;for(c=2;c\u0026lt;=NF;c++) print $c\u0026#39; # 输出值 61 62 63 64 65 [root@SGDLITVM0905 ~]# head -1 score.txt | awk \u0026#39;for(c=2;c\u0026lt;=NF;c++) print $c\u0026#39; # 输出值 61 62 63 64 65 数组：\n数组[下标] = 值，初始化数组。下标可以是数字，也可以是字符串。 for (变量 in 数组)，数组[变量] 获取数组元素 delete 数组[下标] 删除数组元素 [root@SGDLITVM0905 ~]# cat score.txt user1 60 61 62 63 64 65 user2 70 71 72 73 74 75 user3 80 81 82 83 84 85 user4 90 91 92 93 94 95 [root@SGDLITVM0905 ~]# awk \u0026#39;{ sum=0; for(column=2;column\u0026lt;=NF;column++) sum+=$column; print sum }\u0026#39; score.txt # 计算每个人的总分 375 435 495 555 [root@SGDLITVM0905 ~]# [root@SGDLITVM0905 ~]# awk \u0026#39;{ sum=0; for(column=2;column\u0026lt;=NF;column++) sum+=$column; avg[$1]=sum/(NF-1); }END{ for( user in avg) print user, avg[user]}\u0026#39; score.txt # 计算每个人的平均分 并在 END 例程中格式化输出 user1 62.5 user2 72.5 user3 82.5 user4 92.5 awk 脚本可以保存到文件：\n[root@SGDLITVM0905 ~]# awk -f avg.awk score.txt user1 62.5 user2 72.5 user3 82.5 user4 92.5 -f 加载 awk 文件 avg.awk 文件的内容：{ sum=0; for(column=2;column\u0026lt;=NF;column++) sum+=$column; avg[$1]=sum/(NF-1); }END{ for( user in avg) print user, avg[user]}。 命令行参数数组：\nARGC 命令行参数数组的长度 ARGV 命令行参数数组 [root@SGDLITVM0905 ~]# cat arg.awk BEGIN{ for(x=0;x\u0026lt;ARGC;x++) print ARGV[x] print ARGC } [root@SGDLITVM0905 ~]# awk -f arg.awk awk 1 [root@SGDLITVM0905 ~]# awk -f arg.awk 11 22 33 awk 11 22 33 4 ARGV[0] 就是命令本身。\n[root@SGDLITVM0905 ~]# cat avg.awk { sum = 0 for ( c = 2; c \u0026lt;= NF; c++ ) sum += $c avg[$1] = sum / ( NF-1 ) print $1, avg[$1] } END{ for ( usr in avg) sum_all += avg[user] avg_all = sum_all / NR for ( user in avg ) if ( avg[user] \u0026gt; avg_all ) above++ else below++ print \u0026#34;above\u0026#34;, above print \u0026#34;below\u0026#34;, below } [root@SGDLITVM0905 ~]# awk -f avg.awk score.txt user1 62.5 user2 72.5 user3 82.5 user4 92.5 above 4 below 1 awk 函数：\n算数函数 sin() cos() int() rand() srand() 字符串函数 toupper(s) tolower(s) length(s) split(s,a,sep) match(s,r) substr(s,p,n) 自定义函数，自定义函数一定要写在 BEGIN 主循环 END 例程的外面 function 函数名 ( 参数 ) { awk 语句 return awk 变量 } 示例：\n[root@SGDLITVM0905 ~]# awk \u0026#39;BEGIN{pi=3.14; print int(pi)}\u0026#39; 3 [root@SGDLITVM0905 ~]# awk \u0026#39;BEGIN{print rand()}\u0026#39; # 这是一个伪随机数 0.237788 [root@SGDLITVM0905 ~]# awk \u0026#39;BEGIN{print rand()}\u0026#39; 0.237788 [root@SGDLITVM0905 ~]# awk \u0026#39;BEGIN{print rand()}\u0026#39; 0.237788 [root@SGDLITVM0905 ~]# awk \u0026#39;BEGIN{srand();print rand()}\u0026#39; # srand 会重新获取种子。范围是 0 ~ 1 0.960391 [root@SGDLITVM0905 ~]# awk \u0026#39;BEGIN{srand();print rand()}\u0026#39; 0.0422737 [root@SGDLITVM0905 ~]# awk \u0026#39;BEGIN{srand();print rand()}\u0026#39; 0.555768 [root@SGDLITVM0905 ~]# awk \u0026#39;function a() { return 0 } BEGIN{ print a()}\u0026#39; 0 [root@SGDLITVM0905 ~]# awk \u0026#39;function double(str) { return str str } BEGIN{ print double(\u0026#34;hello\u0026#34;)}\u0026#39; hellohello "},{"id":16,"href":"/os-learn/docs/commands/17_firewall/","title":"防火墙","section":"Linux 常用命令","content":" 防火墙 # 防火墙分为两类：\n软件防火墙，CentOS 6 的默认防火墙是 iptables，CentOS 7 的默认防火墙是 firewalld，底层都是使用内核中的 netfilter。 包过滤防火墙，主要用于数据包的过滤，数据包转发。 应用层防火墙，可以控制应用程序的具体的行为。 硬件防火墙 iptables # iptables的结构：\niptables -\u0026gt; Tables -\u0026gt; Chains -\u0026gt; Rules tables 由 chains 组成，而 chains 又由 rules 组成。\n表（tables）提供特定的功能，iptables 包含四个规则表：\nfilter 包过滤 nat 网络地址转换 mangle 包重构(修改) raw 数据跟踪处理 链（chains）是数据包传播的路径，每一条链其实就是众多规则中的一个检查清单，每一条链中可以有一条或数条规则。\n当一个数据包到达一个链时，iptables 就会从链中第一条规则开始检查，看该数据包是否满足规则所定义的条件。如果满足，系统就会根据该条规则所定义的方法处理该数据包； 否则 iptables 将继续检查下一条规则，如果该数据包不符合链中任一条规则，iptables 就会根据该链预先定义的默认策略来处理数据包。\niptables 的规则链：\nINPUT 接收的的数据包使用此规则链中的策略 OUTPUT 发送的数据包使用此规则链中的策略 FORWARD 转发数据包时使用此规则链中的策略 PREROUTING 目的地址转换 POSTROUTING 源地址转换 iptables [-t 表] 命令选项 [规则链] 规则，-t 默认使用的是 filter。\n命令选项用于指定管理 iptables 规则的方式（比如：插入、增加、删除、查看）。\n命令选项：\n-L 列出（list）指定链中所有的规则进行查看 -A 在指定链的末尾添加（append）一条新的规则 -I 在指定链中插入（insert）一条新的规则，默认在第一行添加 -D 删除（delete）指定链中的某一条规则，可以按规则序号和内容删除，iptables -D INPUT 1 -F 清空（flush），iptables -F 清楚 filter 的规则 -P 设置指定链的默认策略（policy），iptables -P INPUT DROP -N 新建（new-chain）一条用户自己定义的规则链 -X 删除指定表中用户自定义的规则链（delete-chain） -E 重命名用户定义的链，不改变链本身 -n 直接使用，不解析域名 -v 查看规则表详细信息 规则选项：\n-i 输入网口 -o 输出网口 -p proto 匹配网络协议：tcp、udp、icmp --icmp-type type 匹配 ICMP 类型，和 -p icmp 配合使用。注意有两根短划线 -s source-ip 匹配来源主机（或网络）的IP地址 --sport port 匹配来源主机的端口，和 -s source-ip 配合使用。 -d dest-ip 匹配目标主机的 IP 地址 --dport port 匹配目标主机（或网络）的端口，和 -d dest-ip 配合使用。 数据包控制方式：\nACCEPT: 允许数据包通过 DROP: 直接丢弃数据包，不给出任何回应信息 REJECT: 拒绝数据包通过，必须时会给数据发送端一个响应信息 LOG: 日志功能，在 /var/log/messages 文件中记录日志信息，然后将数据包传递给下一条规则 REDIRECT: 将数据包重新转向到本机或另一台主机的某一个端口，通常功能实现透明代理或对外开放内网的某些服务 SNAT: 源地址转换 DNAT: 目的地址转换 MASQUERADE: IP 伪装 [root@shcCentOS72VM07 ~]# iptables -t filter -L Chain INPUT (policy ACCEPT) target prot opt source destination ACCEPT udp -- anywhere anywhere udp dpt:domain ACCEPT tcp -- anywhere anywhere tcp dpt:domain ACCEPT udp -- anywhere anywhere udp dpt:bootps ACCEPT tcp -- anywhere anywhere tcp dpt:bootps Chain FORWARD (policy ACCEPT) target prot opt source destination ACCEPT all -- anywhere 192.168.122.0/24 ctstate RELATED,ESTABLISHED ACCEPT all -- 192.168.122.0/24 anywhere ACCEPT all -- anywhere anywhere REJECT all -- anywhere anywhere reject-with icmp-port-unreachable REJECT all -- anywhere anywhere reject-with icmp-port-unreachable Chain OUTPUT (policy ACCEPT) target prot opt source destination ACCEPT udp -- anywhere anywhere udp dpt:bootpc [root@shcCentOS72VM07 ~]# iptables -t filter -A INPUT -s 10.0.0.1 -j ACCEPT # 可以接收从 IP 为 10.0.0.1 发送的数据包 [root@shcCentOS72VM07 ~]# iptables -t filter -vnL Chain INPUT (policy ACCEPT 3170 packets, 320K bytes) # 表示过滤了 3170 个数据包，320 KB pkts bytes target prot opt in out source destination 0 0 ACCEPT udp -- virbr0 * 0.0.0.0/0 0.0.0.0/0 udp dpt:53 0 0 ACCEPT tcp -- virbr0 * 0.0.0.0/0 0.0.0.0/0 tcp dpt:53 0 0 ACCEPT udp -- virbr0 * 0.0.0.0/0 0.0.0.0/0 udp dpt:67 0 0 ACCEPT tcp -- virbr0 * 0.0.0.0/0 0.0.0.0/0 tcp dpt:67 0 0 ACCEPT all -- * * 10.0.0.1 0.0.0.0/0 Chain FORWARD (policy ACCEPT 0 packets, 0 bytes) pkts bytes target prot opt in out source destination 0 0 ACCEPT all -- * virbr0 0.0.0.0/0 192.168.122.0/24 ctstate RELATED,ESTABLISHED 0 0 ACCEPT all -- virbr0 * 192.168.122.0/24 0.0.0.0/0 0 0 ACCEPT all -- virbr0 virbr0 0.0.0.0/0 0.0.0.0/0 0 0 REJECT all -- * virbr0 0.0.0.0/0 0.0.0.0/0 reject-with icmp-port-unreachable 0 0 REJECT all -- virbr0 * 0.0.0.0/0 0.0.0.0/0 reject-with icmp-port-unreachable Chain OUTPUT (policy ACCEPT 33 packets, 3887 bytes) pkts bytes target prot opt in out source destination 0 0 ACCEPT udp -- * virbr0 0.0.0.0/0 0.0.0.0/0 udp dpt:68 [root@shcCentOS72VM07 ~]# iptables -A INPUT -s 10.0.0.2 -j ACCEPT [root@shcCentOS72VM07 ~]# iptables -A INPUT -s 10.0.0.2 -j DROP [root@shcCentOS72VM07 ~]# iptables -vnL Chain INPUT (policy ACCEPT 181 packets, 19084 bytes) pkts bytes target prot opt in out source destination 0 0 ACCEPT udp -- virbr0 * 0.0.0.0/0 0.0.0.0/0 udp dpt:53 0 0 ACCEPT tcp -- virbr0 * 0.0.0.0/0 0.0.0.0/0 tcp dpt:53 0 0 ACCEPT udp -- virbr0 * 0.0.0.0/0 0.0.0.0/0 udp dpt:67 0 0 ACCEPT tcp -- virbr0 * 0.0.0.0/0 0.0.0.0/0 tcp dpt:67 0 0 ACCEPT all -- * * 10.0.0.1 0.0.0.0/0 0 0 ACCEPT all -- * * 10.0.0.2 0.0.0.0/0 0 0 DROP all -- * * 10.0.0.2 0.0.0.0/0 Chain FORWARD (policy ACCEPT 0 packets, 0 bytes) pkts bytes target prot opt in out source destination 0 0 ACCEPT all -- * virbr0 0.0.0.0/0 192.168.122.0/24 ctstate RELATED,ESTABLISHED 0 0 ACCEPT all -- virbr0 * 192.168.122.0/24 0.0.0.0/0 0 0 ACCEPT all -- virbr0 virbr0 0.0.0.0/0 0.0.0.0/0 0 0 REJECT all -- * virbr0 0.0.0.0/0 0.0.0.0/0 reject-with icmp-port-unreachable 0 0 REJECT all -- virbr0 * 0.0.0.0/0 0.0.0.0/0 reject-with icmp-port-unreachable Chain OUTPUT (policy ACCEPT 27 packets, 2396 bytes) pkts bytes target prot opt in out source destination 0 0 ACCEPT udp -- * virbr0 0.0.0.0/0 0.0.0.0/0 udp dpt:68 上面的示例，INPUT 链配置了两条规则，分别是接收 IP 为 10.0.0.2 的数据包，和丢弃 10.0.0.2 的数据包。那么 10.0.0.2 的数据包能不能进来？\n可以。数据包会先匹配前面的 ACCEPT 10.0.0.2 的规则，这个时候数据包就进入了系统，所以规则顺序很重要。可以使用 -I 把规则从头插入。\n(policy ACCEPT) 表示默认的策略。也就意味着，如果没有匹配到任何规则，就会使用默认规则，这里就是全部允许。修改默认规则使用 -P，如 iptables -P INPUT DROP。\n更多示例：\n# 拒绝进入防火墙的所有 ICMP 协议数据包 iptables -I INPUT -p icmp -j REJECT # 允许防火墙转发除 ICMP 协议以外的所有数据包 iptables -A FORWARD -p ! icmp -j ACCEPT # 拒绝转发来自 192.168.1.10 主机的数据，允许转发来自 192.168.0.0/24 网段的数据，注意顺序 iptables -A FORWARD -s 192.168.1.11 -j REJECT iptables -A FORWARD -s 192.168.0.0/24 -j ACCEPT # 丢弃从网口（eth1）进入防火墙本机的源地址为私网地址的数据包 iptables -A INPUT -i eth1 -s 192.168.0.0/16 -j DROP iptables -A INPUT -i eth1 -s 172.16.0.0/12 -j DROP iptables -A INPUT -i eth1 -s 10.0.0.0/8 -j DROP # 封堵网段（192.168.1.0/24），两小时后解封 iptables -I INPUT -s 10.20.30.0/24 -j DROP iptables -I FORWARD -s 10.20.30.0/24 -j DROP at now +2 hours # 借助 crond 计划任务来完成 at\u0026gt; iptables -D INPUT 1 at\u0026gt; iptables -D FORWARD 1 [1]+ Stopped at now +2 hours # 只允许管理员从 202.13.0.0/16 网段使用 SSH 远程登录防火墙主机 iptables -A INPUT -p tcp --dport 22 -s 202.13.0.0/16 -j ACCEPT iptables -A INPUT -p tcp --dport 22 -j DROP # 允许本机开放从 TCP 端口 20-1024 提供的应用服务 iptables -A INPUT -p tcp --dport 20:1024 -j ACCEPT iptables -A OUTPUT -p tcp --sport 20:1024 -j ACCEPT # 允许转发来自 192.168.0.0/24 局域网段的 DNS 解析请求数据包 iptables -A FORWARD -s 192.168.0.0/24 -p udp --dport 53 -j ACCEPT iptables -A FORWARD -d 192.168.0.0/24 -p udp --sport 53 -j ACCEPT # 禁止其他主机 ping 防火墙主机，但是允许从防火墙上 ping 其他主机 iptables -I INPUT -p icmp --icmp-type Echo-Request -j DROP iptables -I INPUT -p icmp --icmp-type Echo-Reply -j ACCEPT iptables -I INPUT -p icmp --icmp-type destination-Unreachable -j ACCEPT # 禁止转发来自 MAC 地址为 00：0C：29：27：55：3F 的和主机的数据包 iptables -A FORWARD -m mac --mac-source 00:0c:29:27:55:3F -j DROP # 允许防火墙本机对外开放 TCP 端口 20、21、25、110 以及被动模式 FTP 端口 1250-1280 # -m multiport –dport 来指定目的端口及范围 iptables -A INPUT -p tcp -m multiport --dport 20,21,25,110,1250:1280 -j ACCEPT # 禁止转发源 IP 地址为 192.168.1.20-192.168.1.99 的 TCP 数据包。 # -m –iprange –src-range 指定 IP 范围 iptables -A FORWARD -p tcp -m iprange --src-range 192.168.1.20-192.168.1.99 -j DROP # 禁止转发与正常 TCP 连接无关的非—syn请求数据包 # -m state 表示数据包的连接状态 # NEW 表示与任何连接无关的 iptables -A FORWARD -m state --state NEW -p tcp ! --syn -j DROP # 拒绝访问防火墙的新数据包，但允许响应连接或与已有连接相关的数据包 # ESTABLISHED 表示已经响应请求或者已经建立连接的数据包 # RELATED 表示与已建立的连接有相关性的 iptables -A INPUT -p tcp -m state --state NEW -j DROP iptables -A INPUT -p tcp -m state --state ESTABLISHED,RELATED -j ACCEPT # 只开放本机的 80、FTP(20、21、20450-20480)，放行外部主机发住服务器其它端口的应答数据包，将其他入站数据包均予以丢弃处理 iptables -I INPUT -p tcp -m multiport --dport 20,21,80 -j ACCEPT iptables -I INPUT -p tcp --dport 20450:20480 -j ACCEPT iptables -I INPUT -p tcp -m state --state ESTABLISHED -j ACCEPT iptables -P INPUT DROP # 删除规则 # 添加一条 NAT 规则 iptables -t nat -A PREROUTING -p tcp -m tcp --dport 80 -j DNAT --to-destination 192.168.99.11:80 # 删除上面的规则 iptables -t nat -D PREROUTING -p tcp -m tcp --dport 80 -j DNAT --to-destination 192.168.99.11:80 nat 表使用：\n# 进入防火墙的数据包目的地址转换，从网口 eth0 进入的数据包，把目的 IP 为 114.115.116.117，端口为 80 的数据包，转到 10.0.0.1 # 这里外网用户访问公网地址 114.115.116.117:80，防火墙再转发到内网地址 iptables -t nat -A PREROUTING -i eth0 -d 114.115.116.117 -p tcp --dport 80 -j DNAT --to-destination 10.0.0.1 # 源地址转换，源地址 10.0.0.0/24 ，从网口 eth1 发出，并把源地址伪装成 111.112.113.114，响应回来后再转换为源地址 # 这里是内网地址 10.0.0.0/24 主机访问外网，会将内网地址伪装成公网 IP 111.112.113.114 iptables -t nat -A POSTROUTING -s 10.0.0.0/24 -i eth1 -j SNAT --to-source 111.112.113.114 iptables 配置文件 # 命令行配置，在关机后会失效，想要持久化，可以修改配置文件：/etc/sysconfig/iptables\n保存命令：\nCentOS 6 可以使用 service iptables save CentOS 7 需要使用 yum install iptables-services 先安装软件包 iptables-save 可以输出内存中的 iptables 规则，iptables-save \u0026gt; /etc/sysconfig/iptables 就可以把内存中的配置保存到配置文件。下次开机时配置就会保留，相当于执行了 iptables-restore \u0026lt; /etc/sysconfig/iptables firewalld # firewalld 使用比 iptables 简单，主要区别：\nfirewalld 使用区域和服务而不是链式规则。 它动态管理规则集，允许更新规则而不破坏现有会话和连接。 使用：\nsystemctl start|stop|enable|disbale firewalld.service 控制 firewalld 服务 firewll-cmd firewalld 配置命令 iptables 和 firewalld 同时运行会产生冲突。应该关闭其中一个。\n# 查看状态 [root@shcCentOS72VM07 ~]# firewall-cmd --state # 重新加载配置 [root@shcCentOS72VM07 ~]# firewall-cmd --reload # 查看具体信息 [root@shcCentOS72VM07 ~]# firewall-cmd --list-all public (active) # public 就是一个区域 zone target: default icmp-block-inversion: no interfaces: eth0 sources: 10.0.0.1 10.0.0.1/24 services: ssh dhcpv6-client ports: 80/tcp 23/tcp protocols: masquerade: no forward-ports: sources-ports: icmp-blocks: rich rules: [root@shcCentOS72VM07 ~]# 上面的示例，就表示 public zone 绑定了 eth0 网口，source IP 为 10.0.0.1 10.0.0.1/24 的可以访问端口 80，和 23，还可以访问 ssh 和 dhcpv6-client 服务。\n[root@shcCentOS72VM07 ~]# firewall-cmd --zone=public --list-interfaces eth0 [root@shcCentOS72VM07 ~]# firewall-cmd --list-ports 80/tcp 23/tcp [root@shcCentOS72VM07 ~]# firewall-cmd --list-services ssh dhcpv6-client 上面的示例是单独查看某一项配置，--zone=public 可以省略，public 是默认的。\n[root@shcCentOS72VM07 ~]# firewall-cmd --get-zones # 查看 block dmz drop external home internal public trusted work [root@shcCentOS72VM07 ~]# firewall-cmd --get-default-zone # 查看默认使用的 zone public [root@shcCentOS72VM07 ~]# firewall-cmd --get-active-zones # 查看激活的 zone public interfaces: eth0 sources: 10.0.0.1 10.0.0.1/24 [root@shcCentOS72VM07 ~]# firewall-cmd --get-default-zone # 查看默认使用的 zone public 添加规则 # [root@shcCentOS72VM07 ~]# firewall-cmd --add-services=https # 添加服务 success 上面的示例中添加了一个 https 服务，但是这种规则是临时的，如果系统重启，或者执行 firewall-cmd --reload 之后就会消失，如果想要持久保存，使用 --permanent 参数。\nfirewall-cmd --zone=public --add-service=https --permanent # reload 命令会删除所有运行时配置并应用永久配置。因为 firewalld 动态管理规则集，所以它不会破坏现有的连接和会话 firewall-cmd --reload # 也可以同时添加到临时和持久规则集 firewall-cmd --zone=public --add-service=https --permanent # 添加到持久规则集，会在 reload 之后生效 firewall-cmd --zone=public --add-service=https # 临时规则集，会立即生效 # 查看默认的可用服务 firewall-cmd --get-services # 要启用或禁用 HTTP 服务：  firewall-cmd --zone=public --add-service=http --permanent firewall-cmd --zone=public --remove-service=http --permanent # 允许或者禁用 12345 端口的 TCP 流量。 firewall-cmd --zone=public --add-port=12345/tcp --permanent firewall-cmd --zone=public --remove-port=12345/tcp --permanent # 在同一台服务器上将 80 端口的流量转发到 12345 端口 firewall-cmd --zone=\u0026#34;public\u0026#34; --add-forward-port=port=80:proto=tcp:toport=12345 # 不同服务器端口转发，要先开启 masquerade firewall-cmd --zone=public --add-masquerade # 将 IP 地址为 ：123.456.78.9 的远程服务器上 80 端口的流量转发到 8080 上 firewall-cmd --zone=\u0026#34;public\u0026#34; --add-forward-port=port=80:proto=tcp:toport=8080:toaddr=123.456.78.9 # 删除规则 --remove 替换 --add # firewall-cmd --zone=public --remove-masquerade 配置文件 # /usr/lib/FirewallD 下保存默认配置，如默认区域和公用服务。避免修改它们，因为每次 firewall 软件包更新时都会覆盖这些文件。 /etc/firewalld 下保存系统配置文件。 这些文件将覆盖默认配置。 "},{"id":17,"href":"/os-learn/docs/commands/18_ssh/","title":"SSH","section":"Linux 常用命令","content":" SSH # SSH（Secure Shell）是一种网络协议，用于加密两台计算机之间的通信，并且支持各种身份验证机制。主要用于服务器登录和各种加密通信。\n历史上，网络主机之间的通信是不加密的，属于明文通信。这使得通信很不安全。SSH 就是为了解决这个问题而诞生的。\nSSH 的软件架构是服务器-客户端模式（Server - Client）。\nSSH 客户端 # 基本用法：\n# 不指定用户名，使用客户端的当前用户名，作为远程服务器的登录用户名 $ ssh hostname # 指定用户名 $ ssh user@hostname # -l 参数，用户名和主机名可以分开 $ ssh -l username host # -p 指定端口，默认连接服务器的 22 端口 $ ssh -p 8821 foo.com # 连接服务器，并立刻执行 command，非交互模式 ssh username@hostname command 客户端连接流程 # ssh 连接远程服务器，如果是第一次连接某一台服务器，会出现下面的提示：\nThe authenticity of host \u0026#39;16.187.189.94 (16.187.189.94)\u0026#39; can\u0026#39;t be established. ECDSA key fingerprint is SHA256:Vybt22mVXuNuB5unE++yowF7lgA/9/2bLSiO3qmYWBY. Are you sure you want to continue connecting (yes/no)? 表示不认识 16.187.189.94 这台服务器的指纹，确认是否需要连接。服务器指纹 指的是 SSH 服务器公钥的哈希值。\n查看公钥的指纹，可以使用命令：\n$ ssh-keygen -l -f /etc/ssh/ssh_host_ecdsa_key.pub 256 Vybt22mVXuNuB5unE++yowF7lgA/9/2bLSiO3qmYWBY (ECDSA) 输入 yes，客户端会将服务器的公钥指纹储存在本机的 ~/.ssh/known_hosts 文件中。每次连接服务器时，通过该文件判断是否为陌生主机。\n建立连接后，输入用户名密码就可以登录了。\n服务器密钥变更 # 服务器指纹可以防止有人恶意冒充远程主机。如果服务器的密钥发生变更（比如重装了 SSH 服务器），客户端再次连接时，发现公钥指纹不匹配，会显示一段警告信息：\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY! Someone could be eavesdropping on you right now (man-in-the-middle attack)! It is also possible that the RSA host key has just been changed. The fingerprint for the RSA key sent by the remote host is 77:a5:69:81:9b:eb:40:76:7b:13:04:a9:6c:f4:9c:5d. Please contact your system administrator. Add correct host key in /home/me/.ssh/known_hosts to get rid of this message. Offending key in /home/me/.ssh/known_hosts:36 表示公钥指纹和 ~/.ssh/known_hosts 文件储存的不一样。如果要信任新的公钥，可以使用命令，将原来的公钥指纹从 ~/.ssh/known_hosts 文件删除：\n$ ssh-keygen -R hostname 也可以手动从 ~/.ssh/known_hosts 文件中删除。\n删除以后，重新连接就可以了。\n配置文件 # SSH 客户端的全局配置文件是 /etc/ssh/ssh_config，用户个人的配置文件在 ~/.ssh/config，优先级高于全局配置文件。\n密钥登录 # SSH 默认使用密码登录，每次都必须输入密码，不安全也麻烦。可以通过密钥登录。\nSSH 密钥登录采用的是非对称加密，私钥必须私密保存，不能泄漏；公钥则是公开的，可以对外发送。如果数据使用公钥加密，那么只有使用对应的私钥才能解密；如果使用私钥加密（这个过程一般称为“签名”），也只有使用对应的公钥解密。\n密钥登录过程：\n用户将自己的公钥储存在远程主机上的指定位置。 用户登录的时候，远程主机会向用户发送一段随机字符串。 用户收到随机字符串，用自己的私钥对随机串加密（签名）后，再发给远程主机。 远程主机收到客户端发来的加密签名后，用事先储存的公钥进行解密，然后跟原始数据比较。如果一致，就允许用户登录。 用户可以使用 ssh-keygen 密钥对，生成时可以对私钥设置口令（passphrase）。一般密钥对会放在 $HOME/.ssh/ 目录下，会新生成两个文件：id_rsa.pub 和 id_rsa。前者是公钥，后者是私钥。\n将公钥传送到远程主机上面：\n查看是否存在 $HOME/.ssh/authorized_keys 文件，不存在则创建该文件： 将生成的 id_rsa.pub 文件内容粘贴到 authorized_keys 文件。 [root@SGDLITVM0905 .ssh]# cat authorized_keys ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDaA4G5QBf3IgoA4+4iB8P2JLshyidbUZ4g4NRhMc0T5t7+LHjitnixtfoufDIFUsX3iiJqj/E53vuYtmPZdB9J+V6LMG1Ld2tPFnnzF8/7Xb+IcYLmpkBxFdH30XpuI4Kbt8nZROhTtpQ6/Hj4RLhvYbuR5xNeBkRZQoST2SwP9BzPnCPZCm4Z0X00/ol61hD9n3lEoa7riAUwzS6Sa+8wNjxf1srUJvvAk6URvN1qGZhJGAG2z+fuYcJOlggZ+fTbLOqaY+JZ/m3CSzZ7Yvl44D3JgqkFBQiBaZGvhg3reaOGxv6KrAd+gIR8QiOekZUzP7LWevthe2mYaYDDVxc9 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCbsQz/ePcNnIb7K3DHaULVRwa/GE6wxTqWSCzMzM4tVYlwfJo0bMti4qjsrJz2IVb9lH6Sfu69brr7yHRgcaeCNPKlDtrhH1bxzu4ayjoimcibeKrOfZu6qCJH+JxfwxC9eW6xQDu+Z6xigny19miSd3PhDqHloz4GZKRa2X1fPxB//F+NYuTZJvafjKCZ8eIXcjr0R53tpxdkhKpYIQ4rd8uPtZPjidrEUQcukmngG/LPhoJ6ebQ1zOmSPtXP3kVLATrrlQRWZlHqSbFJpnJHclhN8NgahtyR7ad63suHxBKLAa71QjNvSRfa0QUQ4/uqH9zBT5hbGd1IXSA3Sq1l root@shcAimeeCOS72.hpeswlab.net ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCaDa+Nl8NK7bagAp9vbuKQyh00y6UHOdNiugwc6Mcw7qsCPpV257LZDLHyrXjdQpqFy135AZTUPGozPh8TH/W6sI8jWgCl9+mYup7+/i1wwjIxnkppKV7nqrWVxEXt5LLny7M0+HCw4pC9jUlFGC5MZVV6mVyI8oTeRkZddrja0c/65Et0+ksiiT2A4yIDoKFslv5vDAYolRJx13a4ESWjsCpGQOvrxtsQqpISm0yaZO8Ha+1a6tjniEWReZNGcOajrLP4V+lv8Qi0Cl/iNIkpD+fnRFphY6RgYC5UrLFYOBCgaKgQhUBK2BOcjM1dR1IqCV9YRv+N4PLhmLweyvQJ root@autovmCOS76VM09.hpeswlab.net 然后再登录，就不需要输入密码了。\nssh 也提供了命令来拷贝公钥，ssh-copy-id：\n# -i 指定公钥文件，拷贝到对应的账户下的 authorized_keys 文件中 ssh-copy-id -i ~/.ssh/id_rsa.pub root@16.187.189.94 如果不能登录，检查远程主机的 /etc/ssh/sshd_config 文件，去掉如下三行注释：\n#RSAAuthentication yes #PubkeyAuthentication yes #AuthorizedKeysFile .ssh/authorized_keys 重启 sshd 服务：systemctl restart sshd。\nssh-agent # 私钥设置了密码以后，每次使用都必须输入密码，非常麻烦。ssh-agent 命令就是为了解决这个问题，它让用户在整个 Bash 对话（session）之中，只在第一次使用 SSH 命令时输入密码，然后将私钥保存在内存中，后面都不需要再输入私钥的密码了。\n使用步骤：\n第一步，新建一个命令行对话：\n# bash 可以换成 zsh，fish 等 $ ssh-agent bash 也可以在当前对话启用 ssh-agent：\n$ eval `ssh-agent` 第二步，在新建的 Shell 对话里面，使用 ssh-add 命令添加默认的私钥：\n# 添加默认的私钥 $ ssh-add Enter passphrase for /home/you/.ssh/id_dsa: ******** Identity added: /home/you/.ssh/id_dsa (/home/you/.ssh/id_dsa) # 添加指定的私钥 $ ssh-add other-key-file 添加私钥时，要输入密码，之后在这个会话中，就不再需要输入私钥密码了。\n第三步，使用 ssh 命令正常登录远程服务器。\n$ ssh hostname 退出 ssh-agent：\n$ ssh-agent -k 也可以直接关闭 shell 会话。\nSSH 服务器 # 配置文件 # 服务端配置文件 /etc/ssh/sshd_config。\n每行都是配置项和对应的值，配置项的大小写不敏感，与值之间使用空格分隔。注释只能放在一行的开头，不能放在一行的结尾。\nscp 和 sftp # scp # scp（secure copy），是 SSH 提供的一个客户端程序，用来在两台主机之间加密传送文件。\n# 本地文件复制到远程 $ scp file.txt user@hostname:/remote/directory # 将本机整个目录拷贝到远程目录下 $ scp -r local/directory user@hostname:/remote_directory/ # 将本机目录下的所有内容拷贝到远程目录下 $ scp -r local/directory/* user@hostname:/remote_directory/ # 远程文件复制到本地 $ scp user@hostname:/remote/file.txt /local/directory # 拷贝远程目录下的所有内容，到本机目录下 $ scp -r user@hostname:directory/SourceFolder TargetFolder sftp # sftp 是 SSH 提供的一个客户端应用程序，主要用来安全地访问 FTP。\n$ sftp user@hostname 验证成功以后，就会出现 FTP 的提示符 sftp\u0026gt;：\n$ sftp root@example.com root@example.com\u0026#39;s password: Connected to example.com. sftp\u0026gt; 然后就可以输入 FTP 命令。\n"},{"id":18,"href":"/os-learn/docs/commands/19_ftp/","title":"FTP","section":"Linux 常用命令","content":" FTP # ftp 协议的全称是文件传输协议。\nFTP 采用两个 TCP 连接来传输一个文件：\n控制连接：服务器以被动的方式，打开众所周知用于 FTP 的端口 21，客户端则主动发起连接。该连接将命令从客户端传给服务器，并传回服务器的应答。常用的命令有： list 获取文件目录 reter 取一个文件 store 存一个文件 数据连接：每当一个文件在客户端与服务器之间传输时，就创建一个数据连接。 FTP 的两种模式 # 两种模式都是站在 FTP 服务器的角度来说的。\n主动模式（PORT） # 客户端随机打开一个大于 1024 的端口 N，向服务器的命令端口 21 发起连接，同时开放 N+1 端口监听，并向服务器发出 port N+1 命令，由服务器从自己的数据端口 20，主动连接到客户端指定的数据端口 N+1。\n被动模式（PASV） # 当开启一个 FTP 连接时，客户端打开两个任意的本地端口 N（大于 1024）和 N+1。第一个端口连接服务器的 21 端口，提交 PASV 命令。然后，服务器会开启一个任意的端口 P（大于 1024），返回 227 entering passive mode 消息，里面有 FTP 服务器开放的用来进行数据传输的端口。客 户端收到消息取得端口号之后，会通过 N+1 号端口连接服务器的端口 P，然后在两个端口之间进行数据传输。\nvsftpd # vsftpd 实现了 ftp 协议。\n安装：yum install vsftpd ftp ftp 是客户端。 启动：systemctl start vsftpd.service 连接 vsftpd：ftp \u0026lt;host\u0026gt;\n[root@SGDLITVM0905 ~]# ftp localhost Connected to localhost (127.0.0.1). 220 (vsFTPd 3.0.2) Name (localhost:root): ftp # ftp 匿名账户，不需要密码 331 Please specify the password. Password: # 这里密码为空，直接回车 230 Login successful. Remote system type is UNIX. Using binary mode to transfer files. ftp\u0026gt; ls 227 Entering Passive Mode (127,0,0,1,190,29). 150 Here comes the directory listing. drwxr-xr-x 2 0 0 6 Apr 01 04:55 pub 226 Directory send OK. ftp\u0026gt; quit 221 Goodbye. [root@SGDLITVM0905 ~]# ls /var/ftp/ # 匿名账户登录后，会在该目录下 pub # 需要共享的文件放在该目录下，就可以被匿名账户访问 vsftpd 支持系统的本地用户：\n[root@SGDLITVM0905 ~]# useradd user1 [root@SGDLITVM0905 ~]# echo 123 | passwd --stdin user1 Changing password for user user1. passwd: all authentication tokens updated successfully. [root@SGDLITVM0905 ~]# ftp localhost Connected to localhost (127.0.0.1). 220 (vsFTPd 3.0.2) Name (localhost:root): user1 331 Please specify the password. Password: 230 Login successful. Remote system type is UNIX. Using binary mode to transfer files. ftp\u0026gt; ls -l # 登录后会进入到 user1 的 home 目录下 227 Entering Passive Mode (127,0,0,1,229,126). 150 Here comes the directory listing. 226 Directory send OK. ftp\u0026gt; quit 221 Goodbye. [root@SGDLITVM0905 ~]# su - user1 [user1@SGDLITVM0905 ~]$ ls vsftpd 配置 # 主要配置文件：\n/etc/vsftpd/vsftpd.conf 主配置文件 /etc/vsftpd/ftpusers 用户黑名单，不允许登录 ftp 服务器的用户，例如 root 权限太大，可以访问到所有文件，所以被禁止使用登录。 /etc/vsftpd/user_list 用户白名单 vsftpd.conf 配置：\n# 允许匿名用户登陆，匿名用户使用的登陆名为 ftp 或 anonymous # 匿名用户家目录 /var/ftp，且只能下载不能上传 anonymous_enable=YES # 允许本地用户登陆 local_enable=YES # 本地用户是否可以写入 write_enable=YES # 设置 FTP 服务器建立连接所监听的端口，默认值为 21 listen_port=21 # 指定 FTP 使用 20 端口进行数据传输，默认值为 YES connect_from_port_20=YES # 是否启用 vsftpd.user_list 文件 userlist_enable=YES # 决定 vsftpd.user_list 文件中的用户是否能够访问 FTP 服务器。若设置为 YES，则 vsftpd.user_list 文件中的用户不允许访问 FTP，若设置为 NO，则只有 vsftpd.user_list 文件中的用户才能访问 FTP。 userlist_deny=YES 上面的配置中 local_enable，如果 selinux 为 enforcing 需要检查 ftp_home_dir 是否为 on。\n[root@SGDLITVM0905 ~]# getsebool -a | grep ftpd ftpd_anon_write --\u0026gt; off ftpd_connect_all_unreserved --\u0026gt; off ftpd_connect_db --\u0026gt; off ftpd_full_access --\u0026gt; off ftpd_use_cifs --\u0026gt; off ftpd_use_fusefs --\u0026gt; off ftpd_use_nfs --\u0026gt; off ftpd_use_passive_mode --\u0026gt; off [root@SGDLITVM0905 ~]# setsebool -P ftpd_use_nfs 1 [root@SGDLITVM0905 ~]# getsebool -a | grep ftpd ftpd_anon_write --\u0026gt; off ftpd_connect_all_unreserved --\u0026gt; off ftpd_connect_db --\u0026gt; off ftpd_full_access --\u0026gt; off ftpd_use_cifs --\u0026gt; off ftpd_use_fusefs --\u0026gt; off ftpd_use_nfs --\u0026gt; on ftpd_use_passive_mode --\u0026gt; off 修改后使用 systemctl reload vsftpd 使配置生效。\n登录另一台机器，使用 ftp 上传文件：\n[root@SGDLITVM0906 ~]# ftp 16.187.191.150 # 连接 vsftpd Connected to 16.187.191.150 (16.187.191.150). 220 (vsFTPd 3.0.2) Name (16.187.191.150:root): user1 331 Please specify the password. Password: 230 Login successful. Remote system type is UNIX. Using binary mode to transfer files. ftp\u0026gt; ls # 查看 user1 的 home 目录 227 Entering Passive Mode (16,187,191,150,84,31). 150 Here comes the directory listing. 226 Directory send OK. ftp\u0026gt; !ls # 查看当前主机的本地目录 anaconda-ks.cfg original-ks.cfg upload.txt workspace workspace2 ftp\u0026gt; put upload.txt # 使用 put 命令上传文件 local: upload.txt remote: upload.txt 227 Entering Passive Mode (16,187,191,150,100,251). 150 Ok to send data. 226 Transfer complete. ftp\u0026gt; get \u0026lt;file\u0026gt; # 使用 get 下载文件 虚拟用户 # guest_enable=YES guest_username=vuser user_config_dir=/etc/vsftpd/vuserconfig allow_writeable_chroot=YES pam_service_name=vsftpd.vuser "},{"id":19,"href":"/os-learn/docs/commands/20_nfs/","title":"NFS","section":"Linux 常用命令","content":" NFS # NFS 在 Linux 中会默认安装。\nNFS 的主配置文件：/etc/exports。\n[root@SGDLITVM0905 ~]# cat /etc/exports /data/share *(rw,sync,all_squash) /data/share2 10.222.77.0/24(rw,sync,insecure,no_subtree_check,no_root_squash) /var/vols/itom/core *(rw,sync,anonuid=1999,anongid=1999,root_squash) ... /data/share2 是要共享目录，而且必须要存在。 10.222.77.0/24 表示允许 IP 在该 10.222.77.0/24 网段的客户端挂载。设置为 * 即允许所有客户端挂载，如 /home *(ro,sync,insecure,no_root_squash)，设置 /home 目录允许所有客户端只读挂载。 一个目录可以配置多个 IP 权限，/data/share 10.0.0.1(rw) 10.0.0.2(ro)，表示 10.0.0.1 访问时是读写权限，10.0.0.2 访问时是只读权限，注意 IP 和括号之间不要有空格，否则会当做两个配置。 目录设置：\nro 只读访问 rw 读写访问 sync 确保数据写入时从内存同步到磁盘 async 将数据先保存在内存缓冲区中，必要时才写入磁盘 secure nfs 通过 1024 以下的安全 TCP/IP 端口发送 insecure nfs 通过 1024 以上的端口发送 root_squash 将 root 用户及所属组都映射为匿名用户或用户组（默认设置） no_root_squash 与 rootsquash 取反 anonuid=xxx 将远程访问的所有用户都映射为匿名用户，并指定该用户为本地用户（UID=xxx） anongid=xxx 将远程访问的所有用户组都映射为匿名用户组账户，并指定该匿名用户组账户为本地用户组账户（GID=xxx） wdelay 检查是否有相关的写操作，如果有则将这些写操作一起执行，这样可以提高效率（默认设置） no_wdelay 若有写操作则立即执行，应与 sync 配合使用 hide 在 nfs 共享目录中不共享其子目录 no_hide 共享 nfs 目录的子目录 subtree_check 如果共享 /usr/bin 之类的子目录时，强制 nfs 检查父目录的权限（默认） no_subtree_check 不检查父目录权限 all_squash 将远程访问的所有普通用户及所属组都映射为匿名用户或用户组（nfsnobody） no_all_squash 与 all_squash 取反（默认设置） [root@SGDLITVM0905 ~]# showmount -e localhost # 查看指定主机有哪些共享目录 Export list for localhost: /data/share * /var/vols/demochart/demochart-db-volume * /var/vols/demochart/demochart-data-volume * /var/vols/demochart/demochart-conf-volume * [root@SGDLITVM0905 ~]# ls /data/share testnfs [root@SGDLITVM0905 ~]# mount -t nfs localhost:/data/share /mnt # 挂载指定主机 localhost 下的共享目录 /data/share 到 /mnt [root@SGDLITVM0905 ~]# ls /mnt testnfs [root@SGDLITVM0905 ~]# cd /mnt [root@SGDLITVM0905 ~]# touch testnfs2 "},{"id":20,"href":"/os-learn/docs/commands/21_dns/","title":"DNS","section":"Linux 常用命令","content":" DNS # DNS（Domain Name System 的缩写）域名系统。 FQDN（Full Qualified Domain Name）完全限定域名。FQDN 由两部分组成:主机名和域名。例如 www.baidu.com，主机名是 www，主机位于域名 baidu.com 中。\nBIND # DNS 主要靠 BIND 这个软件来实现。\n安装 yum install bind bind-utils 启动 systemctl start named.service 配置文件 # 主配置文件 /etc/named.conf。\n"},{"id":21,"href":"/os-learn/docs/commands/22_kernel_upgrade/","title":"内核升级","section":"Linux 常用命令","content":" 内核升级 # rpm 格式内核 # 查看内核版本：\n[root@pooky ~]# uname -r 3.10.0-862.el7.x86_64 [root@pooky ~]# 安装指定的内核版本：yum install kernel-3.10.0\n升级内核：yum update，升级内核和其他软件包\n源码编译安装内核 # 安装依赖：\nyum install gcc gcc-c++ make ncurses-devel openssl-devel elfutils-libelf-devel 下载并解压缩内核：\nhttps://www.kernel.org tar xvf linux-5.1.10.tar.xz -C /usr/src/kernels 配置内核参数编译参数，进入内核源码目录：\ncd /usr/src/kernels/linux-5.1.10 make menuconfig|allyesconfig|allnoconfig，不同于 ./configure ，因为内核有很多参数需要配置。 menuconfig，会显示一个配置菜单，可以自己选择配置 allyesconfig，选择所有配置 allnoconfig，所有配置都不选择 使用当前系统内核配置：\ncp /boot/config-\u0026lt;kernelversion\u0026gt;.\u0026lt;platform\u0026gt; /usr/src/kernels/linux-5.1.10/.config，例如 cp /boot/config-config-3.10.0-862.el7.x86_64 /usr/src/kernels/linux-5.1.10/.config 编译安装 # lscpu，查看 cpu，可以查看内核的数量 make -j2 all ，编译，j2 表示使用两个内核编译。all 表示使用所有编译选项编译 make modules_install 安装内核模块，make install 安装内核 rebot 之后新的内核就会引导界面。选择新的内核。 "},{"id":22,"href":"/os-learn/docs/commands/23_pty_tty/","title":"pty","section":"Linux 常用命令","content":" pty # pty（pseudo terminal）伪终端。tty 可以直接理解为终端。\ntty # tty 全称为 Teletypes（电传打字机），是通过串行线用打印机键盘通过阅读和发送信息的东西，后来这东西被键盘和显示器取代，所以现在叫终端比较合适。\n随着 linux 的发展，终端固定再内核层过于僵化，某些进程需要自主实现一个终端模拟器，比如 ssh，xterm。而 tty 完全由内核接管。用户态无法使用 tty 的功 能，于是 linux 提出将终端仿真移动至用户态，这就是 pty 的由来。\n当创建一个伪终端时，会在 /dev/pts 目录下创建一个设备文件：/dev/pts/8。\npty # pty 由 master 和 slave 两端构成，在任何一端的输入都会传达到另一端。与 tty 不同，系统中并不存在 pty 这种文件，它是由 pts（pseudo-terminal slave） 和 ptmx（pseudo-teiminal master）两种设备文件来实现的。\npts # pts（pseudo-terminal slave）即伪终端的 slave 端。在 Linux 的 /dev/pts/ 文件夹下有对应设设备文件。可以通过 tty 命令查看当前用户的登录终端：\n[root@shcCDFrh75vm7 ~]# tty /dev/pts/0 当我们设备文件 /dev/pts/0 进行输出时，屏幕上会显示相应输出：\n[root@shcCDFrh75vm7 ~]# echo hello \u0026gt;/dev/pts/0 hello [root@shcCDFrh75vm7 ~]# 如果访问别的 slave 文件，比如 /dev/pts/9，则会返回权限不足错误（root 除外）。\nptmx # ptmx (pseudo-terminal master) 是伪终端的 master 端。在 /dev 下仅有 2 个 ptmx 文件：\n[root@shcCDFrh75vm7 ~]# ll /dev/ptmx crw-rw-rw-. 1 root tty 5, 2 Sep 30 15:31 /dev/ptmx [root@shcCDFrh75vm7 ~]# ll /dev/pts/ptmx c---------. 1 root root 5, 2 Jul 28 11:29 /dev/pts/ptmx 原理 # 当 linux 系统创建一个新的 terminal 时(比如上面的 /dev/pts/0)\n首先执行 ptm = open('/dev/ptmx',...)\n接下来 fork(),然后子进程将打开 /dev/pts/0,dup2 到 0，1 和2 句柄上,随后执行 execl 启动一个 shell.\npts = open(\u0026#39;/dev/pts/1\u0026#39;,...); dup2(pts, 0); // 对应 lib 库中 stdin dup2(pts, 1); // 对应 lib 库中 stdout dup2(pts, 2); // 对应 lib 库中 stderr close(pts); execl(\u0026#34;/system/bin/sh\u0026#34;, \u0026#34;/system/bin/sh\u0026#34;, NULL); // 这样 sh 输入数据将全部来自 pts, // sh 的输出数据也都全部输送到 pts,也就直接送到了打开 ptmx 的新 terminal 中. 新 terminal 将启动 GUI,捕获按键数据,然后写入 ptm，pts 将收到数据，进而 sh 将从 stdin 中获得数据，于是 sh 将作进一步运算,将结果送给 stdout 或 stderr,进而送给 pts,于是 ptm 获得数据,然后 terminal 的 GUI 将数据显示出来。\n总结 # 真正的硬件终端基本上已经看不到了，现在所说的终端、伪终端都是软件仿真终端 (即终端模拟软件) 一些连接了键盘和显示器的系统中，我们可以接触到运行在内核态的软件仿真终端 (tty1-tty6) 通过 SSH 等方式建立的连接中使用的都是伪终端 伪终端是运行在用户态的软件仿真终端 "}]