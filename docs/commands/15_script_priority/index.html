<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="脚本控制 # 脚本控制一般分为两种：
脚本的优先级控制 通过信号控制 脚本优先级控制 # nice 和 renice 可以调整脚本的优先级，调整资源的占用，如 CPU。 避免不可控的死循环 死循环会导致 CPU 占用过高 死循环会导致死机，创建大量的子进程，叫做 fock 炸弹。如 .(){.|.&};.，可以当做 func(){func|func &}; func。 ulimit -a 可以查看当前的终端的系统限制：
[root@pooky ~]# ulimit -a core file size (blocks, -c) 0 data seg size (kbytes, -d) unlimited scheduling priority (-e) 0 file size (blocks, -f) unlimited pending signals (-i) 63408 max locked memory (kbytes, -l) 64 max memory size (kbytes, -m) unlimited open files (-n) 1024 pipe size (512 bytes, -p) 8 POSIX message queues (bytes, -q) 819200 real-time priority (-r) 0 stack size (kbytes, -s) 8192 cpu time (seconds, -t) unlimited max user processes (-u) 63408 # 用户的最大进程数 virtual memory (kbytes, -v) unlimited file locks (-x) unlimited 当 fock 炸弹创建大量的进程，超过 max user processes 的限制时，系统就会停止响应，因为 CPU 在不停的创建子进程。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="脚本控制"><meta property="og:description" content="脚本控制 # 脚本控制一般分为两种：
脚本的优先级控制 通过信号控制 脚本优先级控制 # nice 和 renice 可以调整脚本的优先级，调整资源的占用，如 CPU。 避免不可控的死循环 死循环会导致 CPU 占用过高 死循环会导致死机，创建大量的子进程，叫做 fock 炸弹。如 .(){.|.&};.，可以当做 func(){func|func &}; func。 ulimit -a 可以查看当前的终端的系统限制：
[root@pooky ~]# ulimit -a core file size (blocks, -c) 0 data seg size (kbytes, -d) unlimited scheduling priority (-e) 0 file size (blocks, -f) unlimited pending signals (-i) 63408 max locked memory (kbytes, -l) 64 max memory size (kbytes, -m) unlimited open files (-n) 1024 pipe size (512 bytes, -p) 8 POSIX message queues (bytes, -q) 819200 real-time priority (-r) 0 stack size (kbytes, -s) 8192 cpu time (seconds, -t) unlimited max user processes (-u) 63408 # 用户的最大进程数 virtual memory (kbytes, -v) unlimited file locks (-x) unlimited 当 fock 炸弹创建大量的进程，超过 max user processes 的限制时，系统就会停止响应，因为 CPU 在不停的创建子进程。"><meta property="og:type" content="article"><meta property="og:url" content="http://shipengqi.github.io/os-learn/docs/commands/15_script_priority/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-11-15T17:26:03+08:00"><title>脚本控制 | OS Learning</title><link rel=manifest href=/os-learn/manifest.json><link rel=icon href=/os-learn/favicon.png><link rel=stylesheet href=/os-learn/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz+OQteg=" crossorigin=anonymous><script defer src=/os-learn/flexsearch.min.js></script>
<script defer src=/os-learn/en.search.min.5f5ef0e9793825f8025486a61037897ed49846ad920cbcaa8d00a88521c2d5ef.js integrity="sha256-X17w6Xk4JfgCVIamEDeJftSYRq2SDLyqjQCohSHC1e8=" crossorigin=anonymous></script>
<script defer src=/os-learn/sw.min.73e4e12d3b3ff9b5bd6410a479234d8908ebac0e4d11ef31f508715b8e7f7c7d.js integrity="sha256-c+ThLTs/+bW9ZBCkeSNNiQjrrA5NEe8x9QhxW45/fH0=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/os-learn/><span>OS Learning</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://shipengqi.github.io/ target=_blank rel=noopener>Blog</a></li><li><a href=https://github.com/shipengqi/os-learn target=_blank rel=noopener>Github</a></li></ul><ul><li><span>Linux 常用命令</span><ul><li><a href=/os-learn/docs/commands/01_view_text/>查看文件内容</a></li><li><a href=/os-learn/docs/commands/02_tar/>打包压缩</a></li><li><a href=/os-learn/docs/commands/03_vim/>vim</a></li><li><a href=/os-learn/docs/commands/04_user_manage/>用户管理</a></li><li><a href=/os-learn/docs/commands/05_file_perm/>文件权限</a></li><li><a href=/os-learn/docs/commands/06_network/>网络管理</a></li><li><a href=/os-learn/docs/commands/07_package_manage/>包管理器</a></li><li><a href=/os-learn/docs/commands/08_grup/>grup</a></li><li><a href=/os-learn/docs/commands/09_process/>进程管理</a></li><li><a href=/os-learn/docs/commands/10_systemd/>systemctl</a></li><li><a href=/os-learn/docs/commands/11_selinux/>SELinux</a></li><li><a href=/os-learn/docs/commands/12_mem_disk/>内存和磁盘</a></li><li><a href=/os-learn/docs/commands/13_sar/>查看系统状态</a></li><li><a href=/os-learn/docs/commands/14_shell/>Shell</a></li><li><a href=/os-learn/docs/commands/15_script_priority/ class=active>脚本控制</a></li><li><a href=/os-learn/docs/commands/16_text_operation/>操作文本</a></li><li><a href=/os-learn/docs/commands/17_firewall/>防火墙</a></li><li><a href=/os-learn/docs/commands/18_ssh/>SSH</a></li><li><a href=/os-learn/docs/commands/19_ftp/>FTP</a></li><li><a href=/os-learn/docs/commands/20_nfs/>NFS</a></li><li><a href=/os-learn/docs/commands/21_dns/>DNS</a></li><li><a href=/os-learn/docs/commands/22_kernel_upgrade/>内核升级</a></li><li><a href=/os-learn/docs/commands/23_pty_tty/>pty</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/os-learn/svg/menu.svg class=book-icon alt=Menu></label>
<strong>脚本控制</strong>
<label for=toc-control><img src=/os-learn/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#脚本控制>脚本控制</a><ul><li><a href=#脚本优先级控制>脚本优先级控制</a></li><li><a href=#捕获信号>捕获信号</a></li><li><a href=#计划任务>计划任务</a><ul><li><a href=#一次性计划任务>一次性计划任务</a></li><li><a href=#周期性计划任务>周期性计划任务</a></li><li><a href=#延时计划任务>延时计划任务</a></li><li><a href=#任务锁>任务锁</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=脚本控制>脚本控制
<a class=anchor href=#%e8%84%9a%e6%9c%ac%e6%8e%a7%e5%88%b6>#</a></h1><p>脚本控制一般分为两种：</p><ul><li>脚本的优先级控制</li><li>通过信号控制</li></ul><h2 id=脚本优先级控制>脚本优先级控制
<a class=anchor href=#%e8%84%9a%e6%9c%ac%e4%bc%98%e5%85%88%e7%ba%a7%e6%8e%a7%e5%88%b6>#</a></h2><ul><li><code>nice</code> 和 <code>renice</code> 可以调整脚本的优先级，调整资源的占用，如 CPU。</li><li>避免不可控的死循环<ul><li>死循环会导致 CPU 占用过高</li><li>死循环会导致死机，创建大量的子进程，叫做 fock 炸弹。如 <code>.(){.|.&};.</code>，可以当做 <code>func(){func|func &}; func</code>。</li></ul></li></ul><p><code>ulimit -a</code> 可以查看当前的终端的系统限制：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>[</span>root@pooky ~<span style=color:#f92672>]</span><span style=color:#75715e># ulimit -a</span>
</span></span><span style=display:flex><span>core file size          <span style=color:#f92672>(</span>blocks, -c<span style=color:#f92672>)</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>data seg size           <span style=color:#f92672>(</span>kbytes, -d<span style=color:#f92672>)</span> unlimited
</span></span><span style=display:flex><span>scheduling priority             <span style=color:#f92672>(</span>-e<span style=color:#f92672>)</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>file size               <span style=color:#f92672>(</span>blocks, -f<span style=color:#f92672>)</span> unlimited
</span></span><span style=display:flex><span>pending signals                 <span style=color:#f92672>(</span>-i<span style=color:#f92672>)</span> <span style=color:#ae81ff>63408</span>
</span></span><span style=display:flex><span>max locked memory       <span style=color:#f92672>(</span>kbytes, -l<span style=color:#f92672>)</span> <span style=color:#ae81ff>64</span>
</span></span><span style=display:flex><span>max memory size         <span style=color:#f92672>(</span>kbytes, -m<span style=color:#f92672>)</span> unlimited
</span></span><span style=display:flex><span>open files                      <span style=color:#f92672>(</span>-n<span style=color:#f92672>)</span> <span style=color:#ae81ff>1024</span>
</span></span><span style=display:flex><span>pipe size            <span style=color:#f92672>(</span><span style=color:#ae81ff>512</span> bytes, -p<span style=color:#f92672>)</span> <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>POSIX message queues     <span style=color:#f92672>(</span>bytes, -q<span style=color:#f92672>)</span> <span style=color:#ae81ff>819200</span>
</span></span><span style=display:flex><span>real-time priority              <span style=color:#f92672>(</span>-r<span style=color:#f92672>)</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>stack size              <span style=color:#f92672>(</span>kbytes, -s<span style=color:#f92672>)</span> <span style=color:#ae81ff>8192</span>
</span></span><span style=display:flex><span>cpu time               <span style=color:#f92672>(</span>seconds, -t<span style=color:#f92672>)</span> unlimited
</span></span><span style=display:flex><span>max user processes              <span style=color:#f92672>(</span>-u<span style=color:#f92672>)</span> <span style=color:#ae81ff>63408</span>    <span style=color:#75715e># 用户的最大进程数</span>
</span></span><span style=display:flex><span>virtual memory          <span style=color:#f92672>(</span>kbytes, -v<span style=color:#f92672>)</span> unlimited
</span></span><span style=display:flex><span>file locks                      <span style=color:#f92672>(</span>-x<span style=color:#f92672>)</span> unlimited
</span></span></code></pre></div><p>当 fock 炸弹创建大量的进程，超过 max user processes 的限制时，系统就会停止响应，因为 CPU 在不停的创建子进程。</p><h2 id=捕获信号>捕获信号
<a class=anchor href=#%e6%8d%95%e8%8e%b7%e4%bf%a1%e5%8f%b7>#</a></h2><ul><li><code>kill</code> 默认发送 15 号信号给进程。</li><li><code>ctrl + c</code> 发送 2 号信号。</li><li><strong>9 号信号不可阻塞</strong>，<code>trap</code> 是无法捕获的。</li></ul><p>有些应用程序，不希望被 <code>ctrl + c</code> 或者 <code>kill</code> 的信号中断，就可以使用 <code>trap</code> 捕获信号，来屏蔽掉这些信号。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>trap <span style=color:#e6db74>&#34;echo sig 15&#34;</span> <span style=color:#ae81ff>15</span>
</span></span><span style=display:flex><span>trap <span style=color:#e6db74>&#34;echo sig 2&#34;</span> <span style=color:#ae81ff>2</span>     <span style=color:#75715e># 捕获了 ctrl + c 的信号</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>echo $$
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> :
</span></span><span style=display:flex><span><span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  :
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span>
</span></span></code></pre></div><h2 id=计划任务>计划任务
<a class=anchor href=#%e8%ae%a1%e5%88%92%e4%bb%bb%e5%8a%a1>#</a></h2><h3 id=一次性计划任务>一次性计划任务
<a class=anchor href=#%e4%b8%80%e6%ac%a1%e6%80%a7%e8%ae%a1%e5%88%92%e4%bb%bb%e5%8a%a1>#</a></h3><p><code>at [OPTIONS] &lt;系统时间></code> 命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>[</span>root@pooky tmp<span style=color:#f92672>]</span><span style=color:#75715e># date</span>
</span></span><span style=display:flex><span>Thu Sep <span style=color:#ae81ff>10</span> 21:21:13 CST <span style=color:#ae81ff>2020</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@pooky tmp<span style=color:#f92672>]</span><span style=color:#75715e># at 21:23</span>
</span></span><span style=display:flex><span>at&gt; echo hello &gt; /tmp/hello.txt
</span></span><span style=display:flex><span>at&gt; &lt;EOT&gt;
</span></span><span style=display:flex><span>job <span style=color:#ae81ff>2</span> at Thu Sep <span style=color:#ae81ff>10</span> 21:23:00 <span style=color:#ae81ff>2020</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@pooky tmp<span style=color:#f92672>]</span><span style=color:#75715e># atq</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span> Thu Sep <span style=color:#ae81ff>10</span> 21:23:00 <span style=color:#ae81ff>2020</span> a root
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@pooky tmp<span style=color:#f92672>]</span><span style=color:#75715e># cat /tmp/hello.txt</span>
</span></span><span style=display:flex><span>hello
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@pooky tmp<span style=color:#f92672>]</span><span style=color:#75715e># ls -l /tmp/hello.txt</span>
</span></span><span style=display:flex><span>-rw-r--r--. <span style=color:#ae81ff>1</span> root root <span style=color:#ae81ff>6</span> Sep <span style=color:#ae81ff>10</span> 21:23 /tmp/hello.txt
</span></span></code></pre></div><p><code>at</code> 命令执行计划任务之后，可以使用 <code>ctrl + d</code> 退出。
<code>atq</code> 命令可以查看还没有执行的一次性计划任务。</p><p>选项：</p><ul><li><code>-m</code>：当 <code>a</code>t 的工作完成后，即使没有输出讯息，亦以 email 通知使用者该工作已完成。</li><li><code>-l</code>：<code>at -l</code> 相当于 <code>atq</code>，列出目前系统上面的所有该使用者的 <code>at</code> job。</li><li><code>-d</code>：<code>at -d</code> 相当于 <code>atrm</code> ，可以取消一个在 <code>at</code> job；</li><li><code>-v</code>：可以使用较明显的时间格式列出 <code>at</code> job；</li><li><code>-c</code>：可以列出后面接的该项工作的实际指令内容。</li></ul><h3 id=周期性计划任务>周期性计划任务
<a class=anchor href=#%e5%91%a8%e6%9c%9f%e6%80%a7%e8%ae%a1%e5%88%92%e4%bb%bb%e5%8a%a1>#</a></h3><p>Linux 默认安装 <code>crontab</code>，用来执行周期性任务。<code>crond</code> 进程会定期检查是否有要执行的任务，如果有，则自动执行。</p><p><code>crontab [OPTIONS] [CMD]</code> 命令，配置计划任务的格式，如 <code>0 1 * * * root /user/local/run.sh</code>，每个段分别表示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>minute   hour   day   month   week   command
</span></span></code></pre></div><ul><li><code>minute</code>： 分钟，从 <code>0</code> 到<code>59</code> 之间的任何整数。</li><li><code>hour</code>：小时，从 <code>0</code> 到 <code>23</code> 之间的任何整数。</li><li><code>day</code>：日期，从 <code>1</code> 到 <code>31</code> 之间的任何整数。</li><li><code>month</code>：月份，从 <code>1</code> 到 <code>12</code> 之间的任何整数。</li><li><code>week</code>: 星期几，从 <code>0</code> 到 <code>7</code> 之间的任何整数，<code>0</code> 或 <code>7</code> 代表星期日。</li><li><code>command</code>: 行的命令，可以是系统命令，也可以是脚本文件。<strong>要注意命令的路径，如果没有配置 PATH，需要写绝对路径。</strong></li></ul><p>各段中还可以使用下面的字符：</p><ul><li><code>*</code>：代表所有可能的值，例如 <code>month</code> 字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。</li><li><code>,</code>：可以用逗号隔开的值指定一个列表范围，例如，<code>1,2,5,7,8</code></li><li><code>-</code>：可以用整数之间的中杠表示一个整数范围，如 <code>1-5</code> 表示 <code>1,2,3,4,5</code></li><li><code>/</code>：可以用正斜线指定时间的间隔频率，例如 <code>0-23/2</code> 表示每两小时执行一次。同时正斜线可以和星号一起使用，如 <code>*/10</code>，如果用在 <code>minute</code> 字段，
表示每十分钟执行一次。</li></ul><p>选项：</p><ul><li><code>-e</code>：设置用户的计划任务</li><li><code>-l</code>：列出用户的计划任务</li><li><code>-r</code>：删除用户的计划任务</li><li><code>-u</code>：指定用户名，如果不指定，默认是当前用户。</li></ul><p><strong><code>/var/spool/cron/</code> 会有一个与用户同名的文件</strong>。</p><p>可以使用命令添加计划任务，也可以修改 <code>/etc/crontab</code> 配置文件：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>SHELL<span style=color:#f92672>=</span>/bin/bash
</span></span><span style=display:flex><span>PATH<span style=color:#f92672>=</span>/sbin:/bin:/usr/sbin:/usr/bin
</span></span><span style=display:flex><span>MAILTO<span style=color:#f92672>=</span>root
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># For details see man 4 crontabs</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Example of job definition:</span>
</span></span><span style=display:flex><span><span style=color:#75715e># .---------------- minute (0 - 59)</span>
</span></span><span style=display:flex><span><span style=color:#75715e># |  .------------- hour (0 - 23)</span>
</span></span><span style=display:flex><span><span style=color:#75715e># |  |  .---------- day of month (1 - 31)</span>
</span></span><span style=display:flex><span><span style=color:#75715e># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span>
</span></span><span style=display:flex><span><span style=color:#75715e># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span>
</span></span><span style=display:flex><span><span style=color:#75715e># |  |  |  |  |</span>
</span></span><span style=display:flex><span><span style=color:#75715e># *  *  *  *  * user-name  command to be executed</span>
</span></span></code></pre></div><h4 id=示例>示例
<a class=anchor href=#%e7%a4%ba%e4%be%8b>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>* * * * * command
</span></span></code></pre></div><p>每分钟执行一次 <code>command</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>10,20 * * * * command
</span></span></code></pre></div><p>每小时的第 <code>10</code> 和第 <code>20</code> 分钟执行一次。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>10,20 8-11 */2 * * command
</span></span></code></pre></div><p>每隔两天的上午 <code>8</code> 点到 <code>11</code> 点的第 <code>10</code> 和第 <code>20</code> 分钟执行。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#ae81ff>10</span> <span style=color:#ae81ff>1</span> * * 6,0 /etc/init.d/smb restart
</span></span></code></pre></div><p>每周六、周日的一点十分重启 smb</p><h4 id=日志>日志
<a class=anchor href=#%e6%97%a5%e5%bf%97>#</a></h4><p>计划任务的日志可以查看 <code>/var/log/cron</code> 文件：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>[</span>root@pooky ~<span style=color:#f92672>]</span><span style=color:#75715e># crontab -e</span>
</span></span><span style=display:flex><span>no crontab <span style=color:#66d9ef>for</span> root - using an empty one
</span></span><span style=display:flex><span>crontab: installing new crontab
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@pooky ~<span style=color:#f92672>]</span><span style=color:#75715e># tail -f /var/log/cron</span>
</span></span><span style=display:flex><span>Sep <span style=color:#ae81ff>10</span> 21:01:02 pooky run-parts<span style=color:#f92672>(</span>/etc/cron.hourly<span style=color:#f92672>)[</span>15528<span style=color:#f92672>]</span>: starting mcelog.cron
</span></span><span style=display:flex><span>Sep <span style=color:#ae81ff>10</span> 21:01:02 pooky run-parts<span style=color:#f92672>(</span>/etc/cron.hourly<span style=color:#f92672>)[</span>15546<span style=color:#f92672>]</span>: finished mcelog.cron
</span></span><span style=display:flex><span>Sep <span style=color:#ae81ff>10</span> 21:10:01 pooky CROND<span style=color:#f92672>[</span>16058<span style=color:#f92672>]</span>: <span style=color:#f92672>(</span>root<span style=color:#f92672>)</span> CMD <span style=color:#f92672>(</span>/usr/lib64/sa/sa1 <span style=color:#ae81ff>1</span> 1<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Sep <span style=color:#ae81ff>10</span> 21:20:01 pooky CROND<span style=color:#f92672>[</span>16707<span style=color:#f92672>]</span>: <span style=color:#f92672>(</span>root<span style=color:#f92672>)</span> CMD <span style=color:#f92672>(</span>/usr/lib64/sa/sa1 <span style=color:#ae81ff>1</span> 1<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Sep <span style=color:#ae81ff>10</span> 21:30:01 pooky CROND<span style=color:#f92672>[</span>17353<span style=color:#f92672>]</span>: <span style=color:#f92672>(</span>root<span style=color:#f92672>)</span> CMD <span style=color:#f92672>(</span>/usr/lib64/sa/sa1 <span style=color:#ae81ff>1</span> 1<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Sep <span style=color:#ae81ff>10</span> 21:40:01 pooky CROND<span style=color:#f92672>[</span>17936<span style=color:#f92672>]</span>: <span style=color:#f92672>(</span>root<span style=color:#f92672>)</span> CMD <span style=color:#f92672>(</span>/usr/lib64/sa/sa1 <span style=color:#ae81ff>1</span> 1<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Sep <span style=color:#ae81ff>10</span> 21:53:18 pooky crontab<span style=color:#f92672>[</span>18695<span style=color:#f92672>]</span>: <span style=color:#f92672>(</span>root<span style=color:#f92672>)</span> REPLACE <span style=color:#f92672>(</span>root<span style=color:#f92672>)</span>       <span style=color:#75715e># 表示编辑了一个 job</span>
</span></span><span style=display:flex><span>Sep <span style=color:#ae81ff>10</span> 21:53:18 pooky crontab<span style=color:#f92672>[</span>18695<span style=color:#f92672>]</span>: <span style=color:#f92672>(</span>root<span style=color:#f92672>)</span> END EDIT <span style=color:#f92672>(</span>root<span style=color:#f92672>)</span>      <span style=color:#75715e># 表示完成了编辑</span>
</span></span><span style=display:flex><span>Sep <span style=color:#ae81ff>10</span> 21:54:02 pooky CROND<span style=color:#f92672>[</span>18769<span style=color:#f92672>]</span>: <span style=color:#f92672>(</span>root<span style=color:#f92672>)</span> CMD <span style=color:#f92672>(</span>ntpdate ntp.swinfra.net<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>上面的示例设置了周期任务 <code>*/2 * * * * ntpdate ntp.swinfra.net</code> 每两分钟同步一次时间。</p><h3 id=延时计划任务>延时计划任务
<a class=anchor href=#%e5%bb%b6%e6%97%b6%e8%ae%a1%e5%88%92%e4%bb%bb%e5%8a%a1>#</a></h3><p>在有些意外情况下，周期计划任务可能没有执行，比如机器意外关机了。这时候就需要延时计划任务，可以在开机之后再延后运行。</p><p><code>/etc/cron.d/0hourly</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Run the hourly jobs</span>
</span></span><span style=display:flex><span>SHELL<span style=color:#f92672>=</span>/bin/bash
</span></span><span style=display:flex><span>PATH<span style=color:#f92672>=</span>/sbin:/bin:/usr/sbin:/usr/bin
</span></span><span style=display:flex><span>MAILTO<span style=color:#f92672>=</span>root
</span></span><span style=display:flex><span><span style=color:#ae81ff>01</span> * * * * root run-parts /etc/cron.hourly <span style=color:#75715e># 每一个小时的第一分钟 运行 run-parts /etc/cron.hourly</span>
</span></span></code></pre></div><p><code>run-parts</code> 在调用 <code>/etc/cron.hourly</code> 之后会在某处记录一个标记，表示这一个小时已经运行过。再下次开机时会检查这个标记，如果这个小时已经运行过，就不会再运行。</p><p><code>cron.hourly</code> 对应的是每小时的延时任务，其他的任务在 <code>/etc/anacrontab</code> 文件中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># /etc/anacrontab: configuration file for anacron</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># See anacron(8) and anacrontab(5) for details.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>SHELL<span style=color:#f92672>=</span>/bin/sh
</span></span><span style=display:flex><span>PATH<span style=color:#f92672>=</span>/sbin:/bin:/usr/sbin:/usr/bin
</span></span><span style=display:flex><span>MAILTO<span style=color:#f92672>=</span>root
</span></span><span style=display:flex><span><span style=color:#75715e># the maximal random delay added to the base delay of the jobs</span>
</span></span><span style=display:flex><span>RANDOM_DELAY<span style=color:#f92672>=</span><span style=color:#ae81ff>45</span> <span style=color:#75715e># 随机在 0 到 45 之间选择延时时间</span>
</span></span><span style=display:flex><span><span style=color:#75715e># the jobs will be started during the following hours only</span>
</span></span><span style=display:flex><span>START_HOURS_RANGE<span style=color:#f92672>=</span>3-22 <span style=color:#75715e># 延时任务在 3 到 22 点之间运行</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#period in days   delay in minutes   job-identifier   command</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>       <span style=color:#ae81ff>5</span>       cron.daily              nice run-parts /etc/cron.daily <span style=color:#75715e># 延时 5 分钟，就是每天的 3:05 分开始执行延时任务</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>7</span>       <span style=color:#ae81ff>25</span>      cron.weekly             nice run-parts /etc/cron.weekly
</span></span><span style=display:flex><span>@monthly <span style=color:#ae81ff>45</span>     cron.monthly            nice run-parts /etc/cron.monthly
</span></span></code></pre></div><h3 id=任务锁>任务锁
<a class=anchor href=#%e4%bb%bb%e5%8a%a1%e9%94%81>#</a></h3><p>在运行一个周期任务时，如果该任务执行时间较长，导致下一个周期开始，这样再执行任务就可能冲突。这时候可以使用任务锁来避免这种问题。</p><p><code>flock -x</code> 来运行，会加上一个排它锁：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>[</span>root@pooky ~<span style=color:#f92672>]</span><span style=color:#75715e># flock -xn &#34;/tmp/f.lock&#34; -c &#34;/root/test.sh&#34;</span>
</span></span></code></pre></div><p>&ldquo;/tmp/f.lock&rdquo; 就是锁文件。</p><p>选项：</p><ul><li><code>-s</code> 获得一个共享锁</li><li><code>-x</code> 获得一个独占锁，这是默认的</li><li><code>-u</code> 删除一个锁，通常是不需要的，因为在文件关闭时锁会自动删除</li><li><code>-n</code> 如果没有获得锁，直接失败而不是等待</li><li><code>-w</code> 如果没有获得锁，等待指定时间</li><li><code>-o</code> 在执行命令之前关闭保持锁的文件描述符</li><li><code>-c</code> 运行一个命令</li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/shipengqi/os-learn/commit/4f49c8bc26ad1442af2b9f5753687f18dc226c1a title='Last modified by shipengqi | November 15, 2023' target=_blank rel=noopener><img src=/os-learn/svg/calendar.svg class=book-icon alt=Calendar>
<span>November 15, 2023</span></a></div><div><a class="flex align-center" href=https://github.com/shipengqi/os-learn/edit/master/content/docs/commands/15_script_priority.md target=_blank rel=noopener><img src=/os-learn/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#脚本控制>脚本控制</a><ul><li><a href=#脚本优先级控制>脚本优先级控制</a></li><li><a href=#捕获信号>捕获信号</a></li><li><a href=#计划任务>计划任务</a><ul><li><a href=#一次性计划任务>一次性计划任务</a></li><li><a href=#周期性计划任务>周期性计划任务</a></li><li><a href=#延时计划任务>延时计划任务</a></li><li><a href=#任务锁>任务锁</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>