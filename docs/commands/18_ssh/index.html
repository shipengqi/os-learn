<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="SSH # telnet 是明文传输，不安全。所以应该使用 SSH 来远程连接。
ssh [-p port] user@host user 省略的话，就会使用当前登录的用户。
配置文件 # 客户端配置文件：/etc/ssh/ssh_config 服务端配置文件：/etc/ssh/sshd_config Port 22 默认端口 PermitRootLogin yes 是否允许 root 登录 AuthorizedKeysFile .ssh/authorized_keys 中间人攻击 # SSH 之所以能够保证安全，原因在于它采用了公钥加密。
整个过程是这样的：
远程主机收到用户的登录请求，把自己的公钥发给用户。 用户使用这个公钥，将登录密码加密后，发送回来。 远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。 这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像 https 协议，SSH 协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。
可以设想，如果攻击者插在用户与远程主机之间（比如在公共的 wifi 区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机。这种风险就是的&#34;中间人攻击&#34;（Man-in-the-middle attack）。
所以第一次登录远程主机，系统会出现下面的提示：
$ ssh root@16.187.189.94 The authenticity of host '16.187.189.94 (16.187.189.94)' can't be established. ECDSA key fingerprint is MD5:b0:4f:bb:ef:80:aa:07:5f:08:f2:81:5f:5f:9d:73:4f. Are you sure you want to continue connecting (yes/no)? 这段话的意思是，无法确认 host 主机的真实性，只知道它的公钥指纹，是否继续？"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="SSH"><meta property="og:description" content="SSH # telnet 是明文传输，不安全。所以应该使用 SSH 来远程连接。
ssh [-p port] user@host user 省略的话，就会使用当前登录的用户。
配置文件 # 客户端配置文件：/etc/ssh/ssh_config 服务端配置文件：/etc/ssh/sshd_config Port 22 默认端口 PermitRootLogin yes 是否允许 root 登录 AuthorizedKeysFile .ssh/authorized_keys 中间人攻击 # SSH 之所以能够保证安全，原因在于它采用了公钥加密。
整个过程是这样的：
远程主机收到用户的登录请求，把自己的公钥发给用户。 用户使用这个公钥，将登录密码加密后，发送回来。 远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。 这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像 https 协议，SSH 协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。
可以设想，如果攻击者插在用户与远程主机之间（比如在公共的 wifi 区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机。这种风险就是的&#34;中间人攻击&#34;（Man-in-the-middle attack）。
所以第一次登录远程主机，系统会出现下面的提示：
$ ssh root@16.187.189.94 The authenticity of host '16.187.189.94 (16.187.189.94)' can't be established. ECDSA key fingerprint is MD5:b0:4f:bb:ef:80:aa:07:5f:08:f2:81:5f:5f:9d:73:4f. Are you sure you want to continue connecting (yes/no)? 这段话的意思是，无法确认 host 主机的真实性，只知道它的公钥指纹，是否继续？"><meta property="og:type" content="article"><meta property="og:url" content="http://shipengqi.github.io/os-learn/docs/commands/18_ssh/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-11-15T17:26:03+08:00"><title>SSH | OS Learning</title><link rel=manifest href=/os-learn/manifest.json><link rel=icon href=/os-learn/favicon.png><link rel=stylesheet href=/os-learn/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz+OQteg=" crossorigin=anonymous><script defer src=/os-learn/flexsearch.min.js></script>
<script defer src=/os-learn/en.search.min.9da2651f3362f085ba92fedcac79d3065ce93b32c3817feded7d23b6337f4ee9.js integrity="sha256-naJlHzNi8IW6kv7crHnTBlzpOzLDgX/t7X0jtjN/Tuk=" crossorigin=anonymous></script>
<script defer src=/os-learn/sw.min.73e4e12d3b3ff9b5bd6410a479234d8908ebac0e4d11ef31f508715b8e7f7c7d.js integrity="sha256-c+ThLTs/+bW9ZBCkeSNNiQjrrA5NEe8x9QhxW45/fH0=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/os-learn/><span>OS Learning</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://shipengqi.github.io/ target=_blank rel=noopener>Blog</a></li><li><a href=https://github.com/shipengqi/os-learn target=_blank rel=noopener>Github</a></li></ul><ul><li><span>Linux 常用命令</span><ul><li><a href=/os-learn/docs/commands/01_view_text/>查看文件内容</a></li><li><a href=/os-learn/docs/commands/02_tar/>打包压缩</a></li><li><a href=/os-learn/docs/commands/03_vim/>Vim</a></li><li><a href=/os-learn/docs/commands/04_user_manage/>用户管理</a></li><li><a href=/os-learn/docs/commands/05_file_perm/>文件权限</a></li><li><a href=/os-learn/docs/commands/06_network/>网络管理</a></li><li><a href=/os-learn/docs/commands/07_package_manage/>包管理器</a></li><li><a href=/os-learn/docs/commands/08_grup/>grup</a></li><li><a href=/os-learn/docs/commands/09_process/>进程管理</a></li><li><a href=/os-learn/docs/commands/10_systemd/>systemctl</a></li><li><a href=/os-learn/docs/commands/11_selinux/>SELinux</a></li><li><a href=/os-learn/docs/commands/12_mem_disk/>内存和磁盘</a></li><li><a href=/os-learn/docs/commands/13_sar/>查看系统状态</a></li><li><a href=/os-learn/docs/commands/14_shell/>Shell</a></li><li><a href=/os-learn/docs/commands/15_script_priority/>脚本控制</a></li><li><a href=/os-learn/docs/commands/16_text_operation/>操作文本</a></li><li><a href=/os-learn/docs/commands/17_firewall/>防火墙</a></li><li><a href=/os-learn/docs/commands/18_ssh/ class=active>SSH</a></li><li><a href=/os-learn/docs/commands/19_ftp/>FTP</a></li><li><a href=/os-learn/docs/commands/20_nfs/>NFS</a></li><li><a href=/os-learn/docs/commands/21_dns/>DNS</a></li><li><a href=/os-learn/docs/commands/22_kernel_upgrade/>内核升级</a></li><li><a href=/os-learn/docs/commands/23_pty_tty/>pty</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/os-learn/svg/menu.svg class=book-icon alt=Menu></label>
<strong>SSH</strong>
<label for=toc-control><img src=/os-learn/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#ssh>SSH</a><ul><li><a href=#配置文件>配置文件</a></li><li><a href=#中间人攻击>中间人攻击</a></li><li><a href=#公钥登录>公钥登录</a></li><li><a href=#远程拷贝>远程拷贝</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=ssh>SSH
<a class=anchor href=#ssh>#</a></h1><p>telnet 是明文传输，不安全。所以应该使用 SSH 来远程连接。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ssh <span style=color:#f92672>[</span>-p port<span style=color:#f92672>]</span> user@host
</span></span></code></pre></div><p><code>user</code> 省略的话，就会使用当前登录的用户。</p><h2 id=配置文件>配置文件
<a class=anchor href=#%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6>#</a></h2><ul><li>客户端配置文件：<code>/etc/ssh/ssh_config</code></li><li>服务端配置文件：<code>/etc/ssh/sshd_config</code><ul><li>Port 22 默认端口</li><li>PermitRootLogin yes 是否允许 root 登录</li><li>AuthorizedKeysFile .ssh/authorized_keys</li></ul></li></ul><h2 id=中间人攻击>中间人攻击
<a class=anchor href=#%e4%b8%ad%e9%97%b4%e4%ba%ba%e6%94%bb%e5%87%bb>#</a></h2><p>SSH 之所以能够保证安全，原因在于它采用了公钥加密。</p><p>整个过程是这样的：</p><ol><li>远程主机收到用户的登录请求，把自己的公钥发给用户。</li><li>用户使用这个公钥，将登录密码加密后，发送回来。</li><li>远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。</li></ol><p>这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像 https 协议，SSH 协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。</p><p>可以设想，如果攻击者插在用户与远程主机之间（比如在公共的 wifi 区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机。这种风险就是的"中间人攻击"（Man-in-the-middle attack）。</p><p>所以第一次登录远程主机，系统会出现下面的提示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ ssh root@16.187.189.94
</span></span><span style=display:flex><span>The authenticity of host <span style=color:#e6db74>&#39;16.187.189.94 (16.187.189.94)&#39;</span> can<span style=color:#960050;background-color:#1e0010>&#39;</span>t be established.
</span></span><span style=display:flex><span>ECDSA key fingerprint is MD5:b0:4f:bb:ef:80:aa:07:5f:08:f2:81:5f:5f:9d:73:4f.
</span></span><span style=display:flex><span>Are you sure you want to <span style=color:#66d9ef>continue</span> connecting <span style=color:#f92672>(</span>yes/no<span style=color:#f92672>)</span>?
</span></span></code></pre></div><p>这段话的意思是，无法确认 host 主机的真实性，只知道它的公钥指纹，是否继续？</p><p><strong>公钥指纹</strong>是指公钥长度较长（这里采用 RSA 算法，长达 1024 位），很难比对，所以对其进行哈希计算，将它变成一个 128 位的指纹。例如
<code>b0:4f:bb:ef:80:aa:07:5f:08:f2:81:5f:5f:9d:73:4f</code>，再进行比较，就容易多了。</p><p>远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。</p><p>如果用户决定接受这个远程主机的公钥，输入 yes。系统会出现一句提示，然后，会要求输入密码。</p><h2 id=公钥登录>公钥登录
<a class=anchor href=#%e5%85%ac%e9%92%a5%e7%99%bb%e5%bd%95>#</a></h2><p>使用密码登录，每次都必须输入密码。可以通过公钥登录：</p><ol><li>用户将自己的公钥储存在远程主机上。</li><li>登录的时候，远程主机会向用户发送一段随机字符串。</li><li>用户收到随机字符串，用自己的私钥加密后，再发给远程主机。</li><li>远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录 shell，不再要求密码。</li></ol><p>用户可以使用 <code>ssh-keygen</code> 密钥对，生成时可以对私钥设置口令（passphrase）。一般密钥对会放在 <code>$HOME/.ssh/</code> 目录下，会新生成两个文件：<code>id_rsa.pub</code> 和 <code>id_rsa</code>。前者是公钥，后者是私钥。</p><p>将公钥传送到远程主机上面：</p><ol><li>查看是否存在 <code>$HOME/.ssh/authorized_keys</code> 文件，不存在则创建该文件：</li><li>将生成的 <code>id_rsa.pub</code> 文件内容粘贴到 <code>authorized_keys</code> 文件。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>[</span>root@SGDLITVM0905 .ssh<span style=color:#f92672>]</span><span style=color:#75715e># cat authorized_keys</span>
</span></span><span style=display:flex><span>ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDaA4G5QBf3IgoA4+4iB8P2JLshyidbUZ4g4NRhMc0T5t7+LHjitnixtfoufDIFUsX3iiJqj/E53vuYtmPZdB9J+V6LMG1Ld2tPFnnzF8/7Xb+IcYLmpkBxFdH30XpuI4Kbt8nZROhTtpQ6/Hj4RLhvYbuR5xNeBkRZQoST2SwP9BzPnCPZCm4Z0X00/ol61hD9n3lEoa7riAUwzS6Sa+8wNjxf1srUJvvAk6URvN1qGZhJGAG2z+fuYcJOlggZ+fTbLOqaY+JZ/m3CSzZ7Yvl44D3JgqkFBQiBaZGvhg3reaOGxv6KrAd+gIR8QiOekZUzP7LWevthe2mYaYDDVxc9
</span></span><span style=display:flex><span>ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCbsQz/ePcNnIb7K3DHaULVRwa/GE6wxTqWSCzMzM4tVYlwfJo0bMti4qjsrJz2IVb9lH6Sfu69brr7yHRgcaeCNPKlDtrhH1bxzu4ayjoimcibeKrOfZu6qCJH+JxfwxC9eW6xQDu+Z6xigny19miSd3PhDqHloz4GZKRa2X1fPxB//F+NYuTZJvafjKCZ8eIXcjr0R53tpxdkhKpYIQ4rd8uPtZPjidrEUQcukmngG/LPhoJ6ebQ1zOmSPtXP3kVLATrrlQRWZlHqSbFJpnJHclhN8NgahtyR7ad63suHxBKLAa71QjNvSRfa0QUQ4/uqH9zBT5hbGd1IXSA3Sq1l root@shcAimeeCOS72.hpeswlab.net
</span></span><span style=display:flex><span>ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCaDa+Nl8NK7bagAp9vbuKQyh00y6UHOdNiugwc6Mcw7qsCPpV257LZDLHyrXjdQpqFy135AZTUPGozPh8TH/W6sI8jWgCl9+mYup7+/i1wwjIxnkppKV7nqrWVxEXt5LLny7M0+HCw4pC9jUlFGC5MZVV6mVyI8oTeRkZddrja0c/65Et0+ksiiT2A4yIDoKFslv5vDAYolRJx13a4ESWjsCpGQOvrxtsQqpISm0yaZO8Ha+1a6tjniEWReZNGcOajrLP4V+lv8Qi0Cl/iNIkpD+fnRFphY6RgYC5UrLFYOBCgaKgQhUBK2BOcjM1dR1IqCV9YRv+N4PLhmLweyvQJ root@autovmCOS76VM09.hpeswlab.net
</span></span></code></pre></div><p>然后再登录，就不需要输入密码了。</p><p>ssh 也提供了命令来拷贝公钥，<code>ssh-copy-id</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># -i 指定公钥文件，拷贝到对应的账户下的 authorized_keys 文件中</span>
</span></span><span style=display:flex><span>ssh-copy-id -i ~/.ssh/id_rsa.pub root@16.187.189.94
</span></span></code></pre></div><p>如果不能登录，检查远程主机的 <code>/etc/ssh/sshd_config</code> 文件，去掉如下三行注释：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e>#RSAAuthentication yes</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#PubkeyAuthentication yes</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#AuthorizedKeysFile     .ssh/authorized_keys</span>
</span></span></code></pre></div><p>重启 sshd 服务：<code>systemctl restart sshd</code>。</p><h2 id=远程拷贝>远程拷贝
<a class=anchor href=#%e8%bf%9c%e7%a8%8b%e6%8b%b7%e8%b4%9d>#</a></h2><p>远程拷贝文件使用 <code>scp</code></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/shipengqi/os-learn/commit/4f49c8bc26ad1442af2b9f5753687f18dc226c1a title='Last modified by shipengqi | November 15, 2023' target=_blank rel=noopener><img src=/os-learn/svg/calendar.svg class=book-icon alt=Calendar>
<span>November 15, 2023</span></a></div><div><a class="flex align-center" href=https://github.com/shipengqi/os-learn/edit/master/content/docs/commands/18_ssh.md target=_blank rel=noopener><img src=/os-learn/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#ssh>SSH</a><ul><li><a href=#配置文件>配置文件</a></li><li><a href=#中间人攻击>中间人攻击</a></li><li><a href=#公钥登录>公钥登录</a></li><li><a href=#远程拷贝>远程拷贝</a></li></ul></li></ul></nav></div></aside></main></body></html>